"use strict";exports.id=8241,exports.ids=[8241],exports.modules={18241:(e,s,t)=>{t.d(s,{symlinkKlippyExtensions:()=>symlinkKlippyExtensions});var n=t(38316),i=t(56368),r=t(57147),o=t(36523),a=t(98765),l=t(71017),c=t.n(l),p=t(81115),x=t(62807);let m=n.z.object({fileName:n.z.string(),path:n.z.string(),extensionName:n.z.string(),errorIfExists:n.z.boolean().optional(),errorIfNotExists:n.z.boolean().optional(),isKinematics:n.z.boolean().optional()}),y=n.z.array(m),getExtensions=()=>{let e=p.serverSchema.parse(process.env),s=e.RATOS_DATA_DIR,t=c().join(s,"klippy-extensions.json");(0,r.existsSync)(s)||(0,r.mkdirSync)(s),(0,r.existsSync)(t)||(0,r.writeFileSync)(t,"[]");let n=y.parse(JSON.parse((0,r.readFileSync)(t).toString()));return n},saveExtensions=e=>{let s=p.serverSchema.parse(process.env),t=s.RATOS_DATA_DIR,n=c().join(t,"klippy-extensions.json");(0,r.existsSync)(t)||(0,r.mkdirSync)(t),(0,r.writeFileSync)(n,JSON.stringify(e))},symlinkKlippyExtensions=async e=>{let s=p.serverSchema.parse(process.env),t=getExtensions();return await (0,x.b)({extensions:t,options:{errorIfExists:e},gitRepoPath:s.KLIPPER_DIR,relativePath,saveExtensions})},relativePath=e=>e.isKinematics?"klippy/kinematics":"klippy/extras";(0,a.Nd)({register:a.$y.input(n.z.object({json:m})).mutation(async({input:e})=>{let s=getExtensions(),{path:t,fileName:n,errorIfExists:a,extensionName:l}=e.json,p=c().join(t,n);if(!(0,r.existsSync)(p))throw new i.TRPCError({message:`File "${p}" does not exist`,code:"PRECONDITION_FAILED"});if(s.find(s=>s.extensionName===l||s.fileName===n&&!!s.isKinematics==!!e.json.isKinematics)){if(!0===a)throw new i.TRPCError({message:`${e.json.isKinematics?"A kinematic":"An"} extension called "${l}" with fileName "${n}" is already registered`,code:"PRECONDITION_FAILED"});return(0,o.getLogger)().warn(`${e.json.isKinematics?"A kinematic":"An"} extension called "${l}" with the fileName "${n}" is already registered, ignoring...`),!0}return s.push(e.json),saveExtensions(s),!0}),unregister:a.$y.input(n.z.object({extensionName:n.z.string(),errorIfNotExists:n.z.boolean().optional()})).mutation(async({input:e})=>{let s=getExtensions(),{extensionName:t}=e,n=s.findIndex(e=>e.extensionName===t);if(-1===n){if(!0===e.errorIfNotExists)throw new i.TRPCError({message:`Extension with the name "${t}" is not registered`,code:"PRECONDITION_FAILED"});return(0,o.getLogger)().warn(`Extension with the name "${t}" is not registered, ignoring...`),{result:"success",message:`Extension "${t}" does not exist. Nothing to do.`}}let r=s.splice(n,1);if(1!==r.length)throw Error("Failed to remove extension");let a=await (0,x.Y)({extension:r[0],gitRepoPath:p.serverSchema.parse(process.env).KLIPPER_DIR,relativePath});return"success"===a.result&&saveExtensions(s),a}),symlink:a.$y.input(n.z.object({errorIfExists:n.z.boolean().optional()})).mutation(async({input:e})=>await symlinkKlippyExtensions(e.errorIfExists)),unlink:a.$y.mutation(async()=>{let e=getExtensions();return await Promise.all(e.map(async e=>{let s=await (0,x.Y)({extension:e,gitRepoPath:p.serverSchema.parse(process.env).KLIPPER_DIR,relativePath});return s}))}),list:a.$y.output(y).query(async()=>getExtensions())})}};