import { ProcessLineContext } from '@/server/gcode-processor/SlidingWindowLineProcessor';
import { ActionResult } from 'next/dist/server/app-render/types';
import { BookmarkKey } from '@/server/gcode-processor/Bookmark';

/*
GCODE FORMAT NOTES
------------------
gcode in the wild includes the comment suffix with no leading whitespace. Example from orcaslicer:

SET_PRESSURE_ADVANCE ADVANCE=0.03; Override pressure advance value

*/

/*
/; generated by (\w+)\s+(.+) on (.+)/

TG notes from Helge's python impl
---------------------------------

If enable_post_processing is false, only do this:
	get slicer info
	find START_PRINT line
	find start XY coords and do the following, which appears to be an alternative to modifying the file.
				if (not enable_post_processing):
					if (first_x >= 0 and first_y >= 0):
						self.gcode.run_script_from_command("SET_GCODE_VARIABLE MACRO=START_PRINT VARIABLE=first_x VALUE=" + str(first_x))
						self.gcode.run_script_from_command("SET_GCODE_VARIABLE MACRO=START_PRINT VARIABLE=first_y VALUE=" + str(first_y))
						return True

- Processing will continue until first xy is found, and nothing else is done.

If enable_post_processing is true:



Kinds of analysis:



1. Find first occurence

Analysis action conditions:
- some only apply to a particular gcode flavour (can exclude from search list from the start)
- some only apply based on fixed flag like enable_post_processing
- some depend on some other var having been set already (can add to search list only once the dependee is found)

- 

*/

/*

Each action can have the following characteristics:
- activation condition: a condition that transitions the action from inactive to active.
	- variable dependency could be somehow automatically determined or manually expressed
		or execute maybe only execute when *any* variable has changed. Typescript can produce AST from code.
		- Have PoC AST.
		- Fail-safe regex (worst case false positive)
		- Alternative is to use an object for state store, and require that expressions reference props in
		  a consistent way so we can regex for refs.
- execute expression: expression executed for each line after activation.
	returns enum:
		Continue 	- execute on the next line
		Deactivate  - deactivate, but keep monitoring activation condition
		Remove      - deactivate and remove, no reactivation possible.
			

*/

const CHANGED_BY_RATOS = ' ; Changed by RatOS post processor: ';
const REMOVED_BY_RATOS = ' ; Removed by RatOS post processor: ';

// ; generated by PrusaSlicer 2.8.0+win64 on 2024-09-06 at 08:32:07 UTC

enum GCodeFlavour {
	Unknown = 0,
	PrusaSlicer = 1 << 0,
	OrcaSlicer = 1 << 1,
	SuperSlicer = 1 << 2,
	RatOS = 1 << 3,

	Any = 0xffff,
}

class GCodeInfo {
	static parseHeader(header: string): GCodeInfo {
		throw new Error('to do');
	}

	constructor(
		public readonly flavour: GCodeFlavour,
		public readonly version: string,
		public readonly timestamp: string,
	) {}
}

/*
class Action<TState> {
	constructor(
		activate: ((ctx: ProcessLineContext, state: TState) => ActivateResult) | true,
		execute: (ctx: ProcessLineContext, state: TState) => ExecuteResult
	) {
		if ( activate === true ) {
			this.#active = true;
		} else {
			this.#active = false;
			this.#activate = activate;
		}

		this.#execute = execute;			
	}

	#activate?: (ctx: ProcessLineContext, state: TState) => ActivateResult;
	#execute: (ctx: ProcessLineContext, state: TState) => ExecuteResult;

	#active: boolean;

	get active() : boolean
	{
		return this.#active;
	}

	readonly activateRefs: Set<string> = new Set<string>();
	readonly executeRefs: Set<string> = new Set<string>();
}
*/
/*
class actors {
	static getGcodeInfo: Active = (c,s) => {
		if (c.line?.startsWith('; generated by') ) {
			s.gcodeInfo = new GCodeInfo('PrusaSlicer', '1.0', '12345');
			return ExecuteResult.Remove;
		} else if ( s.currentLineNumber == 2 ) {
			throw new Error('Slicer identification not found.');
		}
	};
};
*/

// Logically atomic.
class BookmarkedLine {
	constructor(
		public readonly line: string,
		public readonly bookmark: BookmarkKey,
	) {}
}

/**
 * Property naming convention:
 *  'k' prefix: external configuration. Always readonly.
 *  '_' prefix: iteration-scope state that gets reset for each line
 *   no prefix: file-scope state that is maintained for the whole file
 */
class MyState {
	constructor(
		public readonly kPrinterHasIdex: boolean,
		public readonly kInpsectionOnly: boolean,
		public currentLineNumber: number = 0,
		gcodeInfo?: GCodeInfo,
		public startPrintLine?: BookmarkedLine,
		public extruderTempsBookmark?: symbol,
		public extruderTemps?: number[],
		public startPos?: [number, number],
		public _parsedCommon?: RegExpExecArray | null,
	) {
		this.#gcodeInfo = gcodeInfo;
	}

	/**
	 * Resets iteration-scope state.
	 */
	reset() {
		this._parsedCommon = undefined;
	}

	#gcodeInfo?: GCodeInfo;

	/**
	 * `gcodeInfo` is always set near the start of processing and is accessed frequently
	 * so provide a non-optional accessor for convenience.
	 */
	get gcodeInfo(): GCodeInfo {
		if (!this.#gcodeInfo) {
			throw new Error('gcodeInfo has not been set yet.');
		}
		return this.#gcodeInfo;
	}

	set gcodeInfo(value: GCodeInfo) {
		this.#gcodeInfo = value;
	}

	get gcodeInfoOrUndefined(): GCodeInfo | undefined {
		return this.#gcodeInfo;
	}
}

/**
 * Return value indicates if this actor should keep being checked. Return
 * `false` to exclude the actor from future processing. Return `void` or `true`
 * to keep checking. Throw an `Error` to abort processing.
 */
type Action =
	| ((c: ProcessLineContext, s: MyState) => boolean | void)
	| [relevantGcodeFlavours: GCodeFlavour, (c: ProcessLineContext, s: MyState) => boolean | void];

// TODO: Let's handle header parsing as an explicit action, and only construct the state object
// once it's known. Also we can immediately remove any actions which express flavour relevance.
// TODO: Compatibility check
// TODO: Already processed check
const getGcodeInfo: Action = (c, s) => {
	if (c.line?.startsWith('; generated by')) {
		s.gcodeInfo = GCodeInfo.parseHeader(c.line);
		return false;
	} else if (s.currentLineNumber == 2) {
		throw new Error('Slicer identification not found.');
	}
};

const getStartPrint: Action = (c, s) => {
	if (/^(START_PRINT|RMMU_START_PRINT)[ $]/.test(c.line)) {
		// Fix colour variable format
		c.line = c.line.replace('#', '').padEnd(512);
		c.bookmarkKey = Symbol('START_PRINT');
		s.startPrintLine = new BookmarkedLine(c.line, c.bookmarkKey);
		return false;
	}
};

const fixOtherLayerTemperature: Action = [
	GCodeFlavour.OrcaSlicer | GCodeFlavour.SuperSlicer,
	(c, s) => {
		// TODO: as soon as gcodeInfo is known, remove this action if the gcode flavour is not relevant.
		// Consider expressing relevant flavours directly as it's a common filter.
		if (!!s.startPrintLine && !s.extruderTempsBookmark) {
			if (/^_ON_LAYER_CHANGE LAYER=2[$/s;]/.test(c.line)) {
				s.extruderTempsBookmark = c.bookmarkKey = Symbol('on_layer_change 2');
				const match = /EXTRUDER_OTHER_LAYER_TEMP=([\d,]+)/.exec(s.startPrintLine.line);
				if (match) {
					s.extruderTemps = match.slice(1).map(Number);
				}
			}
			return false;
		}
	},
];

const fixOrcaSetAccelaration: Action = [
	GCodeFlavour.OrcaSlicer,
	(c, s) => {
		if (!!s.startPrintLine) {
			// SET_VELOCITY_LIMIT ACCEL=2500 ACCEL_TO_DECEL=1250
			const match = /^SET_VELOCITY_LIMIT.*\sACCEL=(\d+)/i.exec(c.line);
			if (match) {
				c.line = `M204 S${match[1]}${CHANGED_BY_RATOS}${c.line}`;
			}
		}
	},
];

/**
 * Matches `G0|G1|Tn` followed by args like `X1.2` for X, Y, Z, E and F in any order, each being optional.
 * Groups:
 * 'G' - will be 'G0' or 'G1'
 * 'T' - will be 'n', like '1' or '2', accepts any number of digits.
 * 'X' - will be the (decimal) number after 'X', like '12.3' in 'X12.3'.
 * ditto for Y, Z, E and F.
 *
 * Not-match is very cheap.
 */
const rxParseCommonCommands =
	/^(?:(?<G>G0|G1)|T(?<T>\d+))(?=\s)(?=.*(\sX(?<X>[\d.]+))|)(?=.*(\sY(?<Y>[\d.]+))|)(?=.*(\sZ(?<Z>[\d.]+))|)(?=.*(\sE(?<E>[\d.]+))|)(?=.*(\sF(?<F>[\d.]+))|)/i;

const parseCommonCommands: Action = (c, s) => {
	s._parsedCommon = rxParseCommonCommands.exec(c.line);
};

const xxx: Action = (c, s) => {};

class RatOSGcodeProcessor {
	actions = [getGcodeInfo, getStartPrint, xx, []];

	ProcessLine(ctx: ProcessLineContext) {
		// TODO!!!!
		// Write what the config description should look like.

		++lineNumber;

		new Action<MyState>(true, getGcodeInfo);

		// Do we need this?
		new ActionGroup<MyState>(
			(c, s) => {
				return s.gcodeInfo ? ActivateResult.Activate : ActivateResult.Continue;
			},
			[
				// All actions that depend on state.gcodeInfo
			],
		);
	}
}
