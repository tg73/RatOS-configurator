import { ActionResult, executeActionSequence } from '@/server/gcode-processor/ActionSequence';
import { BookmarkCollection } from '@/server/gcode-processor/BookmarkingBufferEncoder';
import { BookmarkKey } from '@/server/gcode-processor/Bookmark';
import { ProcessLineContext } from '@/server/gcode-processor/SlidingWindowLineProcessor';
import { number } from '@recoiljs/refine';

// TODO: Review pad lengths.

/*
GCODE FORMAT NOTES
------------------
gcode in the wild includes the comment suffix with no leading whitespace. Example from orcaslicer:

SET_PRESSURE_ADVANCE ADVANCE=0.03; Override pressure advance value

*/

/*
/; generated by (\w+)\s+(.+) on (.+)/

TG notes from Helge's python impl
---------------------------------

If enable_post_processing is false, only do this:
	get slicer info
	find START_PRINT line
	find start XY coords and do the following, which appears to be an alternative to modifying the file.
				if (not enable_post_processing):
					if (first_x >= 0 and first_y >= 0):
						self.gcode.run_script_from_command("SET_GCODE_VARIABLE MACRO=START_PRINT VARIABLE=first_x VALUE=" + str(first_x))
						self.gcode.run_script_from_command("SET_GCODE_VARIABLE MACRO=START_PRINT VARIABLE=first_y VALUE=" + str(first_y))
						return True

- Processing will continue until first xy is found, and nothing else is done.

If enable_post_processing is true:



Kinds of analysis:



1. Find first occurence

Analysis action conditions:
- some only apply to a particular gcode flavour (can exclude from search list from the start)
- some only apply based on fixed flag like enable_post_processing
- some depend on some other var having been set already (can add to search list only once the dependee is found)

- 

*/

/*

Each action can have the following characteristics:
- activation condition: a condition that transitions the action from inactive to active.
	- variable dependency could be somehow automatically determined or manually expressed
		or execute maybe only execute when *any* variable has changed. Typescript can produce AST from code.
		- Have PoC AST.
		- Fail-safe regex (worst case false positive)
		- Alternative is to use an object for state store, and require that expressions reference props in
		  a consistent way so we can regex for refs.
- execute expression: expression executed for each line after activation.
	returns enum:
		Continue 	- execute on the next line
		Deactivate  - deactivate, but keep monitoring activation condition
		Remove      - deactivate and remove, no reactivation possible.
			

*/

const CHANGED_BY_RATOS = ' ; Changed by RatOS post processor: ';
const REMOVED_BY_RATOS = '; Removed by RatOS post processor: ';

// ; generated by PrusaSlicer 2.8.0+win64 on 2024-09-06 at 08:32:07 UTC

enum GCodeFlavour {
	Unknown = 0,
	PrusaSlicer = 1 << 0,
	OrcaSlicer = 1 << 1,
	SuperSlicer = 1 << 2,
	RatOS = 1 << 3,

	Any = 0xffff,
}

class GCodeInfo {
	static parseHeader(header: string): GCodeInfo | Error {
		throw new Error('to do');
	}

	constructor(
		public readonly flavour: GCodeFlavour,
		public readonly version: string,
		public readonly timestamp: string,
	) {}
}

/*
class Action<TState> {
	constructor(
		activate: ((ctx: ProcessLineContext, state: TState) => ActivateResult) | true,
		execute: (ctx: ProcessLineContext, state: TState) => ExecuteResult
	) {
		if ( activate === true ) {
			this.#active = true;
		} else {
			this.#active = false;
			this.#activate = activate;
		}

		this.#execute = execute;			
	}

	#activate?: (ctx: ProcessLineContext, state: TState) => ActivateResult;
	#execute: (ctx: ProcessLineContext, state: TState) => ExecuteResult;

	#active: boolean;

	get active() : boolean
	{
		return this.#active;
	}

	readonly activateRefs: Set<string> = new Set<string>();
	readonly executeRefs: Set<string> = new Set<string>();
}
*/
/*
class actors {
	static getGcodeInfo: Active = (c,s) => {
		if (c.line?.startsWith('; generated by') ) {
			s.gcodeInfo = new GCodeInfo('PrusaSlicer', '1.0', '12345');
			return ExecuteResult.Remove;
		} else if ( s.currentLineNumber == 2 ) {
			throw new Error('Slicer identification not found.');
		}
	};
};
*/

// Logically atomic.
class BookmarkedLine {
	constructor(
		public readonly line: string,
		public readonly bookmark: BookmarkKey,
	) {}
}

/**
 * Property naming convention:
 *  'k' prefix: external configuration. Always readonly.
 *  '_' prefix: iteration-scope state that gets reset for each line
 *   no prefix: file-scope state that is maintained for the whole file
 */
class State {
	constructor(
		public readonly kPrinterHasIdex: boolean,
		public readonly kInpsectionOnly: boolean,
	) {}

	// Stream-scope fields:

	public currentLineNumber: number = -1;
	public startPrintLine?: BookmarkedLine;
	public onLayerChange2Bookmark?: symbol;
	public extruderTemps?: string[];
	public toolChangeCount = 0;
	public firstMoveX?: string;
	public firstMoveY?: string;
	public minX = Number.MAX_VALUE;
	public maxX = Number.MIN_VALUE;
	public hasPurgeTower?: boolean;

	/** Used tools, in order of first use. */
	public usedTools: number[] = [];

	// Iteration-scope fields (reset at the start of each processLine iteration):
	public _cmd?: RegExpExecArray | null;

	/**
	 * Resets iteration-scope state.
	 */
	resetIterationState() {
		this._cmd = undefined;
	}

	#gcodeInfo?: GCodeInfo;

	/**
	 * `gcodeInfo` is always set near the start of processing and is accessed frequently
	 * so provide a non-optional accessor for convenience.
	 */
	get gcodeInfo(): GCodeInfo {
		if (!this.#gcodeInfo) {
			throw new Error('gcodeInfo has not been set yet.');
		}
		return this.#gcodeInfo;
	}

	set gcodeInfo(value: GCodeInfo) {
		this.#gcodeInfo = value;
	}

	get gcodeInfoOrUndefined(): GCodeInfo | undefined {
		return this.#gcodeInfo;
	}
}

/**
 * For the function return value `ActionResult | void`, `void` is equivalent to `ActionResult.Continue`.
 */
type Action =
	| ((c: ProcessLineContext, s: State) => ActionResult | void)
	| [relevantGcodeFlavours: GCodeFlavour, (c: ProcessLineContext, s: State) => ActionResult | void];

// TODO: Let's handle header parsing as an explicit action, and only construct the state object
// once it's known. Also we can immediately remove any actions which express flavour relevance.
// TODO: Compatibility check
// TODO: Already processed check
const getGcodeInfo: Action = (c, s) => {
	let parsed = GCodeInfo.parseHeader(c.line);

	if (parsed instanceof Error) {
		parsed = GCodeInfo.parseHeader(c.getLineOrUndefined(1)?.line ?? '');
	}

	if (parsed instanceof Error) {
		throw new Error('Valid slicer identification not found');
	} else {
		s.gcodeInfo = parsed;
	}
	return ActionResult.RemoveAndStop;
};

const getStartPrint: Action = (c, s) => {
	let match =
		/^(START_PRINT|RMMU_START_PRINT)(?=[ $])((?=.*(\sINITIAL_TOOL=(?<INITIAL_TOOL>(\d+))))|)((?=.*(\sEXTRUDER_OTHER_LAYER_TEMP=(?<EXTRUDER_OTHER_LAYER_TEMP>(\d+(,\d+)*))))|)/i.exec(
			c.line,
		);
	if (match) {
		// Fix colour variable format and pad for later modification
		c.line = c.line.replace('#', '').padEnd(c.line.length + 100);
		c.bookmarkKey = Symbol('START_PRINT');
		s.startPrintLine = new BookmarkedLine(c.line, c.bookmarkKey);

		let initialTool = match.groups?.INITIAL_TOOL;
		if (initialTool) {
			s.usedTools.push(Number(initialTool));
		}

		let extruderOtherLayerTemp = match?.groups?.EXTRUDER_OTHER_LAYER_TEMP;
		if (extruderOtherLayerTemp) {
			s.extruderTemps = extruderOtherLayerTemp.split(',');
		}

		return ActionResult.RemoveAndStop;
	}
	// Stop at this point until we find START_LINE. If any actions need to inspect pre-START_LINE,
	// they must be ordered before this action. All actions ordered after this action can assume that
	// the start print line has been found.
	return ActionResult.Stop;
};

const fixOtherLayerTemperature: Action = [
	GCodeFlavour.OrcaSlicer | GCodeFlavour.SuperSlicer,
	(c, s) => {
		if (!s.onLayerChange2Bookmark) {
			if (/^_ON_LAYER_CHANGE LAYER=2[$/s;]/.test(c.line)) {
				c.line = c.line.padEnd(c.line.length + 100);
				s.onLayerChange2Bookmark = c.bookmarkKey = Symbol('on_layer_change 2');
				return ActionResult.RemoveAndStop;
			}
		}
	},
];

const fixOrcaSetAccelaration: Action = [
	GCodeFlavour.OrcaSlicer,
	(c, s) => {
		// SET_VELOCITY_LIMIT ACCEL=2500 ACCEL_TO_DECEL=1250
		const match = /^SET_VELOCITY_LIMIT.*\sACCEL=(\d+)/i.exec(c.line);
		if (match) {
			c.line = `M204 S${match[1]}${CHANGED_BY_RATOS}${c.line}`;
			return ActionResult.Stop;
		}
	},
];

/**
 * Matches `G0|G1|Tn` followed by args like `X1.2` for X, Y, Z, E and F in any order, each being optional.
 * Groups:
 * 'G' - will be 'G0' or 'G1'
 * 'T' - will be 'n', like '0' or '1', accepts any number of digits.
 * 'X' - will be the (decimal) number after 'X', like '12.3' in 'X12.3'.
 * ditto for Y, Z, E and F.
 *
 * Not-match is very cheap.
 */
const rxParseCommonCommands =
	/^(?:T(?<T>\d+))|(?:(?<G>G0|G1)(?=\s)(?=.*(\sX(?<X>[\d.]+))|)(?=.*(\sY(?<Y>[\d.]+))|)(?=.*(\sZ(?<Z>[\d.]+))|)(?=.*(\sE(?<E>[\d.]+))|)(?=.*(\sF(?<F>[\d.]+))|))/i;

const parseCommonCommands: Action = (c, s) => {
	s._cmd = rxParseCommonCommands.exec(c.line);
};

const findFirstMoveXY: Action = (c, s) => {
	if (s._cmd?.groups?.G) {
		s.firstMoveX ??= s._cmd?.groups?.X;
		s.firstMoveY ??= s._cmd?.groups?.Y;

		if (!!s.firstMoveX && !!s.firstMoveY) {
			// We don't need to do this check any more. G0/G1 are extremely frequent, so avoid any excess work.
			return ActionResult.RemoveAndContinue;
		}

		// NOTE: original ratos.py has a short-circuit when !enable_post_processing and both firstMoveX and firstMoveY have been found,
		// which calls run_script_from_command  then returns. (see around line 320). Something like this would be the equivalent
		// short circuit here: if (s.kInpsectionOnly) { throw new SomeObjectToSayAnalysisIsDone() }
	}
};

const findMinMaxX: Action = (c, s) => {
	if (s._cmd?.groups?.G) {
		let x = s._cmd?.groups?.X;
		if (x) {
			let n = Number(x);
			if (n < s.minX) {
				s.minX = n;
			} else if (n > s.maxX) {
				s.maxX = n;
			}
		}
	}
};

const processToolchange: Action = (c, s) => {
	let tool = s._cmd?.groups?.T;
	if (tool) {
		if (s.toolChangeCount++ == 0) {
			c.line = REMOVED_BY_RATOS + c.line; // Remove first toolchange
			return;
		}

		// TOOLSHIFT PROCESSING
		// ====================

		// purge tower
		if (s.hasPurgeTower === undefined) {
			s.hasPurgeTower = false;
			for (let i = 1; i <= 20; ++i) {
				if (c.getLine(-i).line.startsWith('; CP TOOLCHANGE START')) {
					s.hasPurgeTower = true;
					break;
				}
			}
		}

		// z-hop before toolchange
		let zhop = 0;
		let zhopLineOffset = 0;

		if (
			!s.hasPurgeTower &&
			(s.gcodeInfo.flavour & (GCodeFlavour.PrusaSlicer | GCodeFlavour.SuperSlicer | GCodeFlavour.OrcaSlicer)) > 0
		) {
			for (let i = 1; i <= 20; ++i) {
				let line = c.getLine(-i);
				
			}
		}
	}
};

const xxx: Action = (c, s) => {};

//-----------------------

// Reminder: this is a typeguard.
function isActionFunction(x: unknown): x is (c: ProcessLineContext, s: State) => ActionResult | void {
	return true;
}

class RatOSGcodeProcessor {
	constructor(printerHasIdex: boolean, inspectionOnly: boolean) {
		this.#state = new State(printerHasIdex, inspectionOnly);
	}

	#state: State;
	/**
	 * NB: The order of actions is significant.
	 */
	#actions: Action[] = [
		getGcodeInfo,
		getStartPrint, // NB: sequence won't execute past here until start line is found.
		fixOtherLayerTemperature,
		fixOrcaSetAccelaration,
		parseCommonCommands,
		findFirstMoveXY,
		findMinMaxX,
		processToolchange,
	];

	processLine(ctx: ProcessLineContext) {
		this.#state.resetIterationState();
		++this.#state.currentLineNumber;
		executeActionSequence(this.#actions, (action: Action) => {
			if (isActionFunction(action)) {
				let result = action(ctx, this.#state);
				return result === undefined ? ActionResult.Continue : result;
			} else {
				if (this.#state.gcodeInfoOrUndefined === undefined) {
					// We can't do anything with a flavour-filtered action until the flavour is known.
					return ActionResult.Continue;
				} else {
					if ((this.#state.gcodeInfoOrUndefined.flavour & action[0]) > 0) {
						let result = action[1](ctx, this.#state);
						return result === undefined ? ActionResult.Continue : result;
					} else {
						// Flavour is not a match, remove.
						return ActionResult.RemoveAndContinue;
					}
				}
			}
		});
	}

	/**
	 * TODO
	 * @param bookmarks
	 */
	processBookmarks(bookmarks: BookmarkCollection) {
		// TODO: apply boookmarks. If a file is only being inspected, BookmarkingBufferEncoder won't
		// be in the pipeline, and it would be pointless to call this method. This is also expressed
		// via State.kInspectionOnly: most processing code will behave the same regardless, but this
		// flag can be used to skip some expensive mutation that won't end up being used anyhow.
	}

	/**
	 * TODO
	 */
	getSidecarData(): Object {
		// TODO: This can be called at the end of both inspection and mutation pipelines to emit sidecar
		// data. For inspection pipelines, this is the only way to emit the results of the analysis.
		// For mutating pipelines, some data is also extracted for UI use, such as filament information
		// or toolchange timings.
		throw new Error('not implemented');
	}
}
