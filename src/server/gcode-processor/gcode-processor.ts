/* eslint-disable prettier/prettier */
import { ProcessLineContext } from '@/server/gcode-processor/SlidingWindowLineProcessor';
import { ActionResult } from 'next/dist/server/app-render/types';

/*
/; generated by (\w+)\s+(.+) on (.+)/

TG notes from Helge's python impl
---------------------------------

If enable_post_processing is false, only do this:
	get slicer info
	find START_PRINT line
	find start XY coords and do the following, which appears to be an alternative to modifying the file.
				if (not enable_post_processing):
					if (first_x >= 0 and first_y >= 0):
						self.gcode.run_script_from_command("SET_GCODE_VARIABLE MACRO=START_PRINT VARIABLE=first_x VALUE=" + str(first_x))
						self.gcode.run_script_from_command("SET_GCODE_VARIABLE MACRO=START_PRINT VARIABLE=first_y VALUE=" + str(first_y))
						return True

- Processing will continue until first xy is found, and nothing else is done.

If enable_post_processing is true:



Kinds of analysis:



1. Find first occurence

Analysis action conditions:
- some only apply to a particular gcode flavour (can exclude from search list from the start)
- some only apply based on fixed flag like enable_post_processing
- some depend on some other var having been set already (can add to search list only once the dependee is found)

- 

*/

/*

Each action can have the following characteristics:
- activation condition: a condition that transitions the action from inactive to active.
	- variable dependency could be somehow automatically determined or manually expressed
		or execute maybe only execute when *any* variable has changed. Typescript can produce AST from code.
		- Have PoC AST.
		- Fail-safe regex (worst case false positive)
		- Alternative is to use an object for state store, and require that expressions reference props in
		  a consistent way so we can regex for refs.
- execute expression: expression executed for each line after activation.
	returns enum:
		Continue 	- execute on the next line
		Deactivate  - deactivate, but keep monitoring activation condition
		Remove      - deactivate and remove, no reactivation possible.
			

*/

// ; generated by PrusaSlicer 2.8.0+win64 on 2024-09-06 at 08:32:07 UTC

enum GCodeFlavour {
	Unknown = 0,
	PrusaSlicer = 1 << 0,
	OrcaSlicer = 1 << 1,
	SuperSlicer = 1 << 2,
	RatOS = 1 << 3,
}

class GCodeInfo {
	static parseHeader(header: string) : GCodeInfo {
		throw new Error("to do");
	}

	constructor(
		public readonly flavour: GCodeFlavour,
		public readonly version: string,
		public readonly timestamp: string ) {}	
};

const kContinue = 0;
const kActivate = 1;
const kDeactivate = 2;
const kRemove = 3;

enum ActivateResult {
	Continue,
	Activate,
	Remove,
};

enum ExecuteResult {
	Continue,
	Deactivate,
	Remove
};

/*
class Action<TState> {
	constructor(
		activate: ((ctx: ProcessLineContext, state: TState) => ActivateResult) | true,
		execute: (ctx: ProcessLineContext, state: TState) => ExecuteResult
	) {
		if ( activate === true ) {
			this.#active = true;
		} else {
			this.#active = false;
			this.#activate = activate;
		}

		this.#execute = execute;			
	}

	#activate?: (ctx: ProcessLineContext, state: TState) => ActivateResult;
	#execute: (ctx: ProcessLineContext, state: TState) => ExecuteResult;

	#active: boolean;

	get active() : boolean
	{
		return this.#active;
	}

	readonly activateRefs: Set<string> = new Set<string>();
	readonly executeRefs: Set<string> = new Set<string>();
}
*/
/*
class actors {
	static getGcodeInfo: Active = (c,s) => {
		if (c.line?.startsWith('; generated by') ) {
			s.gcodeInfo = new GCodeInfo('PrusaSlicer', '1.0', '12345');
			return ExecuteResult.Remove;
		} else if ( s.currentLineNumber == 2 ) {
			throw new Error('Slicer identification not found.');
		}
	};
};
*/

class MyState {
	constructor(
		public readonly _printerHasIdex: boolean,
		public readonly _inpsectionOnly: boolean,
		public currentLineNumber: number = 0,
		public gcodeInfo?: GCodeInfo,
		public startPrintLine?: symbol,
		public extruderTempsLine?: symbol,
		public extruderTemps?: number[],
		public startPos?: [number, number]
	){}
};

type Active = (c: ProcessLineContext, s: MyState) => ExecuteResult | void;

type Activatable = [
	(c: ProcessLineContext, s: MyState) => ActivateResult | boolean | void,
	(c: ProcessLineContext, s: MyState) => ExecuteResult | void,
]

function ActivateOrRemove( activate: boolean, remove: boolean): ActivateResult {
	if ( remove ) {
		return ActivateResult.Remove;
	}
	if ( activate ) {
		return ActivateResult.Activate;
	}
	return ActivateResult.Continue;
}


// TODO: Compatibility check
// TODO: Already processed check
const getGcodeInfo: Active = (c,s) => {
	if (c.line?.startsWith('; generated by') ) {
		s.gcodeInfo = GCodeInfo.parseHeader(c.line);
		return ExecuteResult.Remove;
	} else if ( s.currentLineNumber == 2 ) {
		throw new Error('Slicer identification not found.');
	}
};

const getStartPrint: Active = (c,s) => {
	if (/^(START_PRINT|RMMU_START_PRINT)[ $]/.test(c.line)) {
		// Fix colour variable format			
		c.line = c.line.replace('#','').padEnd(512);
		s.startPrintLine = c.bookmarkKey = Symbol('START_PRINT');
		return ExecuteResult.Remove;
	}
};

const fixOtherLayerTemperature: Activatable = [
	(c,s) => ActivateOrRemove( !!s.gcodeInfo && !!s.startPrintLine, 
	(c,s) => {
		if (c.line?.startsWith('; generated by') ) {
			s.gcodeInfo = new GCodeInfo('PrusaSlicer', '1.0', '12345');
			return ExecuteResult.Remove;
		} else if ( s.currentLineNumber == 2 ) {
			throw new Error('Slicer identification not found.');
		}
	}];

class RatOSGcodeProcessor
{		
	actions = [
		getGcodeInfo,
		getStartPrint,
		xx,
		[]
	];

	ProcessLine(ctx: ProcessLineContext ) {
		
		// TODO!!!!
		// Write what the config description should look like.

		
		++lineNumber;

		new Action<MyState>(true, getGcodeInfo);

		// Do we need this?
		new ActionGroup<MyState>( (c,s) => { return s.gcodeInfo ? ActivateResult.Activate : ActivateResult.Continue },
			[
				// All actions that depend on state.gcodeInfo
			]);
	}
}