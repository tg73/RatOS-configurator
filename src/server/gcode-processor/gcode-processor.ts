import { exec } from 'child_process';
import { ActionResult, executeActionSequence } from '@/server/gcode-processor/ActionSequence';
import { BookmarkCollection } from '@/server/gcode-processor/BookmarkingBufferEncoder';
import { Bookmark, BookmarkKey } from '@/server/gcode-processor/Bookmark';
import { ProcessLineContext } from '@/server/gcode-processor/SlidingWindowLineProcessor';
import semver, { SemVer } from 'semver';
import { promisify } from 'node:util';

// TODO: Review pad lengths.

/*
GCODE FORMAT NOTES
------------------
gcode in the wild includes the comment suffix with no leading whitespace. Example from orcaslicer:

SET_PRESSURE_ADVANCE ADVANCE=0.03; Override pressure advance value

*/

/*
/; generated by (\w+)\s+(.+) on (.+)/

TG notes from Helge's python impl
---------------------------------

If enable_post_processing is false, only do this:
	get slicer info
	find START_PRINT line
	find start XY coords and do the following, which appears to be an alternative to modifying the file.
				if (not enable_post_processing):
					if (first_x >= 0 and first_y >= 0):
						self.gcode.run_script_from_command("SET_GCODE_VARIABLE MACRO=START_PRINT VARIABLE=first_x VALUE=" + str(first_x))
						self.gcode.run_script_from_command("SET_GCODE_VARIABLE MACRO=START_PRINT VARIABLE=first_y VALUE=" + str(first_y))
						return True

- Processing will continue until first xy is found, and nothing else is done.

If enable_post_processing is true:



Kinds of analysis:



1. Find first occurence

Analysis action conditions:
- some only apply to a particular gcode flavour (can exclude from search list from the start)
- some only apply based on fixed flag like enable_post_processing
- some depend on some other var having been set already (can add to search list only once the dependee is found)

- 

*/

/*

Each action can have the following characteristics:
- activation condition: a condition that transitions the action from inactive to active.
	- variable dependency could be somehow automatically determined or manually expressed
		or execute maybe only execute when *any* variable has changed. Typescript can produce AST from code.
		- Have PoC AST.
		- Fail-safe regex (worst case false positive)
		- Alternative is to use an object for state store, and require that expressions reference props in
		  a consistent way so we can regex for refs.
- execute expression: expression executed for each line after activation.
	returns enum:
		Continue 	- execute on the next line
		Deactivate  - deactivate, but keep monitoring activation condition
		Remove      - deactivate and remove, no reactivation possible.
			

*/

const CHANGED_BY_RATOS = ' ; Changed by RatOS post processor: ';
const REMOVED_BY_RATOS = '; Removed by RatOS post processor: ';

// ; generated by PrusaSlicer 2.8.0+win64 on 2024-09-06 at 08:32:07 UTC

enum GCodeFlavour {
	Unknown = 0,
	PrusaSlicer = 1 << 0,
	OrcaSlicer = 1 << 1,
	SuperSlicer = 1 << 2,
	RatOS = 1 << 3,

	Any = 0xffff,
}

async function getCurrentCodeVersion(): Promise<SemVer> {
	throw new Error('TODO: get correct version');
	const v = (await promisify(exec)('git describe --tags --always', {
		cwd: process.env.RATOS_CONFIGURATION_PATH,
	}).then(({ stdout }) => stdout.trim())) as GitVersion;
	return new SemVer(v);
}

class GCodeInfo {
	/**
	 * Parses header (top of file) comments.
	 * @param header One or more newline-separated lines from the start of a gcode file. Normally, at least the first 2 lines should be provided.
	 */
	static tryParseHeader(header: string): GCodeInfo | null {
		let match =
			/^; generated (by|with) (?<GENERATOR>[^\s]+) (?<VERSION>[^\s]+) (in RatOS dialect (?<RATOS_DIALECT_VERSION>[^\s]+) )?on (?<DATE>[^\s]+) at (?<TIME>.*)$/im.exec(
				header,
			);

		if (match) {
			let flavour = GCodeFlavour.Unknown;
			let ratosDialectVersion: string | undefined = undefined;

			switch (match.groups?.GENERATOR?.toLowerCase()) {
				case 'prusaslicer':
					flavour = GCodeFlavour.PrusaSlicer;
					break;
				case 'orcaslicer':
					flavour = GCodeFlavour.OrcaSlicer;
					break;
				case 'superslicer':
					flavour = GCodeFlavour.SuperSlicer;
					break;
				default:
					if (match.groups?.RATOS_DIALECT_VERSION) {
						flavour = GCodeFlavour.RatOS;
						ratosDialectVersion = match.groups?.RATOS_DIALECT_VERSION;
					}
					break;
			}

			let processedByRatosMatch = /^; processed by RatOS (?<VERSION>[^\s]+) on (?<DATE>[^\s]+) at (?<TIME>.*)$/im.exec(
				header,
			);

			return new GCodeInfo(
				match[0],
				match.groups?.GENERATOR!,
				match.groups?.VERSION!,
				flavour,
				new Date(match.groups?.DATE + ' ' + match.groups?.TIME),
				ratosDialectVersion,
				processedByRatosMatch?.groups?.VERSION,
				processedByRatosMatch
					? new Date(processedByRatosMatch.groups?.DATE + ' ' + processedByRatosMatch.groups?.TIME)
					: undefined,
			);
		}

		return null;
	}

	constructor(
		public readonly originalText: string,
		public readonly generator: string,
		public readonly generatorVersion: string,
		public readonly flavour: GCodeFlavour,
		public readonly generatorTimestamp: Date,
		public readonly ratosDialectVersion?: string,
		public readonly processedByRatOSVersion?: string,
		public readonly processedByRatOSTimestamp?: Date,
	) {}
}

/*
class Action<TState> {
	constructor(
		activate: ((ctx: ProcessLineContext, state: TState) => ActivateResult) | true,
		execute: (ctx: ProcessLineContext, state: TState) => ExecuteResult
	) {
		if ( activate === true ) {
			this.#active = true;
		} else {
			this.#active = false;
			this.#activate = activate;
		}

		this.#execute = execute;			
	}

	#activate?: (ctx: ProcessLineContext, state: TState) => ActivateResult;
	#execute: (ctx: ProcessLineContext, state: TState) => ExecuteResult;

	#active: boolean;

	get active() : boolean
	{
		return this.#active;
	}

	readonly activateRefs: Set<string> = new Set<string>();
	readonly executeRefs: Set<string> = new Set<string>();
}
*/
/*
class actors {
	static getGcodeInfo: Active = (c,s) => {
		if (c.line?.startsWith('; generated by') ) {
			s.gcodeInfo = new GCodeInfo('PrusaSlicer', '1.0', '12345');
			return ExecuteResult.Remove;
		} else if ( s.currentLineNumber == 2 ) {
			throw new Error('Slicer identification not found.');
		}
	};
};
*/

// Logically atomic.
class BookmarkedLine {
	constructor(
		public readonly line: string,
		public readonly bookmark: BookmarkKey,
	) {}
}

/**
 * Property naming convention:
 *  'k' prefix: external configuration. Always readonly.
 *  '_' prefix: iteration-scope state that gets reset for each line
 *   no prefix: file-scope state that is maintained for the whole file
 */
class State {
	constructor(
		public readonly kPrinterHasIdex: boolean,
		public readonly kInpsectionOnly: boolean,
	) {}

	// Stream-scope fields:

	public currentLineNumber: number = -1;
	public firstLine?: BookmarkedLine;
	public startPrintLine?: BookmarkedLine;
	public onLayerChange2Bookmark?: symbol;
	public extruderTemps?: string[];
	public toolChangeCount = 0;
	public firstMoveX?: string;
	public firstMoveY?: string;
	public minX = Number.MAX_VALUE;
	public maxX = Number.MIN_VALUE;
	public hasPurgeTower?: boolean;

	/** Used tools, in order of first use. */
	public usedTools: number[] = [];

	// Iteration-scope fields (reset at the start of each processLine iteration):
	public _cmd?: RegExpExecArray | null;

	/**
	 * Resets iteration-scope state.
	 */
	resetIterationState() {
		this._cmd = undefined;
	}

	#gcodeInfo?: GCodeInfo;

	/**
	 * `gcodeInfo` is always set near the start of processing and is accessed frequently
	 * so provide a non-optional accessor for convenience.
	 */
	get gcodeInfo(): GCodeInfo {
		if (!this.#gcodeInfo) {
			throw new Error('gcodeInfo has not been set yet.');
		}
		return this.#gcodeInfo;
	}

	set gcodeInfo(value: GCodeInfo) {
		this.#gcodeInfo = value;
	}

	get gcodeInfoOrUndefined(): GCodeInfo | undefined {
		return this.#gcodeInfo;
	}
}

/**
 * For the function return value `ActionResult | void`, `void` is equivalent to `ActionResult.Continue`.
 */
type Action =
	| ((c: ProcessLineContext, s: State) => ActionResult | void)
	| [relevantGcodeFlavours: GCodeFlavour, (c: ProcessLineContext, s: State) => ActionResult | void];

// TODO: Let's handle header parsing as an explicit action, and only construct the state object
// once it's known. Also we can immediately remove any actions which express flavour relevance.
// TODO: Compatibility check
// TODO: Already processed check
const getGcodeInfo: Action = (c, s) => {
	let parsed = GCodeInfo.tryParseHeader(
		c.line + '\n' + c.getLineOrUndefined(1)?.line + '\n' + c.getLineOrUndefined(2)?.line,
	);

	if (!parsed) {
		throw new Error('Valid supported slicer identification was not found.');
	} else {
		s.gcodeInfo = parsed;
		switch (parsed.flavour) {
			case GCodeFlavour.Unknown:
				throw new Error(
					`Slicer '${parsed.generator}' is not supported, and RatOS dialect conformance was not declared.`,
				);
			case GCodeFlavour.PrusaSlicer:
				if (semver.neq('2.8.0', parsed.generatorVersion)) {
					throw new Error(
						`Only version 2.8.0 of PrusaSlicer is supported. Version ${parsed.generatorVersion} is not supported`,
					);
				}
				break;
			case GCodeFlavour.OrcaSlicer:
				if (semver.neq('2.1.1', parsed.generatorVersion)) {
					throw new Error(
						`Only version 2.1.1 of OrcasSlicer is supported. Version ${parsed.generatorVersion} is not supported`,
					);
				}
				break;
			case GCodeFlavour.SuperSlicer:
				if (semver.neq('2.5.59.13', parsed.generatorVersion)) {
					throw new Error(
						`Only version 2.5.59.13 of SuperSlicer is supported. Version ${parsed.generatorVersion} is not supported`,
					);
				}
				break;
			case GCodeFlavour.RatOS:
				if (semver.neq('0.1', parsed.generatorVersion)) {
					throw new Error(
						`Only version 0.1 of the RatOS G-code dialect is supported. Version ${parsed.generatorVersion} is not supported`,
					);
				}
				break;
			default:
				throw new Error('Internal error: not expected 0x1'); // should never happen
		}
	}
	c.line = c.line.padEnd(c.line.length + 100);
	c.bookmarkKey = Symbol('first line');
	s.firstLine = new BookmarkedLine(c.line, c.bookmarkKey);
	return ActionResult.RemoveAndStop;
};

const getStartPrint: Action = (c, s) => {
	let match =
		/^(START_PRINT|RMMU_START_PRINT)(?=[ $])((?=.*(\sINITIAL_TOOL=(?<INITIAL_TOOL>(\d+))))|)((?=.*(\sEXTRUDER_OTHER_LAYER_TEMP=(?<EXTRUDER_OTHER_LAYER_TEMP>(\d+(,\d+)*))))|)/i.exec(
			c.line,
		);
	if (match) {
		// Fix colour variable format and pad for later modification
		c.line = c.line.replace('#', '').padEnd(c.line.length + 100);
		c.bookmarkKey = Symbol('START_PRINT');
		s.startPrintLine = new BookmarkedLine(c.line, c.bookmarkKey);

		let initialTool = match.groups?.INITIAL_TOOL;
		if (initialTool) {
			s.usedTools.push(Number(initialTool));
		}

		let extruderOtherLayerTemp = match?.groups?.EXTRUDER_OTHER_LAYER_TEMP;
		if (extruderOtherLayerTemp) {
			s.extruderTemps = extruderOtherLayerTemp.split(',');
		}

		return ActionResult.RemoveAndStop;
	}
	// Stop at this point until we find START_LINE. If any actions need to inspect pre-START_LINE,
	// they must be ordered before this action. All actions ordered after this action can assume that
	// the start print line has been found.
	return ActionResult.Stop;
};

const fixOtherLayerTemperature: Action = [
	GCodeFlavour.OrcaSlicer | GCodeFlavour.SuperSlicer,
	(c, s) => {
		if (!s.onLayerChange2Bookmark) {
			if (/^_ON_LAYER_CHANGE LAYER=2[$/s;]/.test(c.line)) {
				c.line = c.line.padEnd(c.line.length + 100);
				s.onLayerChange2Bookmark = c.bookmarkKey = Symbol('on_layer_change 2');
				return ActionResult.RemoveAndStop;
			}
		}
	},
];

const fixOrcaSetAccelaration: Action = [
	GCodeFlavour.OrcaSlicer,
	(c, s) => {
		// SET_VELOCITY_LIMIT ACCEL=2500 ACCEL_TO_DECEL=1250
		const match = /^SET_VELOCITY_LIMIT.*\sACCEL=(\d+)/i.exec(c.line);
		if (match) {
			c.line = `M204 S${match[1]}${CHANGED_BY_RATOS}${c.line}`;
			return ActionResult.Stop;
		}
	},
];

/**
 * Matches `G0|G1|Tn` followed by args like `X1.2` for X, Y, Z, E and F in any order, each being optional.
 * Groups:
 * 'G' - will be 'G0' or 'G1'
 * 'T' - will be 'n', like '0' or '1', accepts any number of digits.
 * 'X' - will be the (decimal) number after 'X', like '12.3' in 'X12.3'.
 * ditto for Y, Z, E and F.
 *
 * Not-match is very cheap.
 */
const rxParseCommonCommands =
	/^(?:T(?<T>\d+))|(?:(?<G>G0|G1)(?=\s)(?=.*(\sX(?<X>[\d.]+))|)(?=.*(\sY(?<Y>[\d.]+))|)(?=.*(\sZ(?<Z>[\d.]+))|)(?=.*(\sE(?<E>[\d.]+))|)(?=.*(\sF(?<F>[\d.]+))|))/i;

const parseCommonCommands: Action = (c, s) => {
	s._cmd = rxParseCommonCommands.exec(c.line);
};

const findFirstMoveXY: Action = (c, s) => {
	if (s._cmd?.groups?.G) {
		s.firstMoveX ??= s._cmd?.groups?.X;
		s.firstMoveY ??= s._cmd?.groups?.Y;

		if (!!s.firstMoveX && !!s.firstMoveY) {
			// We don't need to do this check any more. G0/G1 are extremely frequent, so avoid any excess work.
			return ActionResult.RemoveAndContinue;
		}

		// NOTE: original ratos.py has a short-circuit when !enable_post_processing and both firstMoveX and firstMoveY have been found,
		// which calls run_script_from_command  then returns. (see around line 320). Something like this would be the equivalent
		// short circuit here: if (s.kInpsectionOnly) { throw new SomeObjectToSayAnalysisIsDone() }
	}
};

const findMinMaxX: Action = (c, s) => {
	if (s._cmd?.groups?.G) {
		let x = s._cmd?.groups?.X;
		if (x) {
			let n = Number(x);
			if (n < s.minX) {
				s.minX = n;
			} else if (n > s.maxX) {
				s.maxX = n;
			}
		}
	}
};

const processToolchange: Action = (c, s) => {
	let tool = s._cmd?.groups?.T;
	if (tool) {
		if (s.toolChangeCount++ == 0) {
			c.line = REMOVED_BY_RATOS + c.line; // Remove first toolchange
			return;
		}

		// TOOLSHIFT PROCESSING
		// ====================

		// purge tower
		if (s.hasPurgeTower === undefined) {
			s.hasPurgeTower = false;
			for (let i = 1; i <= 20; ++i) {
				if (c.getLine(-i).line.startsWith('; CP TOOLCHANGE START')) {
					s.hasPurgeTower = true;
					break;
				}
			}
		}

		// NOT PORTING z-hop before toolchange (line ~356)
		//  1) it looks like PS and OS no longer zhop around a tool change.
		//  2) SS does still zhop, but will not emit '; custom gcode: end_filament_gcode' by default
		//     and the instructions don't say to set this, so current output from SS will not be
		//     detected anyhow.

		// NOT PORTING `# toolchange line` section (line ~379)
		// - This looks for `Tn` from the current line up to 19 lines ahead, but will always match
		//   on the current line because all this code is inside a line is inside an
		//  `if current line is 'Tn'` check. So `toolchange_line` will always be equal to the current line.

		// toolchange retraction
		let retractionLine: ProcessLineContext | undefined = undefined;

		if (!s.hasPurgeTower) {
			switch (s.gcodeInfo.flavour) {
				case GCodeFlavour.PrusaSlicer:
				case GCodeFlavour.SuperSlicer:
					for (let i = 1; i <= 20; ++i) {
						const offsetLine = c.getLine(i);
						if (offsetLine.line.startsWith('G1 E-')) {
							retractionLine = offsetLine;
							break;
						}
					}
					break;
				case GCodeFlavour.OrcaSlicer:
					for (let i = 1; i <= 20; ++i) {
						const offsetLine = c.getLine(-i);
						if (offsetLine.line.startsWith('G1 E-')) {
							retractionLine = offsetLine;
							break;
						}
					}
					break;
			}
		}

		// move after toolchange
		let moveAfterToolchange: [x: string, y: string, line: ProcessLineContext] | undefined = undefined;
		for (let i = 1; i <= 20; ++i) {
			const offsetLine = c.getLine(i);
			const match = rxParseCommonCommands.exec(offsetLine.line);
			if (match) {
				const x = match.groups?.X;
				const y = match.groups?.Y;
				if (x && y) {
					if (match.groups?.E) {
						throw new Error('Unexpected print move after toolchange.');
					}
					moveAfterToolchange = [x, y, offsetLine];
					break;
				} else if (x || y) {
					throw new Error('Unexpected move after toolchange with missing X or Y.');
				}
			}
		}
	}
};

const xxx: Action = (c, s) => {};

//-----------------------

// Reminder: this is a typeguard.
function isActionFunction(x: unknown): x is (c: ProcessLineContext, s: State) => ActionResult | void {
	return true;
}

class RatOSGcodeProcessor {
	constructor(printerHasIdex: boolean, inspectionOnly: boolean) {
		this.#state = new State(printerHasIdex, inspectionOnly);
	}

	#state: State;
	/**
	 * NB: The order of actions is significant.
	 */
	#actions: Action[] = [
		getGcodeInfo,
		getStartPrint, // NB: sequence won't execute past here until start line is found.
		fixOtherLayerTemperature,
		fixOrcaSetAccelaration,
		parseCommonCommands,
		findFirstMoveXY,
		findMinMaxX,
		processToolchange,
	];

	processLine(ctx: ProcessLineContext) {
		this.#state.resetIterationState();
		++this.#state.currentLineNumber;
		executeActionSequence(this.#actions, (action: Action) => {
			if (isActionFunction(action)) {
				let result = action(ctx, this.#state);
				return result === undefined ? ActionResult.Continue : result;
			} else {
				if (this.#state.gcodeInfoOrUndefined === undefined) {
					// We can't do anything with a flavour-filtered action until the flavour is known.
					return ActionResult.Continue;
				} else {
					if ((this.#state.gcodeInfoOrUndefined.flavour & action[0]) > 0) {
						let result = action[1](ctx, this.#state);
						return result === undefined ? ActionResult.Continue : result;
					} else {
						// Flavour is not a match, remove.
						return ActionResult.RemoveAndContinue;
					}
				}
			}
		});
	}

	/**
	 * TODO
	 * @param bookmarks
	 */
	async processBookmarks(
		bookmarks: BookmarkCollection,
		replaceLine: (bookmark: Bookmark, line: string) => Promise<void>,
	) {
		// TODO: apply boookmarks. If a file is only being inspected, BookmarkingBufferEncoder won't
		// be in the pipeline, and it would be pointless to call this method. This is also expressed
		// via State.kInspectionOnly: most processing code will behave the same regardless, but this
		// flag can be used to skip some expensive mutation that won't end up being used anyhow.
		///^; processed by RatOS (?<VERSION>[^\s]+) on (?<DATE>[^\s]+) at (?<TIME>.*)$/im.exec(
		if (this.#state.firstLine) {
			const currentCodeVersion = await getCurrentCodeVersion();
			const now = new Date();
			await replaceLine(
				bookmarks.getBookmark(this.#state.firstLine.bookmark),
				this.#state.firstLine.line +
					`\n; processed by RatOS ${currentCodeVersion.toString()} on ${now.toDateString()} at ${now.toTimeString()}`,
			);
		}
	}

	/**
	 * TODO
	 */
	getSidecarData(): Object {
		// TODO: This can be called at the end of both inspection and mutation pipelines to emit sidecar
		// data. For inspection pipelines, this is the only way to emit the results of the analysis.
		// For mutating pipelines, some data is also extracted for UI use, such as filament information
		// or toolchange timings.
		throw new Error('not implemented');
	}
}
