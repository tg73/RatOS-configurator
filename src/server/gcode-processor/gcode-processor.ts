import { ActionResult, executeActionSequence } from '@/server/gcode-processor/ActionSequence';
import { BookmarkCollection } from '@/server/gcode-processor/BookmarkingBufferEncoder';
import { BookmarkKey } from '@/server/gcode-processor/Bookmark';
import { ProcessLineContext } from '@/server/gcode-processor/SlidingWindowLineProcessor';

/*
GCODE FORMAT NOTES
------------------
gcode in the wild includes the comment suffix with no leading whitespace. Example from orcaslicer:

SET_PRESSURE_ADVANCE ADVANCE=0.03; Override pressure advance value

*/

/*
/; generated by (\w+)\s+(.+) on (.+)/

TG notes from Helge's python impl
---------------------------------

If enable_post_processing is false, only do this:
	get slicer info
	find START_PRINT line
	find start XY coords and do the following, which appears to be an alternative to modifying the file.
				if (not enable_post_processing):
					if (first_x >= 0 and first_y >= 0):
						self.gcode.run_script_from_command("SET_GCODE_VARIABLE MACRO=START_PRINT VARIABLE=first_x VALUE=" + str(first_x))
						self.gcode.run_script_from_command("SET_GCODE_VARIABLE MACRO=START_PRINT VARIABLE=first_y VALUE=" + str(first_y))
						return True

- Processing will continue until first xy is found, and nothing else is done.

If enable_post_processing is true:



Kinds of analysis:



1. Find first occurence

Analysis action conditions:
- some only apply to a particular gcode flavour (can exclude from search list from the start)
- some only apply based on fixed flag like enable_post_processing
- some depend on some other var having been set already (can add to search list only once the dependee is found)

- 

*/

/*

Each action can have the following characteristics:
- activation condition: a condition that transitions the action from inactive to active.
	- variable dependency could be somehow automatically determined or manually expressed
		or execute maybe only execute when *any* variable has changed. Typescript can produce AST from code.
		- Have PoC AST.
		- Fail-safe regex (worst case false positive)
		- Alternative is to use an object for state store, and require that expressions reference props in
		  a consistent way so we can regex for refs.
- execute expression: expression executed for each line after activation.
	returns enum:
		Continue 	- execute on the next line
		Deactivate  - deactivate, but keep monitoring activation condition
		Remove      - deactivate and remove, no reactivation possible.
			

*/

const CHANGED_BY_RATOS = ' ; Changed by RatOS post processor: ';
const REMOVED_BY_RATOS = ' ; Removed by RatOS post processor: ';

// ; generated by PrusaSlicer 2.8.0+win64 on 2024-09-06 at 08:32:07 UTC

enum GCodeFlavour {
	Unknown = 0,
	PrusaSlicer = 1 << 0,
	OrcaSlicer = 1 << 1,
	SuperSlicer = 1 << 2,
	RatOS = 1 << 3,

	Any = 0xffff,
}

class GCodeInfo {
	static parseHeader(header: string): GCodeInfo | Error {
		throw new Error('to do');
	}

	constructor(
		public readonly flavour: GCodeFlavour,
		public readonly version: string,
		public readonly timestamp: string,
	) {}
}

/*
class Action<TState> {
	constructor(
		activate: ((ctx: ProcessLineContext, state: TState) => ActivateResult) | true,
		execute: (ctx: ProcessLineContext, state: TState) => ExecuteResult
	) {
		if ( activate === true ) {
			this.#active = true;
		} else {
			this.#active = false;
			this.#activate = activate;
		}

		this.#execute = execute;			
	}

	#activate?: (ctx: ProcessLineContext, state: TState) => ActivateResult;
	#execute: (ctx: ProcessLineContext, state: TState) => ExecuteResult;

	#active: boolean;

	get active() : boolean
	{
		return this.#active;
	}

	readonly activateRefs: Set<string> = new Set<string>();
	readonly executeRefs: Set<string> = new Set<string>();
}
*/
/*
class actors {
	static getGcodeInfo: Active = (c,s) => {
		if (c.line?.startsWith('; generated by') ) {
			s.gcodeInfo = new GCodeInfo('PrusaSlicer', '1.0', '12345');
			return ExecuteResult.Remove;
		} else if ( s.currentLineNumber == 2 ) {
			throw new Error('Slicer identification not found.');
		}
	};
};
*/

// Logically atomic.
class BookmarkedLine {
	constructor(
		public readonly line: string,
		public readonly bookmark: BookmarkKey,
	) {}
}

/**
 * Property naming convention:
 *  'k' prefix: external configuration. Always readonly.
 *  '_' prefix: iteration-scope state that gets reset for each line
 *   no prefix: file-scope state that is maintained for the whole file
 */
class State {
	constructor(
		public readonly kPrinterHasIdex: boolean,
		public readonly kInpsectionOnly: boolean,
		public currentLineNumber: number = -1,
		gcodeInfo?: GCodeInfo,
		public startPrintLine?: BookmarkedLine,
		public extruderTempsBookmark?: symbol,
		public extruderTemps?: number[],
		public startPos?: [number, number],
		public _cmd?: RegExpExecArray | null,
	) {
		this.#gcodeInfo = gcodeInfo;
	}

	/**
	 * Resets iteration-scope state.
	 */
	reset() {
		this._cmd = undefined;
	}

	#gcodeInfo?: GCodeInfo;

	/**
	 * `gcodeInfo` is always set near the start of processing and is accessed frequently
	 * so provide a non-optional accessor for convenience.
	 */
	get gcodeInfo(): GCodeInfo {
		if (!this.#gcodeInfo) {
			throw new Error('gcodeInfo has not been set yet.');
		}
		return this.#gcodeInfo;
	}

	set gcodeInfo(value: GCodeInfo) {
		this.#gcodeInfo = value;
	}

	get gcodeInfoOrUndefined(): GCodeInfo | undefined {
		return this.#gcodeInfo;
	}
}

/**
 * For the function return value `ActionResult | void`, `void` is equivalent to `ActionResult.Continue`.
 */
type Action =
	| ((c: ProcessLineContext, s: State) => ActionResult | void)
	| [relevantGcodeFlavours: GCodeFlavour, (c: ProcessLineContext, s: State) => ActionResult | void];

// TODO: Let's handle header parsing as an explicit action, and only construct the state object
// once it's known. Also we can immediately remove any actions which express flavour relevance.
// TODO: Compatibility check
// TODO: Already processed check
const getGcodeInfo: Action = (c, s) => {
	let parsed = GCodeInfo.parseHeader(c.line);

	if (parsed instanceof Error) {
		parsed = GCodeInfo.parseHeader(c.getLineOrUndefined(1)?.line ?? '');
	}

	if (parsed instanceof Error) {
		throw new Error('Valid slicer identification not found');
	} else {
		s.gcodeInfo = parsed;
	}
	return ActionResult.RemoveAndStop;
};

const getStartPrint: Action = (c, s) => {
	if (/^(START_PRINT|RMMU_START_PRINT)[ $]/.test(c.line)) {
		// Fix colour variable format
		c.line = c.line.replace('#', '').padEnd(512);
		c.bookmarkKey = Symbol('START_PRINT');
		s.startPrintLine = new BookmarkedLine(c.line, c.bookmarkKey);
		return ActionResult.RemoveAndStop;
	}
};

const fixOtherLayerTemperature: Action = [
	GCodeFlavour.OrcaSlicer | GCodeFlavour.SuperSlicer,
	(c, s) => {
		// TODO: as soon as gcodeInfo is known, remove this action if the gcode flavour is not relevant.
		// Consider expressing relevant flavours directly as it's a common filter.
		if (!!s.startPrintLine && !s.extruderTempsBookmark) {
			if (/^_ON_LAYER_CHANGE LAYER=2[$/s;]/.test(c.line)) {
				s.extruderTempsBookmark = c.bookmarkKey = Symbol('on_layer_change 2');
				const match = /EXTRUDER_OTHER_LAYER_TEMP=([\d,]+)/.exec(s.startPrintLine.line);
				if (match) {
					s.extruderTemps = match.slice(1).map(Number);
				}
				return ActionResult.RemoveAndStop;
			}
		}
	},
];

const fixOrcaSetAccelaration: Action = [
	GCodeFlavour.OrcaSlicer,
	(c, s) => {
		if (!!s.startPrintLine) {
			// SET_VELOCITY_LIMIT ACCEL=2500 ACCEL_TO_DECEL=1250
			const match = /^SET_VELOCITY_LIMIT.*\sACCEL=(\d+)/i.exec(c.line);
			if (match) {
				c.line = `M204 S${match[1]}${CHANGED_BY_RATOS}${c.line}`;
				return ActionResult.Stop;
			}
		}
	},
];

/**
 * Matches `G0|G1|Tn` followed by args like `X1.2` for X, Y, Z, E and F in any order, each being optional.
 * Groups:
 * 'G' - will be 'G0' or 'G1'
 * 'T' - will be 'n', like '0' or '1', accepts any number of digits.
 * 'X' - will be the (decimal) number after 'X', like '12.3' in 'X12.3'.
 * ditto for Y, Z, E and F.
 *
 * Not-match is very cheap.
 */
const rxParseCommonCommands =
	/^(?:T(?<T>\d+))|(?:(?<G>G0|G1)(?=\s)(?=.*(\sX(?<X>[\d.]+))|)(?=.*(\sY(?<Y>[\d.]+))|)(?=.*(\sZ(?<Z>[\d.]+))|)(?=.*(\sE(?<E>[\d.]+))|)(?=.*(\sF(?<F>[\d.]+))|))/i;

const parseCommonCommands: Action = (c, s) => {
	s._cmd = rxParseCommonCommands.exec(c.line);
};

const xxx: Action = (c, s) => {};

//-----------------------

// Reminder: this is a typeguard.
function isActionFunction(x: unknown): x is (c: ProcessLineContext, s: State) => ActionResult | void {
	return true;
}

class RatOSGcodeProcessor {
	constructor(printerHasIdex: boolean, inspectionOnly: boolean) {
		this.#state = new State(printerHasIdex, inspectionOnly);
	}

	#state: State;
	/**
	 * NB: The order of actions is significant.
	 */
	#actions: Action[] = [
		getGcodeInfo,
		getStartPrint,
		fixOtherLayerTemperature,
		fixOrcaSetAccelaration,
		parseCommonCommands,
	];

	processLine(ctx: ProcessLineContext) {
		++this.#state.currentLineNumber;
		executeActionSequence(this.#actions, (action: Action) => {
			if (isActionFunction(action)) {
				let result = action(ctx, this.#state);
				return result === undefined ? ActionResult.Continue : result;
			} else {
				if (this.#state.gcodeInfoOrUndefined === undefined) {
					// We can't do anything with a flavour-filtered action until the flavour is known.
					return ActionResult.Continue;
				} else {
					if ((this.#state.gcodeInfoOrUndefined.flavour | action[0]) > 0) {
						let result = action[1](ctx, this.#state);
						return result === undefined ? ActionResult.Continue : result;
					} else {
						// Flavour is not a match, remove.
						return ActionResult.RemoveAndContinue;
					}
				}
			}
		});
	}

	/**
	 * TODO
	 * @param bookmarks
	 */
	processBookmarks(bookmarks: BookmarkCollection) {
		// TODO: apply boookmarks. If a file is only being inspected, BookmarkingBufferEncoder won't
		// be in the pipeline, and it would be pointless to call this method. This is also expressed
		// via State.kInspectionOnly: most processing code will behave the same regardless, but this
		// flag can be used to skip some expensive mutation that won't end up being used anyhow.
	}

	/**
	 * TODO
	 */
	getSidecarData(): Object {
		// TODO: This can be called at the end of both inspection and mutation pipelines to emit sidecar
		// data. For inspection pipelines, this is the only way to emit the results of the analysis.
		// For mutating pipelines, some data is also extracted for UI use, such as filament information
		// or toolchange timings.
		throw new Error('not implemented');
	}
}
