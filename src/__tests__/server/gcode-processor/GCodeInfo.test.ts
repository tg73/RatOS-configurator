/**
 * @file GCodeInfo.test.ts
 * @description
 *
 * @author Tom Glastonbury <t@tg73.net>
 * @license MIT
 * @copyright 2024
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
 * PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

import { describe, test, expect } from 'vitest';
import { GCodeFlavour, GCodeInfo } from '@/server/gcode-processor/GCodeInfo';
import semver, { SemVer } from 'semver';
import path from 'path';

describe('tryParseHeader', async () => {
	test('PrusaSlicer 2.8.0', () => {
		const header = '; generated by PrusaSlicer 2.8.0+win64 on 2024-09-06 at 08:32:07 UTC\n\n';
		const parsed = GCodeInfo.tryParseHeader(header);

		expect(parsed).not.toBeNull();
		expect(parsed!.flavour).toEqual(GCodeFlavour.PrusaSlicer);
		expect(parsed!.generator).toEqual('PrusaSlicer');
		expect(parsed!.generatorTimestamp).toEqual(new Date('2024-09-06 08:32:07 UTC'));
		expect(parsed!.generatorVersion).toEqual(semver.coerce('2.8.0+win64'));
		expect(parsed!.ratosDialectVersion).toBeUndefined();
		expect(parsed!.processedByRatOSVersion).toBeUndefined();
		expect(parsed!.processedByRatOSTimestamp).toBeUndefined();
	});

	test('SuperSlicer 2.5.59.13', async () => {
		const header = '; generated by SuperSlicer 2.5.59.13 on 2024-09-14 at 09:35:09 UTC\n\n';
		const parsed = GCodeInfo.tryParseHeader(header);

		expect(parsed).not.toBeNull();
		expect(parsed!.flavour).toEqual(GCodeFlavour.SuperSlicer);
		expect(parsed!.generator).toEqual('SuperSlicer');
		expect(parsed!.generatorTimestamp).toEqual(new Date('2024-09-14 09:35:09 UTC'));
		expect(parsed!.generatorVersion).toEqual(semver.coerce('2.5.59.13'));
		expect(parsed!.ratosDialectVersion).toBeUndefined();
		expect(parsed!.processedByRatOSVersion).toBeUndefined();
		expect(parsed!.processedByRatOSTimestamp).toBeUndefined();
	});

	test('OrcaSlicer 2.1.1', async () => {
		const header =
			'; HEADER_BLOCK_START\n' +
			'; generated by OrcaSlicer 2.1.1 on 2024-09-12 at 14:57:24\n' +
			'; total layer number: 240';

		const parsed = GCodeInfo.tryParseHeader(header);

		expect(parsed).not.toBeNull();
		expect(parsed!.flavour).toEqual(GCodeFlavour.OrcaSlicer);
		expect(parsed!.generator).toEqual('OrcaSlicer');
		expect(parsed!.generatorTimestamp).toEqual(new Date('2024-09-12 14:57:24'));
		expect(parsed!.generatorVersion).toEqual(semver.coerce('2.1.1'));
		expect(parsed!.ratosDialectVersion).toBeUndefined();
		expect(parsed!.processedByRatOSVersion).toBeUndefined();
		expect(parsed!.processedByRatOSTimestamp).toBeUndefined();
	});

	test('CustomGenerator in RatOS dialect', async () => {
		const header = '; generated by CustomGenerator 0.1-alpha in RatOS dialect 0.1 on 2025-01-01 at 08:32:07 UTC\n\n';
		const parsed = GCodeInfo.tryParseHeader(header);

		expect(parsed).not.toBeNull();
		expect(parsed!.flavour).toEqual(GCodeFlavour.RatOS);
		expect(parsed!.generator).toEqual('CustomGenerator');
		expect(parsed!.generatorTimestamp).toEqual(new Date('2025-01-01 08:32:07 UTC'));
		expect(parsed!.generatorVersion).toEqual(semver.coerce('0.1-alpha'));
		expect(parsed!.ratosDialectVersion).toEqual(semver.coerce('0.1'));
		expect(parsed!.processedByRatOSVersion).toBeUndefined();
		expect(parsed!.processedByRatOSTimestamp).toBeUndefined();
	});

	test('CustomGenerator without RatOS dialect', async () => {
		const header = '; generated by CustomGenerator 0.1-alpha on 2025-01-01 at 08:32:07 UTC\n\n';
		const parsed = GCodeInfo.tryParseHeader(header);

		expect(parsed).not.toBeNull();
		expect(parsed!.flavour).toEqual(GCodeFlavour.Unknown);
		expect(parsed!.generator).toEqual('CustomGenerator');
		expect(parsed!.generatorTimestamp).toEqual(new Date('2025-01-01 08:32:07 UTC'));
		expect(parsed!.generatorVersion).toEqual(semver.coerce('0.1-alpha'));
		expect(parsed!.ratosDialectVersion).toBeUndefined();
		expect(parsed!.processedByRatOSVersion).toBeUndefined();
		expect(parsed!.processedByRatOSTimestamp).toBeUndefined();
	});

	test('already processed', async () => {
		const header =
			'; generated by PrusaSlicer 2.8.0+win64 on 2024-09-06 at 08:32:07 UTC\n' +
			'; processed by RatOS 2.0.2-518-g4ffef464 on 2025-01-01 at 08:30:00Z\n';
		const parsed = GCodeInfo.tryParseHeader(header);

		expect(parsed).not.toBeNull();
		expect(parsed!.flavour).toEqual(GCodeFlavour.PrusaSlicer);
		expect(parsed!.generator).toEqual('PrusaSlicer');
		expect(parsed!.generatorTimestamp).toEqual(new Date('2024-09-06 08:32:07 UTC'));
		expect(parsed!.generatorVersion).toEqual(semver.coerce('2.8.0+win64'));
		expect(parsed!.ratosDialectVersion).toBeUndefined();
		expect(parsed!.processedByRatOSVersion).toEqual(semver.coerce('2.0.2-518-g4ffef464'));
		expect(parsed!.processedByRatOSTimestamp).toEqual(new Date('2025-01-01 08:30:00Z'));
	});

	test('no match', async () => {
		let parsed = GCodeInfo.tryParseHeader('blah blah blah');
		expect(parsed).toBeNull();
	});

	test('getProcessedByRatosHeader', async () => {
		const header = await GCodeInfo.getProcessedByRatosHeader();
		expect(header).toMatch(/^; processed by RatOS (?<VERSION>[^\s]+) on (?<DATE>[^\s]+) at (?<TIME>.*)$/im);
	});
});

describe('fromFile', async () => {
	test('unprocessed', async () => {
		const parsed = await GCodeInfo.fromFile(path.join(__dirname, 'fixtures', 'slicer_output', 'benchy2c_ss.gcode'));
		expect(parsed).not.toBeNull();
		expect(parsed!.flavour).toEqual(GCodeFlavour.SuperSlicer);
		expect(parsed!.generator).toEqual('SuperSlicer');
		expect(parsed!.generatorTimestamp).toEqual(new Date('2024-09-14 20:39:12 UTC'));
		expect(parsed!.generatorVersion).toEqual(semver.coerce('2.5.59.13'));
		expect(parsed!.ratosDialectVersion).toBeUndefined();
		expect(parsed!.processedByRatOSVersion).toBeUndefined();
		expect(parsed!.processedByRatOSTimestamp).toBeUndefined();
	});

	test('legacy processed', async () => {
		const parsed = await GCodeInfo.fromFile(
			path.join(__dirname, 'fixtures', 'transformed_legacy', 'benchy2c_ss.gcode'),
		);
		expect(parsed).not.toBeNull();
		expect(parsed!.flavour).toEqual(GCodeFlavour.SuperSlicer);
		expect(parsed!.generator).toEqual('SuperSlicer');
		expect(parsed!.generatorTimestamp).toEqual(new Date('2024-09-14 20:39:12 UTC'));
		expect(parsed!.generatorVersion).toEqual(semver.coerce('2.5.59.13'));
		expect(parsed!.ratosDialectVersion).toBeUndefined();
		expect(parsed!.processedByRatOSVersion).toEqual(new SemVer('1.0.0-legacy'));
		expect(parsed!.processedByRatOSTimestamp).toBeUndefined();
	});
});
