"use strict";(()=>{var e={};e.id=829,e.ids=[829,2888],e.modules={18910:e=>{e.exports=require("@tanstack/react-query")},85337:e=>{e.exports=require("@trpc/client")},4129:e=>{e.exports=require("@trpc/next")},56368:e=>{e.exports=require("@trpc/server")},41169:e=>{e.exports=require("class-variance-authority")},68103:e=>{e.exports=require("clsx")},56988:e=>{e.exports=require("deep-equal")},54230:e=>{e.exports=require("glob")},9227:e=>{e.exports=require("jszip")},20145:e=>{e.exports=require("next/dist/compiled/next-server/pages-api.runtime.prod.js")},24580:e=>{e.exports=require("node-cache")},71569:e=>{e.exports=require("object-hash")},58545:e=>{e.exports=require("pino")},16689:e=>{e.exports=require("react")},7636:e=>{e.exports=require("react-use-websocket")},20997:e=>{e.exports=require("react/jsx-runtime")},29755:e=>{e.exports=require("recoil")},44101:e=>{e.exports=require("recoil-sync")},5873:e=>{e.exports=require("tailwind-merge")},53489:e=>{e.exports=require("ts-deepmerge")},38316:e=>{e.exports=require("zod")},15140:e=>{e.exports=require("zod-refine")},32081:e=>{e.exports=require("child_process")},57147:e=>{e.exports=require("fs")},73292:e=>{e.exports=require("fs/promises")},22037:e=>{e.exports=require("os")},71017:e=>{e.exports=require("path")},14521:e=>{e.exports=require("readline")},73837:e=>{e.exports=require("util")},94646:(e,t,r)=>{r.r(t),r.d(t,{config:()=>ed,default:()=>ec,routeModule:()=>eu});var n={};r.r(n),r.d(n,{config:()=>eo,default:()=>el});var i=r(93273),a=r(80424),s=r(77354),o=r(97926),l=r(57147),c=r(73837),d=r(32081);let hasSsid=e=>e.ssid,hasKeys=e=>0!==Object.keys(e).length,bySignal=(e,t)=>t.signal-e.signal,parseCell=e=>{var t,r={};return(t=e.match(/BSS ([0-9A-Fa-f:-]{17})\(on/))&&(r.address=t[1].toLowerCase()),(t=e.match(/freq: ([0-9]+)/))&&(r.frequency=parseInt(t[1],10)),(t=e.match(/signal: (-?[0-9.]+) dBm/))&&(r.signal=parseFloat(t[1])),(t=e.match(/last seen: ([0-9]+) ms ago/))&&(r.lastSeenMs=parseInt(t[1],10)),(t=e.match(/SSID: \\x00/))?delete r.ssid:(t=e.match(/SSID: ([^\n]*)/))&&(r.ssid=t[1]),(t=e.match(/Country: ([^\t]*)/))&&(r.country=t[1]),(t=e.match(/DS Parameter set: channel ([0-9]+)/))?r.channel=parseInt(t[1],10):(t=e.match(/\* primary channel: ([0-9]+)/))&&(r.channel=parseInt(t[1],10)),(t=e.match(/RSN:[\s*]+Version: 1/))?r.security="wpa2":(t=e.match(/WPA:[\s*]+Version: 1/))?r.security="wpa":(t=e.match(/capability: ESS Privacy/))?r.security="wep":(t=e.match(/capability: ESS/))&&(r.security="open"),r},parseScan=e=>function({stdout:t,stderr:r}){return e?t.split(/(^|\n)(?=BSS )/).map(parseCell).filter(hasKeys).sort(bySignal):t.split(/(^|\n)(?=BSS )/).map(parseCell).filter(hasSsid).sort(bySignal)},getWirelessInterface=async()=>{let e=await (0,c.promisify)(d.exec)("iw dev | awk '$1==\"Interface\"{print $2}' | head -n1");return e.stdout.trim()},scan=async(e,t)=>{let r=t.apForce?" ap-force":"",n=await (0,c.promisify)(d.exec)("sudo iw dev "+e+" scan"+r);return parseScan(t.showHidden??!1)(n)};var u=r(31452),m=r(38316);let p=m.z.object({hostname:m.z.string().min(2).regex(/^([a-zA-Z0-9]|-)+$/,"Hostname can only include a-Z, 0-9 and dashes.")}),g=m.z.object({ssid:m.z.string().min(1).max(32),passphrase:m.z.string().min(8).max(63),frequencies:m.z.string(),country:m.z.string().optional(),hidden:m.z.boolean().optional()});var y=r(36029),f=r(23637),w=r(56368),h=r(71017),x=r.n(h);let b=(0,f.Nd)({hostname:f.$y.input(p).mutation(async({input:e})=>{let t=(0,u.xg)();try{await (0,c.promisify)(d.exec)(`sudo ${x().join(t,"change-hostname.sh")} ${e.hostname}`)}catch(e){throw e instanceof Error&&(0,o.j)().error(e.message),new w.TRPCError({message:"An error occured while attempting to change the hostname",code:"INTERNAL_SERVER_ERROR",cause:e})}return{result:"success"}}),join:f.$y.input(g).mutation(async({input:e})=>{try{await (0,y.$)("add-wifi-network.sh",e.ssid,e.passphrase,e.country??"GB",e.frequencies,e.hidden?"hidden":"shown")}catch(e){throw e instanceof Error&&(0,o.j)().error(e.message),new w.TRPCError({message:"Invalid wifi credentials",code:"PRECONDITION_FAILED",cause:e})}return{result:"success"}}),scan:f.$y.input(m.z.object({showHidden:m.z.boolean().default(!1)})).query(async({input:e})=>{let t=await getWirelessInterface();if(null==t||""===t.trim())throw new w.TRPCError({message:"No wifi interface available on device, if you're connected via ethernet you can skip this step.",code:"INTERNAL_SERVER_ERROR"});try{return await scan(t,{apForce:!0,showHidden:e.showHidden})}catch(e){throw e instanceof Error&&(0,o.j)().error(e.message),new w.TRPCError({message:"Failed to scan wifi networks",code:"INTERNAL_SERVER_ERROR",cause:e})}})});var j=r(82557),E=r(74169),S=r(73292);m.z.object({fileName:m.z.string(),path:m.z.string(),extensionName:m.z.string()}),m.z.object({errorIfExists:m.z.boolean().optional(),errorIfNotExists:m.z.boolean().optional()});let symlinkExtensions=async e=>{let t=e.extensions.slice(),r=[];if(0===t.length)return{report:"No extensions registered, nothing to do.",cleanedUpExtensions:r,symlinkResults:[]};let n=x().resolve(x().join(e.gitRepoPath,".git","info","exclude")),i=await Promise.all(t.map(async t=>{let i=x().join("function"==typeof e.relativePath?e.relativePath(t):e.relativePath,t.fileName),a=x().resolve(x().join(e.gitRepoPath,i)),s=(0,l.existsSync)(a);if((0,l.existsSync)(x().resolve(x().join(t.path,t.fileName)))){r.push(t);let o=RegExp(`^${i}$`),l=await (0,u.M_)(n,o);try{if(!1===s)await (0,S.symlink)(x().resolve(x().join(t.path,t.fileName)),a);else if(e.options?.errorIfExists)throw new w.TRPCError({code:"PRECONDITION_FAILED",message:`Symlink for "${t.fileName}" already exists.`});return!1===l&&await (0,S.appendFile)(n,`${i}
`),{result:"success",message:s?`Symlink for "${t.fileName}" already exists. Skipping.`:`Symlink for "${t.fileName}" created`}}catch(e){return{result:"error",message:`Failed to create symlink for "${t.fileName}"${e instanceof Error?`:
	${e.message}`:""}`}}}else{if(s){let n=await unlinkExtension({extension:t,gitRepoPath:e.gitRepoPath,relativePath:e.relativePath});if("error"===n.result)return r.push(t),{result:"error",message:`Failed to remove symlink for non-existent extension file "${t.fileName}" in "${t.path}"`}}return{result:"error",message:`Extension file "${t.fileName}" does not exist in "${t.path}". It has been unlinked and removed from the list of registered extensions`}}}));r.length!==t.length&&e.saveExtensions(r);let a=i.filter(e=>"success"===e.result).length,s=`Symlinked ${a}/${i.length} extension(s): 
`;return i.forEach(e=>{s+=`${e.message} 
`}),{report:s,cleanedUpExtensions:r,symlinkResults:i}},unlinkExtension=async e=>{let t=e.extension,r=x().join("function"==typeof e.relativePath?e.relativePath(t):e.relativePath,t.fileName),n=x().resolve(e.gitRepoPath,".git","info","exclude"),i=x().resolve(x().join(e.gitRepoPath,r));if(!(0,l.existsSync)(x().resolve(x().join(t.path,t.fileName))))return{result:"success",message:`Extension file "${t.fileName}" does not exist in ${t.path}. Nothing to do.`};{let a=RegExp(`^${r}$`);await (0,u.u5)(n,a,null);let s=(0,l.existsSync)(i);try{if(!0===s)await (0,S.unlink)(i);else if(e.options?.errorIfNotExists)throw new w.TRPCError({code:"PRECONDITION_FAILED",message:`Symlink for "${t.fileName}" doesn't exist.`});return{result:"success",message:s?`Symlink for "${t.fileName}" has been removed.`:`Symlink for "${t.fileName}" doesn't exist. Skipping.`}}catch(e){return{result:"error",message:`Failed to remove symlink for "${t.fileName}"`}}}},I=m.z.object({fileName:m.z.string(),path:m.z.string(),extensionName:m.z.string(),errorIfExists:m.z.boolean().optional(),errorIfNotExists:m.z.boolean().optional(),isKinematics:m.z.boolean().optional()}),z=m.z.array(I),getExtensions=()=>{let e=E.Rz.parse(process.env),t=e.RATOS_DATA_DIR,r=x().join(t,"klippy-extensions.json");(0,l.existsSync)(t)||(0,l.mkdirSync)(t),(0,l.existsSync)(r)||(0,l.writeFileSync)(r,"[]");let n=z.parse(JSON.parse((0,l.readFileSync)(r).toString()));return n},saveExtensions=e=>{let t=E.Rz.parse(process.env),r=t.RATOS_DATA_DIR,n=x().join(r,"klippy-extensions.json");(0,l.existsSync)(r)||(0,l.mkdirSync)(r),(0,l.writeFileSync)(n,JSON.stringify(e))},symlinkKlippyExtensions=async e=>{let t=E.Rz.parse(process.env),r=getExtensions();return await symlinkExtensions({extensions:r,options:{errorIfExists:e},gitRepoPath:t.KLIPPER_DIR,relativePath,saveExtensions})},relativePath=e=>e.isKinematics?"klippy/kinematics":"klippy/extras",$=(0,f.Nd)({register:f.$y.input(m.z.object({json:I})).mutation(async({input:e})=>{let t=getExtensions(),{path:r,fileName:n,errorIfExists:i,extensionName:a}=e.json,s=x().join(r,n);if(!(0,l.existsSync)(s))throw new w.TRPCError({message:`File "${s}" does not exist`,code:"PRECONDITION_FAILED"});if(t.find(t=>t.extensionName===a||t.fileName===n&&!!t.isKinematics==!!e.json.isKinematics)){if(!0===i)throw new w.TRPCError({message:`${e.json.isKinematics?"A kinematic":"An"} extension called "${a}" with fileName "${n}" is already registered`,code:"PRECONDITION_FAILED"});return(0,o.j)().warn(`${e.json.isKinematics?"A kinematic":"An"} extension called "${a}" with the fileName "${n}" is already registered, ignoring...`),!0}return t.push(e.json),saveExtensions(t),!0}),unregister:f.$y.input(m.z.object({extensionName:m.z.string(),errorIfNotExists:m.z.boolean().optional()})).mutation(async({input:e})=>{let t=getExtensions(),{extensionName:r}=e,n=t.findIndex(e=>e.extensionName===r);if(-1===n){if(!0===e.errorIfNotExists)throw new w.TRPCError({message:`Extension with the name "${r}" is not registered`,code:"PRECONDITION_FAILED"});return(0,o.j)().warn(`Extension with the name "${r}" is not registered, ignoring...`),{result:"success",message:`Extension "${r}" does not exist. Nothing to do.`}}let i=t.splice(n,1);if(1!==i.length)throw Error("Failed to remove extension");let a=await unlinkExtension({extension:i[0],gitRepoPath:E.Rz.parse(process.env).KLIPPER_DIR,relativePath});return"success"===a.result&&saveExtensions(t),a}),symlink:f.$y.input(m.z.object({errorIfExists:m.z.boolean().optional()})).mutation(async({input:e})=>await symlinkKlippyExtensions(e.errorIfExists)),unlink:f.$y.mutation(async()=>{let e=getExtensions();return await Promise.all(e.map(async e=>{let t=await unlinkExtension({extension:e,gitRepoPath:E.Rz.parse(process.env).KLIPPER_DIR,relativePath});return t}))}),list:f.$y.output(z).query(async()=>getExtensions())}),R=m.z.object({fileName:m.z.string(),path:m.z.string(),extensionName:m.z.string(),errorIfExists:m.z.boolean().optional()}),v=m.z.array(R),moonraker_extensions_getExtensions=()=>{let e=E.Rz.parse(process.env),t=e.RATOS_DATA_DIR,r=x().join(t,"moonraker-extensions.json");(0,l.existsSync)(t)||(0,l.mkdirSync)(t),(0,l.existsSync)(r)||(0,l.writeFileSync)(r,"[]");let n=v.parse(JSON.parse((0,l.readFileSync)(r).toString()));return n},moonraker_extensions_saveExtensions=e=>{let t=E.Rz.parse(process.env),r=t.RATOS_DATA_DIR,n=x().join(r,"moonraker-extensions.json");(0,l.existsSync)(r)||(0,l.mkdirSync)(r),(0,l.writeFileSync)(n,JSON.stringify(e))},symlinkMoonrakerExtensions=async e=>{let t=E.Rz.parse(process.env),r=moonraker_extensions_getExtensions();return await symlinkExtensions({extensions:r,options:{errorIfExists:e},gitRepoPath:t.MOONRAKER_DIR,relativePath:()=>"moonraker/components",saveExtensions:moonraker_extensions_saveExtensions})},A=(0,f.Nd)({register:f.$y.input(m.z.object({json:R})).mutation(async({input:e})=>{let t=moonraker_extensions_getExtensions(),{path:r,fileName:n,errorIfExists:i}=e.json,a=x().join(r,n);if(!(0,l.existsSync)(a))throw(0,o.j)().error(`File "${a}" does not exist`),new w.TRPCError({message:`File "${a}" does not exist`,code:"PRECONDITION_FAILED"});if(t.find(e=>e.fileName===n)){if(!0===i)throw(0,o.j)().error(`An extension with the fileName "${n}" is already registered`),new w.TRPCError({message:`An extension with the fileName "${n}" is already registered`,code:"PRECONDITION_FAILED"});return(0,o.j)().warn(`An extension with the fileName "${n}" is already registered, ignoring...`),!0}return t.push(e.json),moonraker_extensions_saveExtensions(t),!0}),symlink:f.$y.input(m.z.object({errorIfExists:m.z.boolean().optional()})).mutation(async({input:e})=>await symlinkMoonrakerExtensions(e.errorIfExists)),unlink:f.$y.mutation(async()=>{let e=moonraker_extensions_getExtensions(),t=E.Rz.parse(process.env);return await Promise.all(e.map(async e=>{let r=await unlinkExtension({extension:e,gitRepoPath:t.MOONRAKER_DIR,relativePath:"moonraker/components"});return r}))}),unregister:f.$y.input(m.z.object({extensionName:m.z.string(),errorIfNotExists:m.z.boolean().optional()})).mutation(async({input:e})=>{let t=E.Rz.parse(process.env),r=moonraker_extensions_getExtensions(),{extensionName:n}=e,i=r.findIndex(e=>e.extensionName===n);if(-1===i){if(!0===e.errorIfNotExists)throw new w.TRPCError({message:`Extension with the name "${n}" is not registered`,code:"PRECONDITION_FAILED"});return(0,o.j)().warn(`Extension with the name "${n}" is not registered, ignoring...`),{result:"success",message:`Extension with the name "${n}" is not registered`}}let a=r.splice(i,1);if(1!==a.length)throw Error("Failed to remove extension");let s=await unlinkExtension({extension:a[0],gitRepoPath:t.MOONRAKER_DIR,relativePath:"moonraker/components"});return"success"===s.result&&moonraker_extensions_saveExtensions(r),s}),list:f.$y.output(v).query(async()=>moonraker_extensions_getExtensions())});var N=r(45227),O=r(22042),T=r(44439),k=r(89850);let D=m.z.union([m.z.literal("time"),m.z.literal("x_acceleration"),m.z.literal("y_acceleration"),m.z.literal("z_acceleration"),m.z.literal("x"),m.z.literal("y"),m.z.literal("z")]);m.z.object({header:m.z.tuple([D,D,D,D])}),m.z.object({data:m.z.array(m.z.tuple([m.z.number(),m.z.number(),m.z.number(),m.z.number()])),overflows:m.z.number().optional(),errors:m.z.number().optional()}),m.z.array(m.z.tuple([m.z.number(),m.z.number(),m.z.number(),m.z.number()]));let P=m.z.object({frequencies:m.z.array(m.z.number()),estimates:m.z.array(m.z.number()),powerRange:m.z.object({max:m.z.number(),min:m.z.number()})}),_=m.z.object({x:P,y:P,z:P,total:P}),q=m.z.string().brand("MacroID"),C=m.z.string().brand("MacroSequenceID"),F=m.z.string().brand("MacroRecordingID"),M=m.z.string().brand("MacroRecordingRunID"),L=m.z.object({capturePSD:m.z.boolean().default(!1),accelerometer:k.Yx.optional(),color:m.z.string().optional()}).superRefine((e,t)=>(e.capturePSD&&null==e.accelerometer&&t.addIssue({code:m.z.ZodIssueCode.custom,message:"Required when recording resonance data",path:["accelerometer"]}),e)),B=m.z.object({id:F,macroRecordingRunId:M,scv:m.z.number().default(5),macroId:q,sequenceId:C,startTimeStamp:m.z.number(),endTimeStamp:m.z.number(),accelerometer:k.Yx,recordingHardwareName:m.z.string(),psd:_,name:m.z.string()}),K=m.z.object({id:C,name:m.z.string(),recording:L.nullable(),gcode:m.z.string().min(2)}),J=m.z.object({id:q,name:m.z.string(),description:m.z.string(),createdAtTimeStamp:m.z.number(),updatedAtTimeStamp:m.z.number().nullable(),recordingCount:m.z.record(C,m.z.number()),sequences:m.z.array(K)}),H=J.omit({recordingCount:!0,createdAtTimeStamp:!0,updatedAtTimeStamp:!0}),V=require("split2");var Z=r.n(V),W=r(22037);/**
 * @file ndjson.ts
 * @description
 * This file contains helper functions for reading, writing, and transforming newline delimited JSON files.
 * The functions in this file are used to create object storage with common CRUD operations.
 * The object storage is used to store and manage data in a file using newline delimited JSON format.
 * The object storage can be initialized with a Zod schema to validate the objects in the storage.
 * The object storage also provides a destroyStorage operation to delete the storage file.
 *
 * @author Mikkel Schmidt <mikkel.schmidt@gmail.com>
 * @license MIT
 * @copyright 2024
 */let U=E.Rz.parse(process.env),G=x().join(U.RATOS_DATA_DIR,"object-storage.ndjson");m.z.object({id:m.z.coerce.string().brand()});let Y=m.z.object({id:m.z.string().brand("ObjectStorageStatsID"),total:m.z.number().default(0),lastModifiedTimeStamp:m.z.number().nullable().default(null),lastAccessedTimeStamp:m.z.number().nullable().default(null),version:m.z.number().default(0)}),X=new Map,lock=async(e,t=1e3)=>{if(!X.has(e)){X.set(e,[]);return}let r=Error(`File lock timeout of ${t}ms reached, make sure to release the locks you claim on ${e}`);return new Promise((n,i)=>{X.get(e)?.push(n),setTimeout(()=>{i(r)},t)})},release=e=>{let t=X.get(e);if(t){let r=t.shift();r&&r(),0===t.length&&X.delete(e)}},_baseObjectStorage=(e,t)=>{(0,l.existsSync)(e)||((0,l.mkdirSync)(x().dirname(e),{recursive:!0}),(0,l.writeFileSync)(e,""));let getAll=async(r=0,n=1/0)=>await readObjects(e,t,void 0,r,n),find=async r=>await findObject(e,t,r),findAll=async(r,n=1/0)=>await findAllObjects(e,t,r,void 0,n),findById=async r=>await findObject(e,t,e=>e.id===("object"==typeof r?r.id:r)),insert=async r=>{let n=await findById(r);if(n)throw Error(`Object with id ${r.id} already exists`);let i=await saveObject(e,t,r);return i},update=async(r,n)=>{let i=!1,a=await replaceObjects(e,t,e=>e.id===n?(i=!0,t.parse({...e,...r})):e);if(!i)throw Error(`Object with id ${n} not found`);return 0===a.linesChanged&&(0,o.j)().warn(r,`Update to object with id ${n} resulted in no changes`),a},upsert=async(r,n=!1)=>{let i=t.parse(r),a=!1,s=await replaceObjects(e,t,e=>e.id===r.id?(a=!0,i=t.parse({...!0===n?e:{},...r})):e);return a?(s.linesChanged>1&&(0,o.j)().warn(`Upserted more than one object with id ${r.id}`),{updateCount:s,result:i}):{updateCount:0,result:await insert(r)}},transform=async r=>await transformObjects(e,t,r),replace=async r=>await replaceObjects(e,t,r),del=async r=>{let n=[],i=await replaceObjects(e,t,e=>r(e)?(n.push(e),null):t.parse(e));return{found:n,...i}},destroyStorage=async()=>{(0,l.existsSync)(e)&&await new Promise((t,r)=>{(0,S.unlink)(e).then(()=>{(0,o.j)().info(`Deleted object storage file: ${e}`),t()}).catch(t=>{(0,o.j)().error(`Error deleting object storage file: ${e}: ${t instanceof Error?t.message:t}`),r(t)})})};return{getAll,find,findAll,findById,insert,update,upsert,transform,replace,remove:del,destroyStorage}},logStatError=async(e,t=!1)=>{try{return await e()}catch(e){if((0,o.j)().error(`Object storage stat update error: ${e instanceof Error?e.message:e instanceof String?e:"Unknown error"}`),!t)throw e}return null},initObjectStorage=(e,t)=>{let r=_baseObjectStorage(G,Y),n=_baseObjectStorage(e,t),getAll=async(t=0,i=1/0)=>{let a=await n.getAll(t,i),s=await logStatError(async()=>await r.upsert({id:e,lastAccessedTimeStamp:new Date().getTime()},!0));return{...a,total:s.result.total}},find=async e=>{let t=await n.find(e);return t},findById=async e=>{let t=await n.findById(e);return t},findAll=async(e,t=1/0)=>{let r=await n.findAll(e,t);return r},insert=async t=>{let i=await n.insert(t);return await logStatError(async()=>{let t=await r.find(t=>t.id===e);return await r.upsert({id:e,lastAccessedTimeStamp:new Date().getTime(),lastModifiedTimeStamp:new Date().getTime(),total:(t?.total??0)+1},!0)}),i},update=async(t,i)=>{let a=await n.update(t,i);return await logStatError(async()=>await r.upsert({id:e,lastAccessedTimeStamp:new Date().getTime(),lastModifiedTimeStamp:new Date().getTime()},!0)),{updateCount:a,result:await n.findById(i)}},upsert=async t=>{let i=await n.upsert(t);return await logStatError(async()=>{let t=await r.find(t=>t.id===e);return await r.upsert({id:e,lastAccessedTimeStamp:new Date().getTime(),lastModifiedTimeStamp:new Date().getTime(),total:(t?.total??0)+(0===i.updateCount?1:0)},!0)}),i},transform=async(t,i)=>{let a=await n.transform(t);return await logStatError(async()=>{let t={id:e,lastAccessedTimeStamp:new Date().getTime(),lastModifiedTimeStamp:new Date().getTime(),total:a.linesTotal-a.linesDeleted};return null!=i&&(t.version=i),await r.upsert(t,!0)}),a},replace=async t=>{let i=await n.replace(t);return await logStatError(async()=>await r.upsert({id:e,lastAccessedTimeStamp:new Date().getTime(),lastModifiedTimeStamp:new Date().getTime()},!0)),i},del=async t=>{let i=await n.remove(e=>e.id===t);return await logStatError(async()=>{let t=await r.find(t=>t.id===e);return await r.upsert({id:e,lastAccessedTimeStamp:new Date().getTime(),lastModifiedTimeStamp:new Date().getTime(),total:(t?.total??0)-i.linesDeleted})}),i},delAll=async t=>{let i=await n.remove(e=>t.includes(e.id));return await logStatError(async()=>{let t=await r.find(t=>t.id===e);return await r.upsert({id:e,lastAccessedTimeStamp:new Date().getTime(),lastModifiedTimeStamp:new Date().getTime(),total:(t?.total??0)-i.linesDeleted})}),i},destroyStorage=async()=>{await n.destroyStorage();let t=(await r.findById(e))?.total??0;return await r.remove(t=>t.id===e),t};return{getAll,find,findAll,findById,insert,update,upsert,transform,replace,remove:del,removeAll:delAll,destroyStorage}},readObjects=async(e,t,r=()=>{},n=0,i=1/0)=>{if(!(0,l.existsSync)(e))return{result:[],cursor:0,hasNextPage:!1};let a=(0,l.createReadStream)(e,{encoding:"utf-8",start:n,highWaterMark:1048576}),s=(await (0,S.stat)(e)).size-n,c=[],d=Z()(),u=0;function processFile(){let s=!0,l=null;for(;s&&a.readable&&null!==(l=a.read());)s=d.write(l);if(!s&&a.readable){d.once("drain",processFile);return}let p=null;for(;d.readable&&null!==(p=d.read());)!function(s){if(c.length>=i)return a.destroy(),d.destroy();let l=null;try{l=JSON.parse(s.toString())}catch{(0,o.j)().warn(s.toString(),`readObjects: Error parsing json from file ${e} at ${a.bytesRead+n} bytes`)}if(null!=l)try{c.push(t.parse(l)),u+=s.byteLength,!1===r(c[c.length-1])&&(a.destroy(),d.destroy())}catch(t){throw t instanceof m.z.ZodError&&(0,o.j)().warn(t,`readObjects: Error validating object from file ${e} at ${a.bytesRead+n} bytes`),t}}(Buffer.from(p+W.EOL))}return a.on("readable",processFile),a.on("close",()=>{d.end(),processFile()}),d.on("error",t=>{throw(0,o.j)().error(t,`readObjects: Error reading object from file ${e} at ${u+n} bytes`),t}),await new Promise((e,t)=>{d.on("close",e),a.on("error",t),d.on("error",t)}),{result:c,cursor:u+n,hasNextPage:u<s}},findObject=async(e,t,r)=>{let n=null;return await readObjects(e,t,e=>{if(r(e))return n=e,!1}),n},findAllObjects=async(e,t,r,n=0,i=1/0)=>{if(!(0,l.existsSync)(e))return{result:[],cursor:0,hasNextPage:!1};let a=[],s=await readObjects(e,t,e=>{if(r(e)&&a.push(e),a.length>=i)return!1},n);return{...s,result:a}},saveObject=async(e,t,r)=>{let n=(0,l.createWriteStream)(e,{flags:"a+",encoding:"utf-8"}),i=t.parse(r);return n.write(JSON.stringify(i)+"\n"),n.end(),await new Promise((e,t)=>{n.on("close",e),n.on("error",t)}),i},transformObjects=async(e,t,r)=>{if(!(0,l.existsSync)(e))throw Error("File does not exist: "+e);await lock(e);try{return await (0,u.u5)(e,(n,i)=>{try{let e=t.parse(JSON.parse(n));return JSON.stringify(r(e))}catch(t){if(t instanceof m.z.ZodError)return(0,o.j)().warn(t,`transformObjects: Error parsing line ${i} of ${e}: ${t instanceof Error?t.message:t}`),n;throw t}})}finally{release(e)}},replaceObjects=async(e,t,r)=>{if(!(0,l.existsSync)(e))throw Error("File does not exist: "+e);await lock(e);try{let n=await (0,u.u5)(e,(n,i)=>{try{let e=t.parse(JSON.parse(n)),i=r(e);return null==i?null:JSON.stringify(i)}catch(t){if(t instanceof m.z.ZodError)return(0,o.j)().warn(t,`replaceObjects: Error parsing line ${i} of ${e}: ${t instanceof Error?t.message:t}`),n;throw t}});return n}finally{release(e)}},Q=E.Rz.parse(process.env),ee=x().join(Q.RATOS_DATA_DIR,"analysis"),et=x().join(Q.RATOS_DATA_DIR,"analysis","recordings"),er=initObjectStorage(x().join(ee,"macros.ndjson"),J),en=(0,f.Nd)({createMacro:f.$y.input(H).mutation(async({input:e})=>await er.upsert({...e,recordingCount:{},createdAtTimeStamp:Date.now(),updatedAtTimeStamp:null})),updateMacro:f.$y.input(H).mutation(async({input:e})=>{let t=x().join(et,`${e.id}.ndjson`),r=initObjectStorage(t,B);return await r.destroyStorage(),(0,o.j)().info(`Deleted recordings for macro "${e.name}" (${e.id})`),await er.update({...e,recordingCount:{},updatedAtTimeStamp:Date.now()},e.id)}),deleteMacro:f.$y.input(q).mutation(async({input:e})=>{let t=await er.findById(e);if(null==t)throw Error(`Can't delete macro: macro with id ${e} not found`);let r=x().join(et,`${e}.ndjson`),n=initObjectStorage(r,B),i=await n.destroyStorage();(0,o.j)().info(`Deleted recordings for macro "${t.name}" (${t.id})`);let a=await er.remove(e);return(0,o.j)().info(`Deleted macro "${t.name}" (${t.id})`),{result:"success",totalRecordingsRemoved:i,macrosRemoved:a}}),deleteMacros:f.$y.input(m.z.array(q)).mutation(async({input:e})=>{let t=await Promise.all(e.map(async e=>{let t=await er.findById(e);if(null==t){let t=`Can't delete macro: macro with id ${e} not found`;return(0,o.j)().warn(t),{id:e,msg:t,totalRecordingsRemoved:0,success:!1}}let r=x().join(et,`${e}.ndjson`),n=initObjectStorage(r,B),i=await n.destroyStorage(),a=`Deleted ${i} recordings for macro "${t.name}" (${t.id})`;return(0,o.j)().info(a),{id:e,msg:a,totalRecordingsRemoved:i,success:!0}})),r=await er.removeAll(e);return(0,o.j)().info(`Deleted ${r}/${e.length} macros`),{result:t,macrosRemoved:r}}),deleteRecordings:f.$y.input(m.z.object({macroId:q,recordingIds:m.z.array(F)})).mutation(async({input:e})=>{let t=await er.findById(e.macroId);if(null==t){let t=`Can't delete recordings, macro with id ${e.macroId} not found`;return(0,o.j)().warn(t),{msg:t,recordingsRemoved:0,success:!1}}let r=x().join(et,`${e.macroId}.ndjson`),n=initObjectStorage(r,B),i=await n.removeAll(e.recordingIds),a=`Deleted ${i.linesDeleted} recordings for macro "${t.name}" (${e.macroId})`,s=t.recordingCount;return i.found.forEach(e=>{s[e.sequenceId]-=1}),await er.update({recordingCount:s,updatedAtTimeStamp:new Date().getTime()},e.macroId),(0,o.j)().info(a),{msg:a,recordingsRemoved:i.linesDeleted,success:!0}}),findMacro:f.$y.input(m.z.object({id:m.z.string()})).query(async({input:e})=>{let t=await er.findById(e.id);if(null==t)throw Error(`Macro with id ${e.id} not found`);return t}),getMacros:f.$y.input(m.z.object({cursor:m.z.number().default(0),limit:m.z.number().default(50)})).query(async({input:e})=>await er.getAll(e.cursor,e.limit)),saveRecording:f.$y.input(m.z.object({recording:B})).mutation(async({input:e})=>{let t=await er.findById(e.recording.macroId);if(null==t)throw Error(`Can't save recording: macro with id ${e.recording.macroId} not found`);if(!t.sequences.some(t=>t.id===e.recording.sequenceId))throw Error(`Can't save recording: sequence with id ${e.recording.sequenceId} not found in "${t.name}" macro`);let r=x().join(et,`${e.recording.macroId}.ndjson`),n=initObjectStorage(r,B),i=await n.upsert(e.recording);return await er.update({recordingCount:{[e.recording.sequenceId]:(t.recordingCount[e.recording.sequenceId]??0)+1},updatedAtTimeStamp:Date.now()},e.recording.macroId),i}),getNextAndPreviousRunRecordingIds:f.$y.input(m.z.object({macroId:q,runId:M})).output(m.z.object({next:M.nullable(),previous:M.nullable()})).query(async({input:e})=>{let t=x().join(et,`${e.macroId}.ndjson`),r=initObjectStorage(t,B),n=await r.getAll(),i=n.result.findIndex(t=>t.macroRecordingRunId===e.runId),a=n.result.findLastIndex(t=>t.macroRecordingRunId===e.runId);if(-1===i||-1===a)throw Error(`Recording with id ${e.runId} not found in macro with id ${e.macroId}`);let s=n.result[a+1],o=n.result[i-1];return{next:s?.macroRecordingRunId??null,previous:o?.macroRecordingRunId??null}}),getRecordings:f.$y.input(m.z.object({macroId:q,sequenceId:C.optional(),includeSource:m.z.boolean().default(!1),limit:m.z.number().default(50),cursor:m.z.number().default(0)})).query(async({input:e})=>{let t=x().join(et,`${e.macroId}.ndjson`),r=initObjectStorage(t,(e.includeSource,B)),n=await r.getAll(e.cursor,e.limit);if(e.sequenceId){let t=await er.findById(e.macroId);if(null==t)throw Error(`Macro with id ${e.macroId} not found`);n.result=n.result.filter(t=>t.sequenceId===e.sequenceId),n.total=t.recordingCount[e.sequenceId]??0}return n}),getRecording:f.$y.input(m.z.object({macroId:q,recordingId:F})).output(B.nullable()).query(async({input:e})=>{let t=x().join(et,`${e.macroId}.ndjson`),r=initObjectStorage(t,B);return await r.find(t=>t.id===e.recordingId)}),getRunRecordings:f.$y.input(m.z.object({runId:M,macroId:q})).query(async({input:e})=>{let t=x().join(et,`${e.macroId}.ndjson`),r=initObjectStorage(t,B);return await r.findAll(t=>t.macroRecordingRunId===e.runId)})});var ei=r(42618);let ea=(0,f.Nd)({clientLog:f.$y.input(m.z.object({level:m.z.enum(["trace","debug","info","warn","error","fatal"]),logEvent:T.s})).mutation(async({input:e})=>{let t=(0,o.j)().child({source:"frontend"},{level:e.level});for(let r of e.logEvent.bindings)t=t.child(r);t[e.logEvent.level.label](e.logEvent.messages[0],e.logEvent.messages[1],...e.logEvent.messages.slice(2))}),version:f.$y.query(async()=>await (0,c.promisify)(d.exec)("git describe --tags --always",{cwd:process.env.RATOS_CONFIGURATION_PATH}).then(({stdout:e})=>e.trim())),klipperVersion:f.$y.query(async()=>await (0,c.promisify)(d.exec)("git describe --tags --always",{cwd:process.env.KLIPPER_DIR}).then(({stdout:e})=>e.trim())),osVersion:f.$y.query(async()=>{let e=(0,l.statSync)("/etc/ratos-release").isFile()?"/etc/ratos-release":"/etc/RatOS-release";return await (0,c.promisify)(d.exec)(`cat ${e}`).then(({stdout:e})=>e.trim().replace("RatOS ",""))}),ipAddress:f.$y.query(async()=>{let e=await getWirelessInterface(),t=null==e||""===e.trim()?"eth0":e.trim();return await (0,c.promisify)(d.exec)(`ip address | grep "${t}"`).then(({stdout:e})=>e.match(/inet\s(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})/)?.[1])??"Unknown IP"}),resetCache:f.$y.mutation(async()=>(O.oA.flushAll(),{result:"success"})),kill:f.$y.query(async()=>{process.exit()}),reboot:f.$y.mutation(async()=>(setTimeout(()=>{(0,c.promisify)(d.exec)("reboot")},500),{result:"success"})),debugFileList:f.$y.query(async()=>await (0,ei.getDebugZipFiles)()),mcu:j.px,printer:N.Cu,wifi:b,"klippy-extensions":$,"moonraker-extensions":A,analysis:en}),es=require("@trpc/server/adapters/next"),eo={api:{bodyParser:{sizeLimit:"100mb"},responseLimit:"100mb"}},el=es.createNextApiHandler({router:ea,createContext:()=>({boards:[]}),onError:e=>{(0,o.j)().error(e.error)}}),ec=(0,s.l)(n,"default"),ed=(0,s.l)(n,"config"),eu=new i.PagesAPIRouteModule({definition:{kind:a.x.PAGES_API,page:"/api/trpc/[trpc]",pathname:"/api/trpc/[trpc]",bundlePath:"",filename:""},userland:n})}};var t=require("../../../webpack-api-runtime.js");t.C(e);var __webpack_exec__=e=>t(t.s=e),r=t.X(0,[2716,7926,4756,2618],()=>__webpack_exec__(94646));module.exports=r})();