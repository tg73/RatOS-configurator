"use strict";exports.id=1056,exports.ids=[1056],exports.modules={21056:(e,n,s)=>{s.d(n,{symlinkMoonrakerExtensions:()=>symlinkMoonrakerExtensions});var t=s(38316),r=s(56368),o=s(57147),i=s(36523),a=s(98765),l=s(71017),x=s.n(l),g=s(81115),m=s(62807);let c=t.z.object({fileName:t.z.string(),path:t.z.string(),extensionName:t.z.string(),errorIfExists:t.z.boolean().optional()}),E=t.z.array(c),getExtensions=()=>{let e=g.serverSchema.parse(process.env),n=e.RATOS_DATA_DIR,s=x().join(n,"moonraker-extensions.json");(0,o.existsSync)(n)||(0,o.mkdirSync)(n),(0,o.existsSync)(s)||(0,o.writeFileSync)(s,"[]");let t=E.parse(JSON.parse((0,o.readFileSync)(s).toString()));return t},saveExtensions=e=>{let n=g.serverSchema.parse(process.env),s=n.RATOS_DATA_DIR,t=x().join(s,"moonraker-extensions.json");(0,o.existsSync)(s)||(0,o.mkdirSync)(s),(0,o.writeFileSync)(t,JSON.stringify(e))},symlinkMoonrakerExtensions=async e=>{let n=g.serverSchema.parse(process.env),s=getExtensions();return await (0,m.b)({extensions:s,options:{errorIfExists:e},gitRepoPath:n.MOONRAKER_DIR,relativePath:()=>"moonraker/components",saveExtensions})};(0,a.Nd)({register:a.$y.input(t.z.object({json:c})).mutation(async({input:e})=>{let n=getExtensions(),{path:s,fileName:t,errorIfExists:a}=e.json,l=x().join(s,t);if(!(0,o.existsSync)(l))throw(0,i.getLogger)().error(`File "${l}" does not exist`),new r.TRPCError({message:`File "${l}" does not exist`,code:"PRECONDITION_FAILED"});if(n.find(e=>e.fileName===t)){if(!0===a)throw(0,i.getLogger)().error(`An extension with the fileName "${t}" is already registered`),new r.TRPCError({message:`An extension with the fileName "${t}" is already registered`,code:"PRECONDITION_FAILED"});return(0,i.getLogger)().warn(`An extension with the fileName "${t}" is already registered, ignoring...`),!0}return n.push(e.json),saveExtensions(n),!0}),symlink:a.$y.input(t.z.object({errorIfExists:t.z.boolean().optional()})).mutation(async({input:e})=>await symlinkMoonrakerExtensions(e.errorIfExists)),unlink:a.$y.mutation(async()=>{let e=getExtensions(),n=g.serverSchema.parse(process.env);return await Promise.all(e.map(async e=>{let s=await (0,m.Y)({extension:e,gitRepoPath:n.MOONRAKER_DIR,relativePath:"moonraker/components"});return s}))}),unregister:a.$y.input(t.z.object({extensionName:t.z.string(),errorIfNotExists:t.z.boolean().optional()})).mutation(async({input:e})=>{let n=g.serverSchema.parse(process.env),s=getExtensions(),{extensionName:t}=e,o=s.findIndex(e=>e.extensionName===t);if(-1===o){if(!0===e.errorIfNotExists)throw new r.TRPCError({message:`Extension with the name "${t}" is not registered`,code:"PRECONDITION_FAILED"});return(0,i.getLogger)().warn(`Extension with the name "${t}" is not registered, ignoring...`),{result:"success",message:`Extension with the name "${t}" is not registered`}}let a=s.splice(o,1);if(1!==a.length)throw Error("Failed to remove extension");let l=await (0,m.Y)({extension:a[0],gitRepoPath:n.MOONRAKER_DIR,relativePath:"moonraker/components"});return"success"===l.result&&saveExtensions(s),l}),list:a.$y.output(E).query(async()=>getExtensions())})}};