"use strict";exports.id=3471,exports.ids=[3471],exports.modules={13471:(e,n,t)=>{/**
 * @license
 * Copyright 2024 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var a,r,o,i,c,s,u,l,d,p=t(52013),h=function(e){var n=Object.create(null);return e&&Object.keys(e).forEach(function(t){if("default"!==t){var a=Object.getOwnPropertyDescriptor(e,t);Object.defineProperty(n,t,a.get?a:{enumerable:!0,get:function(){return e[t]}})}}),n.default=e,n}(p),extendStatics=function(e,n){return(extendStatics=Object.setPrototypeOf||({__proto__:[]})instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)Object.prototype.hasOwnProperty.call(n,t)&&(e[t]=n[t])})(e,n)};function __awaiter(e,n,t,a){return new(t||(t=Promise))(function(r,o){function fulfilled(e){try{step(a.next(e))}catch(e){o(e)}}function rejected(e){try{step(a.throw(e))}catch(e){o(e)}}function step(e){var n;e.done?r(e.value):((n=e.value)instanceof t?n:new t(function(e){e(n)})).then(fulfilled,rejected)}step((a=a.apply(e,n||[])).next())})}function __generator(e,n){var t,a,r,o,i={label:0,sent:function(){if(1&r[0])throw r[1];return r[1]},trys:[],ops:[]};return o={next:verb(0),throw:verb(1),return:verb(2)},"function"==typeof Symbol&&(o[Symbol.iterator]=function(){return this}),o;function verb(o){return function(c){return function(o){if(t)throw TypeError("Generator is already executing.");for(;i;)try{if(t=1,a&&(r=2&o[0]?a.return:o[0]?a.throw||((r=a.return)&&r.call(a),0):a.next)&&!(r=r.call(a,o[1])).done)return r;switch(a=0,r&&(o=[2&o[0],r.value]),o[0]){case 0:case 1:r=o;break;case 4:return i.label++,{value:o[1],done:!1};case 5:i.label++,a=o[1],o=[0];continue;case 7:o=i.ops.pop(),i.trys.pop();continue;default:if(!(r=(r=i.trys).length>0&&r[r.length-1])&&(6===o[0]||2===o[0])){i=0;continue}if(3===o[0]&&(!r||o[1]>r[0]&&o[1]<r[3])){i.label=o[1];break}if(6===o[0]&&i.label<r[1]){i.label=r[1],r=o;break}if(r&&i.label<r[2]){i.label=r[2],i.ops.push(o);break}r[2]&&i.ops.pop(),i.trys.pop();continue}o=n.call(e,i)}catch(e){o=[6,e],a=0}finally{t=r=0}if(5&o[0])throw o[1];return{value:o[0]?o[1]:void 0,done:!0}}([o,c])}}}function __values(e){var n="function"==typeof Symbol&&Symbol.iterator,t=n&&e[n],a=0;if(t)return t.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&a>=e.length&&(e=void 0),{value:e&&e[a++],done:!e}}};throw TypeError(n?"Object is not iterable.":"Symbol.iterator is not defined.")}function __read(e,n){var t="function"==typeof Symbol&&e[Symbol.iterator];if(!t)return e;var a,r,o=t.call(e),i=[];try{for(;(void 0===n||n-- >0)&&!(a=o.next()).done;)i.push(a.value)}catch(e){r={error:e}}finally{try{a&&!a.done&&(t=o.return)&&t.call(o)}finally{if(r)throw r.error}}return i}function __spreadArray(e,n,t){if(t||2==arguments.length)for(var a,r=0,o=n.length;r<o;r++)!a&&r in n||(a||(a=Array.prototype.slice.call(n,0,r)),a[r]=n[r]);return e.concat(a||Array.prototype.slice.call(n))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var f={},x={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function getWebGLContext(e,n){if(!(e in f)||null!=n){var t=function(e,n){if(1!==e&&2!==e)throw Error("Cannot get WebGL rendering context, WebGL is disabled.");var t=null==n?function(e){if(!p.env().getBool("IS_SAFARI")&&"undefined"!=typeof OffscreenCanvas&&2===e)return new OffscreenCanvas(300,150);if("undefined"!=typeof document)return document.createElement("canvas");throw Error("Cannot create a canvas in this context")}(e):n;return(t.addEventListener("webglcontextlost",function(n){n.preventDefault(),delete f[e]},!1),p.env().getBool("SOFTWARE_WEBGL_ENABLED")&&(x.failIfMajorPerformanceCaveat=!1),1===e)?t.getContext("webgl",x)||t.getContext("experimental-webgl",x):t.getContext("webgl2",x)}(e,n);if(null===t)return console.log("Could not get context for WebGL version",e),null;f[e]=t}var a=f[e];return null==a||a.isContextLost()?(delete f[e],getWebGLContext(e)):(a.disable(a.DEPTH_TEST),a.disable(a.STENCIL_TEST),a.disable(a.BLEND),a.disable(a.DITHER),a.disable(a.POLYGON_OFFSET_FILL),a.disable(a.SAMPLE_COVERAGE),a.enable(a.SCISSOR_TEST),a.enable(a.CULL_FACE),a.cullFace(a.BACK),f[e])}function getDenseTexShape(e){var n=Math.ceil(p.util.sizeFromShape(e)/4);return p.util.sizeToSquarishShape(n)}function getPackedMatrixTextureShapeWidthHeight(e,n){return[Math.max(1,Math.ceil(n/2)),Math.max(1,Math.ceil(e/2))]}function getTextureConfig(e,n){var t,a,r,o,i,c,s,u,l,d;return 2===p.env().getNumber("WEBGL_VERSION")?(t=e.R32F,a=e.R16F,r=e.RGBA16F,o=e.RGBA32F,i=e.RED,s=4,u=1,l=e.HALF_FLOAT,d=e.FLOAT,c=e.RGBA8):(t=e.RGBA,a=e.RGBA,r=e.RGBA,o=e.RGBA,i=e.RGBA,s=4,u=4,l=null!=n?n.HALF_FLOAT_OES:null,d=e.FLOAT,c=e.RGBA),{internalFormatFloat:t,internalFormatHalfFloat:a,internalFormatPackedHalfFloat:r,internalFormatPackedFloat:o,textureFormatFloat:i,downloadTextureFormat:c,downloadUnpackNumChannels:s,defaultNumChannels:u,textureTypeHalfFloat:l,textureTypeFloat:d}}function callAndCheck(e,n){var t=n();return p.env().getBool("DEBUG")&&function(e){var n=e.getError();if(n!==e.NO_ERROR)throw Error("WebGL Error: "+getWebGLErrorMessage(e,n))}(e),t}function canBeRepresented(e){return!!(p.env().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||596e-10<Math.abs(e)&&65504>Math.abs(e))}function getWebGLErrorMessage(e,n){switch(n){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return"Unknown error code ".concat(n)}}function getExtensionOrThrow(e,n){return throwIfNull(e,function(){return e.getExtension(n)},'Extension "'+n+'" not supported on this browser.')}function createVertexShader$1(e,n){var t=throwIfNull(e,function(){return e.createShader(e.VERTEX_SHADER)},"Unable to create vertex WebGLShader.");if(callAndCheck(e,function(){return e.shaderSource(t,n)}),callAndCheck(e,function(){return e.compileShader(t)}),!1===e.getShaderParameter(t,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(t)),Error("Failed to compile vertex shader.");return t}function createFragmentShader(e,n){var t=throwIfNull(e,function(){return e.createShader(e.FRAGMENT_SHADER)},"Unable to create fragment WebGLShader.");if(callAndCheck(e,function(){return e.shaderSource(t,n)}),callAndCheck(e,function(){return e.compileShader(t)}),p.env().get("ENGINE_COMPILE_ONLY"))return t;if(!1===e.getShaderParameter(t,e.COMPILE_STATUS))throw logShaderSourceAndInfoLog(n,e.getShaderInfoLog(t)),Error("Failed to compile fragment shader.");return t}(function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"})(a||(a={})),function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"}(r||(r={})),function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(o||(o={}));var m=/ERROR: [0-9]+:([0-9]+):/g;function logShaderSourceAndInfoLog(e,n){var t=m.exec(n);if(null==t){console.log("Couldn't parse line number in error: ".concat(n)),console.log(e);return}for(var a=+t[1],r=e.split("\n"),o=r.length.toString().length+2,i=r.map(function(e,n){return p.util.rightPad((n+1).toString(),o)+e}),c=0,s=0;s<i.length;s++)c=Math.max(i[s].length,c);var u=i.slice(0,a-1),l=i.slice(a-1,a),d=i.slice(a);console.log(u.join("\n")),console.log(n.split("\n")[0]),console.log("%c ".concat(p.util.rightPad(l[0],c)),"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(d.join("\n"))}function createProgram(e){return throwIfNull(e,function(){return e.createProgram()},"Unable to create WebGLProgram.")}function linkProgram(e,n){if(callAndCheck(e,function(){return e.linkProgram(n)}),!p.env().get("ENGINE_COMPILE_ONLY")&&!1===e.getProgramParameter(n,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(n)),Error("Failed to link vertex and fragment shaders.")}function validateProgram(e,n){if(callAndCheck(e,function(){return e.validateProgram(n)}),!1===e.getProgramParameter(n,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(n)),Error("Shader program validation failed.")}function createStaticVertexBuffer(e,n){var t=throwIfNull(e,function(){return e.createBuffer()},"Unable to create WebGLBuffer");return callAndCheck(e,function(){return e.bindBuffer(e.ARRAY_BUFFER,t)}),callAndCheck(e,function(){return e.bufferData(e.ARRAY_BUFFER,n,e.STATIC_DRAW)}),t}function createStaticIndexBuffer(e,n){var t=throwIfNull(e,function(){return e.createBuffer()},"Unable to create WebGLBuffer");return callAndCheck(e,function(){return e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,t)}),callAndCheck(e,function(){return e.bufferData(e.ELEMENT_ARRAY_BUFFER,n,e.STATIC_DRAW)}),t}function createTexture(e){return throwIfNull(e,function(){return e.createTexture()},"Unable to create WebGLTexture.")}function validateTextureSize(e,n){var t=p.env().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||n<=0){var a="[".concat(e,"x").concat(n,"]");throw Error("Requested texture size "+a+" is invalid.")}if(e>t||n>t){var a="[".concat(e,"x").concat(n,"]");throw Error("Requested texture size "+a+" greater than WebGL maximum on this browser / GPU "+"[".concat(t,"x").concat(t,"]")+".")}}function createFramebuffer(e){return throwIfNull(e,function(){return e.createFramebuffer()},"Unable to create WebGLFramebuffer.")}function bindVertexBufferToProgramAttribute(e,n,t,a,r,o,i){var c=e.getAttribLocation(n,t);return -1!==c&&(callAndCheck(e,function(){return e.bindBuffer(e.ARRAY_BUFFER,a)}),callAndCheck(e,function(){return e.vertexAttribPointer(c,r,e.FLOAT,!1,o,i)}),callAndCheck(e,function(){return e.enableVertexAttribArray(c)}),!0)}function bindTextureUnit(e,n,t){validateTextureUnit(e,t),callAndCheck(e,function(){return e.activeTexture(e.TEXTURE0+t)}),callAndCheck(e,function(){return e.bindTexture(e.TEXTURE_2D,n)})}function getProgramUniformLocationOrThrow(e,n,t){return throwIfNull(e,function(){return e.getUniformLocation(n,t)},'uniform "'+t+'" not present in program.')}function getProgramUniformLocation(e,n,t){return e.getUniformLocation(n,t)}function bindTextureToProgramUniformSampler(e,n,t,a){callAndCheck(e,function(){return bindTextureUnit(e,n,a)}),callAndCheck(e,function(){return e.uniform1i(t,a)})}function bindColorTextureToFramebuffer(e,n,t){callAndCheck(e,function(){return e.bindFramebuffer(e.FRAMEBUFFER,t)}),callAndCheck(e,function(){return e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0)})}function unbindColorTextureFromFramebuffer(e,n){callAndCheck(e,function(){return e.bindFramebuffer(e.FRAMEBUFFER,n)}),callAndCheck(e,function(){return e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0)})}function validateFramebuffer(e){var n=e.checkFramebufferStatus(e.FRAMEBUFFER);if(n!==e.FRAMEBUFFER_COMPLETE)throw Error("Error binding framebuffer: "+getFramebufferErrorMessage(e,n))}function getFramebufferErrorMessage(e,n){switch(n){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return"unknown error ".concat(n)}}function throwIfNull(e,n,t){var a=callAndCheck(e,function(){return n()});if(null==a)throw Error(t);return a}function validateTextureUnit(e,n){var t=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,a=n+e.TEXTURE0;if(a<e.TEXTURE0||a>t)throw Error("textureUnit must be in ".concat("[gl.TEXTURE0, gl.TEXTURE".concat(t,"]"),"."))}function getBatchDim(e,n){return void 0===n&&(n=2),p.util.sizeFromShape(e.slice(0,e.length-n))}function getRowsCols(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function getShapeAs3D(e){var n=[1,1,1];return 0===e.length||1===e.length&&1===e[0]||(n=__spreadArray([getBatchDim(e)],__read(getRowsCols(e)),!1)),n}function getTextureShapeFromLogicalShape(e,n){void 0===n&&(n=!1);var t,a=p.env().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=p.env().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");r===1/0&&p.env().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=a/2),n&&(a*=2,r*=2,1===(e=e.map(function(n,t){return t>=e.length-2?p.util.nearestLargerEven(e[t]):e[t]})).length&&(e=[2,e[0]])),2!==e.length&&(e=p.util.squeezeShape(e).newShape);var o=p.util.sizeFromShape(e),i=null;e.length<=1&&o<=a?i=[1,o]:2===e.length&&e[0]<=a&&e[1]<=a?i=e:3===e.length&&e[0]*e[1]<=a&&e[2]<=a?i=[e[0]*e[1],e[2]]:3===e.length&&e[0]<=a&&e[1]*e[2]<=a?i=[e[0],e[1]*e[2]]:4===e.length&&e[0]*e[1]*e[2]<=a&&e[3]<=a?i=[e[0]*e[1]*e[2],e[3]]:4===e.length&&e[0]<=a&&e[1]*e[2]*e[3]<=a&&(i=[e[0],e[1]*e[2]*e[3]]);var c=null!=i&&Math.max.apply(Math,__spreadArray([],__read(i),!1))>r&&Math.min.apply(Math,__spreadArray([],__read(i),!1))<=(n?2:1)&&Math.min.apply(Math,__spreadArray([],__read(i),!1))>0;if(null==i||c){if(n){var s=getBatchDim(e),u=2,l=2;e.length&&(u=(t=__read(getRowsCols(e),2))[0],l=t[1]),o=s*(u/2)*(l/2),i=p.util.sizeToSquarishShape(o).map(function(e){return 2*e})}else i=p.util.sizeToSquarishShape(o)}return i}function isReshapeFree(e,n){if(e=e.slice(-2),n=n.slice(-2),p.util.arraysEqual(e,n)||!e.length||!n.length||0===e[0]||0===e[1]||0===n[0]||0===n[1])return!0;if(e.length!==n.length){var t=e[e.length-1],a=n[n.length-1];if(t===a||t%2==0&&a%2==0&&(1===e[0]||1===n[0]))return!0}return e[1]===n[1]&&e[0]%2==0&&n[0]%2==0}function getWebGLMaxTextureSize(e){if(null==i){var n=getWebGLContext(e);i=n.getParameter(n.MAX_TEXTURE_SIZE)}return i}function getMaxTexturesInShader(e){if(null==c){var n=getWebGLContext(e);c=n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,c)}function getWebGLDisjointQueryTimerVersion(e){if(0===e)return 0;var n=getWebGLContext(e);return hasExtension(n,"EXT_disjoint_timer_query_webgl2")&&2===e?2:hasExtension(n,"EXT_disjoint_timer_query")?1:0}function hasExtension(e,n){return null!=e.getExtension(n)}function isWebGLVersionEnabled(e){try{var n=getWebGLContext(e);if(null!=n)return!0}catch(e){console.log("Error when getting WebGL context: ",e)}return!1}function isCapableOfRenderingToFloatTexture(e){if(0===e)return!1;var n=getWebGLContext(e);if(1===e){if(!hasExtension(n,"OES_texture_float"))return!1}else if(!hasExtension(n,"EXT_color_buffer_float"))return!1;return createFloatTextureAndBindToFramebuffer(n)}function isDownloadFloatTextureEnabled(e){if(0===e)return!1;var n=getWebGLContext(e);if(1===e){if(!hasExtension(n,"OES_texture_float")||!hasExtension(n,"WEBGL_color_buffer_float"))return!1}else{if(hasExtension(n,"EXT_color_buffer_float"))return createFloatTextureAndBindToFramebuffer(n);var t="EXT_color_buffer_half_float";if(hasExtension(n,t)){var a,r,o,i,c=n.getExtension(t);return a=getTextureConfig(n,c),r=n.createTexture(),n.bindTexture(n.TEXTURE_2D,r),n.texImage2D(n.TEXTURE_2D,0,a.internalFormatHalfFloat,1,1,0,a.textureFormatFloat,a.textureTypeHalfFloat,null),o=n.createFramebuffer(),n.bindFramebuffer(n.FRAMEBUFFER,o),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,r,0),i=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE,n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(r),n.deleteFramebuffer(o),i}return!1}return createFloatTextureAndBindToFramebuffer(n)}function createFloatTextureAndBindToFramebuffer(e){var n=getTextureConfig(e),t=e.createTexture();e.bindTexture(e.TEXTURE_2D,t),e.texImage2D(e.TEXTURE_2D,0,n.internalFormatFloat,1,1,0,n.textureFormatFloat,n.textureTypeFloat,null);var a=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,a),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0);var r=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(t),e.deleteFramebuffer(a),r}function isWebGLFenceEnabled(e){return 2===e&&null!=getWebGLContext(e).fenceSync}function assertNotComplex(e,n){Array.isArray(e)||(e=[e]),e.forEach(function(e){null!=e&&p.util.assert("complex64"!==e.dtype,function(){return"".concat(n," does not support complex64 tensors ")+"in the WebGL backend."})})}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var g=p.env();/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function getGlslDifferences(){var e,n,t,a,r,o,i,c,s,u;return 2===p.env().getNumber("WEBGL_VERSION")?(e="#version 300 es",n="in",t="out",a="in",r="texture",o="outputColor",i="out vec4 outputColor;",c=p.env().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",s="",u="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(e="",n="attribute",t="varying",a="varying",r="texture2D",o="gl_FragColor",i="",c="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",s="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",u="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:e,attribute:n,varyingVs:t,varyingFs:a,texture2D:r,output:o,defineOutput:i,defineSpecialNaN:c,defineSpecialInf:s,defineRound:u}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function getLogicalCoordinatesFromFlatIndex(e,n,t){void 0===t&&(t="index");var a=p.util.computeStrides(n);return a.map(function(n,r){var o="int ".concat(e[r]," = ").concat(t," / ").concat(n),i=r===a.length-1?"int ".concat(e[r+1]," = ").concat(t," - ").concat(e[r]," * ").concat(n):"index -= ".concat(e[r]," * ").concat(n);return"".concat(o,"; ").concat(i,";")}).join("")}function getOutputLogicalCoordinatesFromFlatIndexByUniform(e,n,t){void 0===t&&(t="index");var a=p.util.computeStrides(n);return a.map(function(n,r){var o="int ".concat(e[r]," = ").concat(t," / outShapeStrides[").concat(r,"]"),i=r===a.length-1?"int ".concat(e[r+1]," = ").concat(t," - ").concat(e[r]," * outShapeStrides[").concat(r,"]"):"index -= ".concat(e[r]," * outShapeStrides[").concat(r,"]");return"".concat(o,"; ").concat(i,";")}).join("")}function getFlatIndexFrom3D(e){var n=p.util.computeStrides(e).map(function(e){return e.toString()});return"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ".concat(n[0]," + coords.y * ").concat(n[1]," + coords.z;\n  }\n")}function getFlatIndexFrom3DOutput(){return"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n"}g.registerFlag("HAS_WEBGL",function(){return g.getNumber("WEBGL_VERSION")>0}),g.registerFlag("WEBGL_VERSION",function(){return isWebGLVersionEnabled(2)?2:isWebGLVersionEnabled(1)?1:0}),g.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",function(){return!1}),g.registerFlag("WEBGL_BUFFER_SUPPORTED",function(){return 2===g.get("WEBGL_VERSION")}),g.registerFlag("WEBGL_CPU_FORWARD",function(){return!0}),g.registerFlag("WEBGL_FORCE_F16_TEXTURES",function(){return!1}),g.registerFlag("WEBGL_PACK",function(){return g.getBool("HAS_WEBGL")}),g.registerFlag("WEBGL_PACK_NORMALIZATION",function(){return g.getBool("WEBGL_PACK")}),g.registerFlag("WEBGL_PACK_CLIP",function(){return g.getBool("WEBGL_PACK")}),g.registerFlag("WEBGL_PACK_DEPTHWISECONV",function(){return g.getBool("WEBGL_PACK")}),g.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",function(){return g.getBool("WEBGL_PACK")}),g.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",function(){return g.getBool("WEBGL_PACK")}),g.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",function(){return g.getBool("WEBGL_PACK")}),g.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",function(){return g.getBool("WEBGL_PACK")}),g.registerFlag("WEBGL_PACK_REDUCE",function(){return g.getBool("WEBGL_PACK")}),g.registerFlag("WEBGL_LAZILY_UNPACK",function(){return g.getBool("WEBGL_PACK")}),g.registerFlag("WEBGL_CONV_IM2COL",function(){return g.getBool("WEBGL_PACK")}),g.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",function(){return g.getBool("WEBGL_PACK")}),g.registerFlag("WEBGL_MAX_TEXTURE_SIZE",function(){return getWebGLMaxTextureSize(g.getNumber("WEBGL_VERSION"))}),g.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",function(){return getMaxTexturesInShader(g.getNumber("WEBGL_VERSION"))}),g.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",function(){var e=g.getNumber("WEBGL_VERSION");return 0===e?0:getWebGLDisjointQueryTimerVersion(e)}),g.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",function(){return g.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!p.device_util.isMobile()}),g.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",function(){return isCapableOfRenderingToFloatTexture(g.getNumber("WEBGL_VERSION"))}),g.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",function(){return!g.getBool("WEBGL_FORCE_F16_TEXTURES")&&g.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")}),g.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",function(){return isDownloadFloatTextureEnabled(g.getNumber("WEBGL_VERSION"))}),g.registerFlag("WEBGL_FENCE_API_ENABLED",function(){return isWebGLFenceEnabled(g.getNumber("WEBGL_VERSION"))}),g.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",function(){return g.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0}),g.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",function(){return -1},function(e){if("number"!=typeof e)throw Error("WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but "+"got ".concat(e,"."));if(e<0&&-1!==e)throw Error("WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never "+"delete) or at least 0, but got ".concat(e,"."))}),g.registerFlag("WEBGL_FLUSH_THRESHOLD",function(){return p.device_util.isMobile()?1:-1},function(e){if("number"!=typeof e)throw Error("WEBGL_FLUSH_THRESHOLD must be a number but got "+"".concat(e,"."));if(e<0&&-1!==e)throw Error("WEBGL_FLUSH_THRESHOLD must be -1 (indicating never "+"manual flush) or at least 0, but got ".concat(e,"."))}),g.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",function(){return 128}),g.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",function(){return!1}),g.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",function(){return 1e5}),g.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",function(){return 128}),g.registerFlag("WEBGL_EXP_CONV",function(){return!1}),g.registerFlag("SOFTWARE_WEBGL_ENABLED",function(){return g.getBool("IS_TEST")}),g.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",function(){return 1/0}),g.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",function(){return!1}),g.registerFlag("WEBGL2_ISNAN_CUSTOM",function(){return!1}),g.registerFlag("ENGINE_COMPILE_ONLY",function(){return!1});var v="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",b=p.backend_util.getBroadcastDims;function getOutputScalarCoords(){return"\n    int getOutputCoords() {\n      return 0;\n    }\n  "}function getFlatOffsetUniformName(e){return"offset".concat(e)}function getUniformSampler(e){var n=e.name,t=p.util.sizeFromShape(e.shapeInfo.logicalShape);return t<2?"return ".concat(n,";"):"\n    for (int i = 0; i < ".concat(t,"; i++) {\n      if (i == index) {\n        return ").concat(n,"[i];\n      }\n    }\n  ")}function getCoordsDataType(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error("GPU for rank ".concat(e," is not yet supported"))}function getUniformInfoFromShape(e,n,t){var a=p.util.squeezeShape(n),r=a.newShape,o=a.keptDims,i=n.length,c=e&&3===i&&1===n[0],s=c?n.slice(1):r,u=!e&&i>1&&!p.util.arraysEqual(n,t)&&r.length<i||c,l=u?s:n;return{useSqueezeShape:u,uniformShape:l,keptDims:o}}function squeezeInputInfo(e,n){var t=JSON.parse(JSON.stringify(e));return t.shapeInfo.logicalShape=n,t}function getSqueezedParams(e,n){return n.map(function(n){return e[n]}).join(", ")}function getUniformLocations(e,n,t){var a,r,o,i,c,s,u,l=[],d=[],h=null,f=null;f=e.getUniformLocation(t,"NAN",!1),1===p.env().getNumber("WEBGL_VERSION")&&(h=e.getUniformLocation(t,"INFINITY",!1));try{for(var x=__values(n.variableNames),m=x.next();!m.done;m=x.next()){var g=m.value,v={name:g,uniform:e.getUniformLocation(t,g,!1),offset:e.getUniformLocation(t,"offset".concat(g),!1)};n.enableShapeUniforms&&(v.shape=e.getUniformLocation(t,"".concat(g,"Shape"),!1),v.texShape=e.getUniformLocation(t,"".concat(g,"TexShape"),!1)),l.push(v)}}catch(e){a={error:e}}finally{try{m&&!m.done&&(r=x.return)&&r.call(x)}finally{if(a)throw a.error}}if(n.enableShapeUniforms&&(c=e.getUniformLocation(t,"outShape",!1),u=e.getUniformLocation(t,"outShapeStrides",!1),s=e.getUniformLocation(t,"outTexShape",!1)),n.customUniforms)try{for(var b=__values(n.customUniforms),C=b.next();!C.done;C=b.next()){var y=C.value;d.push(e.getUniformLocation(t,y.name,!1))}}catch(e){o={error:e}}finally{try{C&&!C.done&&(i=b.return)&&i.call(b)}finally{if(o)throw o.error}}return{variablesLocations:l,customUniformLocations:d,infLoc:h,nanLoc:f,outShapeLocation:c,outShapeStridesLocation:u,outTexShapeLocation:s}}function validateBinaryAndProgram(e,n){if(e.length!==n.length)throw Error("Binary was compiled with ".concat(e.length," inputs, but ")+"was executed with ".concat(n.length," inputs"));e.forEach(function(e,t){var a=e.logicalShape,r=n[t],o=r.shape;if(!p.util.arraysEqual(a,o))throw Error("Binary was compiled with different shapes than "+"the current args. Shapes ".concat(a," and ").concat(o," must match"));if(!e.isUniform||!r.isUniform){var i=e.texShape,c=r.isUniform?null:r.texData.texShape;if(!p.util.arraysEqual(i,c))throw Error("Binary was compiled with different texture shapes than the"+" current args. Shape ".concat(i," and ").concat(c," must match"))}})}function useShapeUniforms(e){return p.env().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var DecodeMatrixProgram=function(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=a.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];var n=getGlslDifferences();this.outputShape=e,this.enableShapeUniforms=useShapeUniforms(this.outputShape.length),this.userCode="\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ".concat(this.enableShapeUniforms?getOutputLogicalCoordinatesFromFlatIndexByUniform(["r","c","d"],e):getLogicalCoordinatesFromFlatIndex(["r","c","d"],e),"\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ").concat(n.output," = result;\n      }\n    ")},DecodeMatrixPackedProgram=function(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=a.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];var n=getGlslDifferences();this.outputShape=e,this.enableShapeUniforms=useShapeUniforms(this.outputShape.length),this.userCode="\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ".concat(this.enableShapeUniforms?getOutputLogicalCoordinatesFromFlatIndexByUniform(["r","c","d"],e):getLogicalCoordinatesFromFlatIndex(["r","c","d"],e),"\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ").concat(n.output," = result;\n      }\n    ")},EncodeFloatProgram=function(e){this.variableNames=["A"],this.outTexUsage=r.DOWNLOAD;var n=getGlslDifferences();this.outputShape=e,this.userCode="\n      ".concat(v,"\n\n      void main() {\n        float x = getAAtOutCoords();\n        ").concat(n.output," = encode_float(x);\n      }\n    ")},EncodeFloatPackedProgram=function(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=r.DOWNLOAD;var n=getGlslDifferences();this.outputShape=e,this.userCode="\n      ".concat(v,"\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ").concat(n.output," = encode_float(x);\n      }\n    ")},C={R:0,G:1,B:2,A:3},EncodeMatrixProgram=function(e,n,t){void 0===n&&(n=!1),void 0===t&&(t="RGBA"),this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];var a=getGlslDifferences();this.outputShape=e,this.enableShapeUniforms=useShapeUniforms(this.outputShape.length);var r="result";n&&(r="floor(result * 255. + 0.5)");for(var o="",i=0;i<t.length;i++){var c=t[i];o+="\n          if(offset == ".concat(i,") {\n            result = values[").concat(C[c],"];\n          }")}this.userCode="\n      ".concat(this.enableShapeUniforms?getFlatIndexFrom3DOutput():getFlatIndexFrom3D(e),"\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ").concat(t.length,");\n\n        flatIndex = idiv(flatIndex, ").concat(t.length,", 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ").concat(a.texture2D,"(A, uv);\n          ").concat(o,"\n        }\n        ").concat(a.output," = vec4(").concat(r,", 0., 0., 0.);\n      }\n    ")},EncodeMatrixPackedProgram=function(e,n){void 0===n&&(n=!1),this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];var t=getGlslDifferences();this.outputShape=e,this.enableShapeUniforms=useShapeUniforms(this.outputShape.length);var a="",r="result";n&&(r="floor(result * 255. + 0.5)");for(var o=0;o<=1;o++)for(var i=0;i<=1;i++){var c=2*o+i;a+="\n          localCoords = coords;\n          if(localCoords[2] + ".concat(i," < ").concat(this.enableShapeUniforms?"outShape[2]":"".concat(e[2]),") {\n          localCoords[2] += ").concat(i,";\n          if (localCoords[1] + ").concat(o," < ").concat(this.enableShapeUniforms?"outShape[1]":"".concat(e[1]),") {\n            localCoords[1] += ").concat(o,";\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ").concat(t.texture2D,"(A, uv);\n\n            if (offset == 0) {\n              result[").concat(c,"] = values[0];\n            } else if (offset == 1) {\n              result[").concat(c,"] = values[1];\n            } else if (offset == 2) {\n              result[").concat(c,"] = values[2];\n            } else {\n              result[").concat(c,"] = values[3];\n            }\n          }\n        }\n        ")}this.userCode="\n        ".concat(this.enableShapeUniforms?getFlatIndexFrom3DOutput():getFlatIndexFrom3D(e),"\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ").concat(a,"\n\n          ").concat(t.output," = ").concat(r,";\n        }\n    ")};function createVertexShader(e){var n=getGlslDifferences();return createVertexShader$1(e,"".concat(n.version,"\n    precision highp float;\n    ").concat(n.attribute," vec3 clipSpacePos;\n    ").concat(n.attribute," vec2 uv;\n    ").concat(n.varyingVs," vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }"))}function createVertexBuffer(e){return createStaticVertexBuffer(e,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function createIndexBuffer(e){return createStaticIndexBuffer(e,new Uint16Array([0,1,2,2,1,3]))}function createAndConfigureTexture(e,n,t,a,r,o){validateTextureSize(n,t);var i=createTexture(e),c=e.TEXTURE_2D;return callAndCheck(e,function(){return e.bindTexture(c,i)}),callAndCheck(e,function(){return e.texParameteri(c,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE)}),callAndCheck(e,function(){return e.texParameteri(c,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE)}),callAndCheck(e,function(){return e.texParameteri(c,e.TEXTURE_MIN_FILTER,e.NEAREST)}),callAndCheck(e,function(){return e.texParameteri(c,e.TEXTURE_MAG_FILTER,e.NEAREST)}),1===p.env().getNumber("WEBGL_VERSION")?callAndCheck(e,function(){return e.texImage2D(c,0,a,n,t,0,r,o,null)}):callAndCheck(e,function(){return e.texStorage2D(c,1,a,n,t)}),callAndCheck(e,function(){return e.bindTexture(e.TEXTURE_2D,null)}),{texture:i,texShape:[t,n]}}function getInternalFormatForFloat32MatrixTexture(e){return e.internalFormatFloat}function createFloat32MatrixTexture(e,n,t,a){var r=__read([t,n],2);return createAndConfigureTexture(e,r[0],r[1],getInternalFormatForFloat32MatrixTexture(a),a.textureFormatFloat,e.FLOAT)}function getInternalFormatForFloat16MatrixTexture(e){return e.internalFormatHalfFloat}function createFloat16MatrixTexture(e,n,t,a){var r=__read([t,n],2);return createAndConfigureTexture(e,r[0],r[1],getInternalFormatForFloat16MatrixTexture(a),a.textureFormatFloat,a.textureTypeHalfFloat)}function getInternalFormatForUnsignedBytesMatrixTexture(e){return e.downloadTextureFormat}function createUnsignedBytesMatrixTexture(e,n,t,a){var r=__read([t,n],2);return createAndConfigureTexture(e,r[0],r[1],getInternalFormatForUnsignedBytesMatrixTexture(a),e.RGBA,e.UNSIGNED_BYTE)}function getInternalFormatForPackedMatrixTexture(e){return e.internalFormatPackedFloat}function createPackedMatrixTexture(e,n,t,a){var r=__read(getPackedMatrixTextureShapeWidthHeight(n,t),2);return createAndConfigureTexture(e,r[0],r[1],getInternalFormatForPackedMatrixTexture(a),e.RGBA,e.FLOAT)}function getInternalFormatForFloat16PackedMatrixTexture(e){return e.internalFormatPackedHalfFloat}function createFloat16PackedMatrixTexture(e,n,t,a){var r=__read(getPackedMatrixTextureShapeWidthHeight(n,t),2);return createAndConfigureTexture(e,r[0],r[1],getInternalFormatForFloat16PackedMatrixTexture(a),e.RGBA,a.textureTypeHalfFloat)}function bindVertexProgramAttributeStreams(e,n,t){return callAndCheck(e,function(){return e.bindBuffer(e.ARRAY_BUFFER,t)}),bindVertexBufferToProgramAttribute(e,n,"clipSpacePos",t,3,20,0)&&bindVertexBufferToProgramAttribute(e,n,"uv",t,2,20,12)}function uploadDenseMatrixToTexture(e,n,t,a,r,o){var i,c,s;callAndCheck(e,function(){return e.bindTexture(e.TEXTURE_2D,n)}),r instanceof Uint8Array?(i=new Uint8Array(t*a*4),c=e.UNSIGNED_BYTE,s=e.RGBA):(i=new Float32Array(t*a*4),c=e.FLOAT,s=o.internalFormatPackedFloat),i.set(r),2===p.env().getNumber("WEBGL_VERSION")?callAndCheck(e,function(){return e.texSubImage2D(e.TEXTURE_2D,0,0,0,t,a,e.RGBA,c,i)}):callAndCheck(e,function(){return e.texImage2D(e.TEXTURE_2D,0,s,t,a,0,e.RGBA,c,i)}),callAndCheck(e,function(){return e.bindTexture(e.TEXTURE_2D,null)})}function uploadPixelDataToTexture(e,n,t){callAndCheck(e,function(){return e.bindTexture(e.TEXTURE_2D,n)}),t.data instanceof Uint8Array?2===p.env().getNumber("WEBGL_VERSION")?callAndCheck(e,function(){return e.texSubImage2D(e.TEXTURE_2D,0,0,0,t.width,t.height,e.RGBA,e.UNSIGNED_BYTE,t.data)}):callAndCheck(e,function(){return e.texImage2D(e.TEXTURE_2D,0,e.RGBA,t.width,t.height,0,e.RGBA,e.UNSIGNED_BYTE,t.data)}):2===p.env().getNumber("WEBGL_VERSION")?callAndCheck(e,function(){return e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,t)}):callAndCheck(e,function(){return e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,t)}),callAndCheck(e,function(){return e.bindTexture(e.TEXTURE_2D,null)})}function createBufferFromOutputTexture(e,n,t,a){var r=e.createBuffer();callAndCheck(e,function(){return e.bindBuffer(e.PIXEL_PACK_BUFFER,r)});var o=16*n*t;return callAndCheck(e,function(){return e.bufferData(e.PIXEL_PACK_BUFFER,o,e.STREAM_READ)}),callAndCheck(e,function(){return e.readPixels(0,0,t,n,e.RGBA,e.FLOAT,0)}),callAndCheck(e,function(){return e.bindBuffer(e.PIXEL_PACK_BUFFER,null)}),r}function downloadFloat32MatrixFromBuffer(e,n,t){var a=new Float32Array(t);return e.bindBuffer(e.PIXEL_PACK_BUFFER,n),e.getBufferSubData(e.PIXEL_PACK_BUFFER,0,a),e.bindBuffer(e.PIXEL_PACK_BUFFER,null),a}function downloadByteEncodedFloatMatrixFromOutputTexture(e,n,t,a){var r=__read([t,n],2),o=r[0],i=r[1],c=new Uint8Array(n*t*4);return callAndCheck(e,function(){return e.readPixels(0,0,o,i,a.downloadTextureFormat,e.UNSIGNED_BYTE,c)}),new Float32Array(c.buffer)}function downloadPackedMatrixFromBuffer(e,n,t,a,r,o,i,c){var s,u=new Float32Array((s=__read(getPackedMatrixTextureShapeWidthHeight(o,i),2))[0]*s[1]*4);return e.bindBuffer(e.PIXEL_PACK_BUFFER,n),e.getBufferSubData(e.PIXEL_PACK_BUFFER,0,u),e.bindBuffer(e.PIXEL_PACK_BUFFER,null),u}function downloadMatrixFromPackedOutputTexture(e,n,t){var a=new Float32Array(n*t*4);return callAndCheck(e,function(){return e.readPixels(0,0,t,n,e.RGBA,e.FLOAT,a)}),a}var y=function(){function GPGPUContext(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];var n,t=p.env().getNumber("WEBGL_VERSION");if(null!=e?(this.gl=e,n=e,f[t]=n):this.gl=getWebGLContext(t),e=this.gl,2===p.env().getNumber("WEBGL_VERSION")){var a=e;this.createVertexArray=function(){return callAndCheck(a,function(){return a.createVertexArray()})},this.bindVertexArray=function(e){return callAndCheck(a,function(){return a.bindVertexArray(e)})},this.deleteVertexArray=function(e){return callAndCheck(a,function(){return a.deleteVertexArray(e)})},this.getVertexArray=function(){return callAndCheck(a,function(){return a.getParameter(a.VERTEX_ARRAY_BINDING)})}}else if(null!=e){var r=e.getExtension("OES_vertex_array_object");if(null==r)throw Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=function(){return callAndCheck(e,function(){return r.createVertexArrayOES()})},this.bindVertexArray=function(n){return callAndCheck(e,function(){return r.bindVertexArrayOES(n)})},this.deleteVertexArray=function(n){return callAndCheck(e,function(){return r.deleteVertexArrayOES(n)})},this.getVertexArray=function(){return callAndCheck(e,function(){return e.getParameter(r.VERTEX_ARRAY_BINDING_OES)})}}var o="WEBGL_color_buffer_float",i="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===p.env().getNumber("WEBGL_VERSION")){var c="OES_texture_half_float";if(this.textureFloatExtension=getExtensionOrThrow(this.gl,"OES_texture_float"),hasExtension(this.gl,c))this.textureHalfFloatExtension=getExtensionOrThrow(this.gl,c);else if(p.env().get("WEBGL_FORCE_F16_TEXTURES"))throw Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(o),hasExtension(this.gl,i))this.colorBufferHalfFloatExtension=getExtensionOrThrow(this.gl,i);else if(p.env().get("WEBGL_FORCE_F16_TEXTURES"))throw Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(o="EXT_color_buffer_float",hasExtension(this.gl,o))this.colorBufferFloatExtension=this.gl.getExtension(o);else if(hasExtension(this.gl,i))this.colorBufferHalfFloatExtension=this.gl.getExtension(i);else throw Error("GL context does not support color renderable floats");this.vertexBuffer=createVertexBuffer(this.gl),this.indexBuffer=createIndexBuffer(this.gl),this.framebuffer=createFramebuffer(this.gl),this.textureConfig=getTextureConfig(this.gl,this.textureHalfFloatExtension)}return Object.defineProperty(GPGPUContext.prototype,"debug",{get:function(){return p.env().getBool("DEBUG")},enumerable:!1,configurable:!0}),GPGPUContext.prototype.dispose=function(){var e=this;if(!this.disposed){null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");var n=this.gl;callAndCheck(n,function(){return n.finish()}),callAndCheck(n,function(){return n.bindFramebuffer(n.FRAMEBUFFER,null)}),callAndCheck(n,function(){return n.deleteFramebuffer(e.framebuffer)}),callAndCheck(n,function(){return n.bindBuffer(n.ARRAY_BUFFER,null)}),callAndCheck(n,function(){return n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,null)}),callAndCheck(n,function(){return n.deleteBuffer(e.indexBuffer)}),this.disposed=!0}},GPGPUContext.prototype.createFloat32MatrixTexture=function(e,n){return this.throwIfDisposed(),createFloat32MatrixTexture(this.gl,e,n,this.textureConfig)},GPGPUContext.prototype.createFloat16MatrixTexture=function(e,n){return this.throwIfDisposed(),createFloat16MatrixTexture(this.gl,e,n,this.textureConfig)},GPGPUContext.prototype.createUnsignedBytesMatrixTexture=function(e,n){return this.throwIfDisposed(),createUnsignedBytesMatrixTexture(this.gl,e,n,this.textureConfig)},GPGPUContext.prototype.uploadPixelDataToTexture=function(e,n){this.throwIfDisposed(),uploadPixelDataToTexture(this.gl,e,n)},GPGPUContext.prototype.uploadDenseMatrixToTexture=function(e,n,t,a){this.throwIfDisposed(),uploadDenseMatrixToTexture(this.gl,e,n,t,a,this.textureConfig)},GPGPUContext.prototype.createFloat16PackedMatrixTexture=function(e,n){return this.throwIfDisposed(),createFloat16PackedMatrixTexture(this.gl,e,n,this.textureConfig)},GPGPUContext.prototype.createPackedMatrixTexture=function(e,n){return this.throwIfDisposed(),createPackedMatrixTexture(this.gl,e,n,this.textureConfig)},GPGPUContext.prototype.deleteMatrixTexture=function(e){var n=this;this.throwIfDisposed(),this.outputTexture===e&&(unbindColorTextureFromFramebuffer(this.gl,this.framebuffer),this.outputTexture=null),callAndCheck(this.gl,function(){return n.gl.deleteTexture(e)})},GPGPUContext.prototype.downloadByteEncodedFloatMatrixFromOutputTexture=function(e,n,t){var a=this;return this.downloadMatrixDriver(e,function(){return downloadByteEncodedFloatMatrixFromOutputTexture(a.gl,n,t,a.textureConfig)})},GPGPUContext.prototype.downloadPackedMatrixFromBuffer=function(e,n,t,a,r,o){return downloadPackedMatrixFromBuffer(this.gl,e,n,t,a,r,o,this.textureConfig)},GPGPUContext.prototype.downloadFloat32MatrixFromBuffer=function(e,n){return downloadFloat32MatrixFromBuffer(this.gl,e,n)},GPGPUContext.prototype.createBufferFromTexture=function(e,n,t){this.bindTextureToFrameBuffer(e);var a=createBufferFromOutputTexture(this.gl,n,t,this.textureConfig);return this.unbindTextureToFrameBuffer(),a},GPGPUContext.prototype.createAndWaitForFence=function(){var e=this.createFence(this.gl);return this.pollFence(e)},GPGPUContext.prototype.createFence=function(e){var n,t,a=this;if(p.env().getBool("WEBGL_FENCE_API_ENABLED")){var r=e.fenceSync(e.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),t=function(){var n=e.clientWaitSync(r,0,0);return n===e.ALREADY_SIGNALED||n===e.CONDITION_SATISFIED},n=r}else p.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(n=this.beginQuery(),this.endQuery(),t=function(){return a.isQueryAvailable(n,p.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}):t=function(){return!0};return{query:n,isFencePassed:t}},GPGPUContext.prototype.downloadMatrixFromPackedTexture=function(e,n,t){var a=this;return this.downloadMatrixDriver(e,function(){return downloadMatrixFromPackedOutputTexture(a.gl,n,t)})},GPGPUContext.prototype.createProgram=function(e){var n=this;this.throwIfDisposed();var t=this.gl;null==this.vertexShader&&(this.vertexShader=createVertexShader(t));var a=createProgram(t);callAndCheck(t,function(){return t.attachShader(a,n.vertexShader)}),callAndCheck(t,function(){return t.attachShader(a,e)}),linkProgram(t,a);var r=Object.assign(a,{vao:this.createVertexArray()});return this.debug&&validateProgram(t,r),r},GPGPUContext.prototype.buildVao=function(e){var n=this;this.setProgram(e),this.bindVertexArray(e.vao);var t=this.gl;callAndCheck(t,function(){return t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,n.indexBuffer)}),bindVertexProgramAttributeStreams(t,e,this.vertexBuffer)},GPGPUContext.prototype.deleteProgram=function(e){var n=this;this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&(callAndCheck(this.gl,function(){return n.gl.deleteProgram(e)}),this.deleteVertexArray(e.vao))},GPGPUContext.prototype.setProgram=function(e){var n=this;this.throwIfDisposed(),this.program=e,null!=this.program&&this.debug&&validateProgram(this.gl,this.program),callAndCheck(this.gl,function(){return n.gl.useProgram(e)})},GPGPUContext.prototype.getUniformLocation=function(e,n,t){return(void 0===t&&(t=!0),this.throwIfDisposed(),t)?getProgramUniformLocationOrThrow(this.gl,e,n):getProgramUniformLocation(this.gl,e,n)},GPGPUContext.prototype.getAttributeLocation=function(e,n){var t=this;return this.throwIfDisposed(),callAndCheck(this.gl,function(){return t.gl.getAttribLocation(e,n)})},GPGPUContext.prototype.getUniformLocationNoThrow=function(e,n){return this.throwIfDisposed(),this.gl.getUniformLocation(e,n)},GPGPUContext.prototype.setInputMatrixTexture=function(e,n,t){this.throwIfDisposed(),this.throwIfNoProgram(),bindTextureToProgramUniformSampler(this.gl,e,n,t)},GPGPUContext.prototype.setOutputMatrixTexture=function(e,n,t){this.setOutputMatrixTextureDriver(e,t,n)},GPGPUContext.prototype.setOutputPackedMatrixTexture=function(e,n,t){this.throwIfDisposed();var a=__read(getPackedMatrixTextureShapeWidthHeight(n,t),2),r=a[0],o=a[1];this.setOutputMatrixTextureDriver(e,r,o)},GPGPUContext.prototype.setOutputMatrixWriteRegion=function(e,n,t,a){this.setOutputMatrixWriteRegionDriver(t,e,a,n)},GPGPUContext.prototype.setOutputPackedMatrixWriteRegion=function(e,n,t,a){throw Error("setOutputPackedMatrixWriteRegion not implemented.")},GPGPUContext.prototype.debugValidate=function(){null!=this.program&&validateProgram(this.gl,this.program),validateFramebuffer(this.gl)},GPGPUContext.prototype.executeProgram=function(){this.throwIfDisposed(),this.throwIfNoProgram();var e=this.gl;this.debug&&(console.assert(this.getVertexArray()===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()),callAndCheck(e,function(){return e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0)})},GPGPUContext.prototype.blockUntilAllProgramsCompleted=function(){var e=this;this.throwIfDisposed(),callAndCheck(this.gl,function(){return e.gl.finish()})},GPGPUContext.prototype.getQueryTimerExtension=function(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=getExtensionOrThrow(this.gl,2===p.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension},GPGPUContext.prototype.getQueryTimerExtensionWebGL2=function(){return this.getQueryTimerExtension()},GPGPUContext.prototype.getQueryTimerExtensionWebGL1=function(){return this.getQueryTimerExtension()},GPGPUContext.prototype.beginQuery=function(){if(2===p.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){var e=this.gl,n=this.getQueryTimerExtensionWebGL2(),t=e.createQuery();return e.beginQuery(n.TIME_ELAPSED_EXT,t),t}var a=this.getQueryTimerExtensionWebGL1(),r=a.createQueryEXT();return a.beginQueryEXT(a.TIME_ELAPSED_EXT,r),r},GPGPUContext.prototype.endQuery=function(){if(2===p.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){var e=this.gl,n=this.getQueryTimerExtensionWebGL2();e.endQuery(n.TIME_ELAPSED_EXT);return}var t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)},GPGPUContext.prototype.waitForQueryAndGetTime=function(e){return __awaiter(this,void 0,void 0,function(){var n=this;return __generator(this,function(t){switch(t.label){case 0:return[4,p.util.repeatedTry(function(){return n.disposed||n.isQueryAvailable(e,p.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))})];case 1:return t.sent(),[2,this.getQueryTime(e,p.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))]}})})},GPGPUContext.prototype.getQueryTime=function(e,n){if(0===n)return null;if(2===n){var t=this.gl,a=t.getQueryParameter(e,t.QUERY_RESULT);return a/1e6}var r=this.getQueryTimerExtensionWebGL1(),a=r.getQueryObjectEXT(e,r.QUERY_RESULT_EXT);return a/1e6},GPGPUContext.prototype.isQueryAvailable=function(e,n){if(0===n)return!0;if(2===n){var t=this.gl,a=this.getQueryTimerExtensionWebGL2(),r=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(a.GPU_DISJOINT_EXT)),r&&!this.disjoint}var a=this.getQueryTimerExtensionWebGL1(),r=a.getQueryObjectEXT(e,a.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(a.GPU_DISJOINT_EXT)),r&&!this.disjoint},GPGPUContext.prototype.pollFence=function(e){var n=this;return new Promise(function(t){n.addItemToPoll(function(){return e.isFencePassed()},function(){return t()})})},GPGPUContext.prototype.pollItems=function(){for(var e=function(e){for(var n=0;n<e.length&&e[n]();++n);return n-1}(this.itemsToPoll.map(function(e){return e.isDoneFn})),n=0;n<=e;++n)(0,this.itemsToPoll[n].resolveFn)();this.itemsToPoll=this.itemsToPoll.slice(e+1)},GPGPUContext.prototype.addItemToPoll=function(e,n){var t=this;if(this.itemsToPoll.push({isDoneFn:e,resolveFn:n}),!(this.itemsToPoll.length>1)){var a=void 0;"setTimeoutCustom"in p.env().platform&&(a=p.env().platform.setTimeoutCustom.bind(p.env().platform)),p.util.repeatedTry(function(){return t.pollItems(),0===t.itemsToPoll.length},function(){return 0},null,a)}},GPGPUContext.prototype.bindTextureToFrameBuffer=function(e){this.throwIfDisposed(),bindColorTextureToFramebuffer(this.gl,e,this.framebuffer),this.debug&&validateFramebuffer(this.gl)},GPGPUContext.prototype.unbindTextureToFrameBuffer=function(){null!=this.outputTexture?(bindColorTextureToFramebuffer(this.gl,this.outputTexture,this.framebuffer),this.debug&&validateFramebuffer(this.gl)):unbindColorTextureFromFramebuffer(this.gl,this.framebuffer)},GPGPUContext.prototype.downloadMatrixDriver=function(e,n){this.bindTextureToFrameBuffer(e);var t=n();return this.unbindTextureToFrameBuffer(),t},GPGPUContext.prototype.setOutputMatrixTextureDriver=function(e,n,t){this.throwIfDisposed();var a=this.gl;bindColorTextureToFramebuffer(a,e,this.framebuffer),this.debug&&validateFramebuffer(a),this.outputTexture=e,callAndCheck(a,function(){return a.viewport(0,0,n,t)}),callAndCheck(a,function(){return a.scissor(0,0,n,t)})},GPGPUContext.prototype.setOutputMatrixWriteRegionDriver=function(e,n,t,a){var r=this;this.throwIfDisposed(),callAndCheck(this.gl,function(){return r.gl.scissor(e,n,t,a)})},GPGPUContext.prototype.throwIfDisposed=function(){if(this.disposed)throw Error("Attempted to use disposed GPGPUContext.")},GPGPUContext.prototype.throwIfNoProgram=function(){if(null==this.program)throw Error("No GPU program is currently set.")},GPGPUContext}();/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function createSimpleBinaryKernelImpl(e){return function(n,t,a,r,o){var i=p.backend_util.assertAndGetBroadcastShape(n,t),c=i.length,s=p.util.computeStrides(i),u=p.util.sizeFromShape(i),l=p.util.getTypedArrayFromDType(o,u),d=n.length,h=t.length,f=p.util.computeStrides(n),x=p.util.computeStrides(t),m=p.backend_util.getBroadcastDims(n,i),g=p.backend_util.getBroadcastDims(t,i);if(m.length+g.length===0)for(var v=0;v<l.length;++v)l[v]=e(a[v%a.length],r[v%r.length]);else for(var v=0;v<l.length;++v)!function(n){var t=p.util.indexToLoc(n,c,s),o=t.slice(-d);m.forEach(function(e){return o[e]=0});var i=p.util.locToIndex(o,d,f),u=t.slice(-h);g.forEach(function(e){return u[e]=0});var v=p.util.locToIndex(u,h,x);l[n]=e(a[i],r[v])}(v);return[l,i]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var k=createSimpleBinaryKernelImpl(function(e,n){return e+n}),I=createSimpleBinaryKernelImpl(function(e,n){return e&n});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function createSimpleUnaryImpl(e){return function(n,t,a){for(var r=p.util.getArrayFromDType(t,n.length),o=0;o<n.length;++o)r[o]=e(n[o],a);return r}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var T=createSimpleUnaryImpl(function(e){return Math.ceil(e)}),S=createSimpleBinaryKernelImpl(function(e,n){return e===n?1:0}),R=createSimpleUnaryImpl(function(e){return Math.exp(e)}),w=createSimpleUnaryImpl(function(e){return Math.expm1(e)}),P=createSimpleUnaryImpl(function(e){return Math.floor(e)}),_=createSimpleBinaryKernelImpl(function(e,n){return e>n?1:0}),E=createSimpleBinaryKernelImpl(function(e,n){return e>=n?1:0}),F=createSimpleBinaryKernelImpl(function(e,n){return e<n?1:0}),N=createSimpleBinaryKernelImpl(function(e,n){return e<=n?1:0}),A=createSimpleUnaryImpl(function(e){return Math.log(e)}),O=createSimpleBinaryKernelImpl(function(e,n){return Math.max(e,n)}),D=createSimpleBinaryKernelImpl(function(e,n){return Math.min(e,n)}),L=createSimpleBinaryKernelImpl(function(e,n){return e*n}),B=createSimpleBinaryKernelImpl(function(e,n){return e!==n?1:0});function computeFlatOuterDims(e,n){for(var t=e.slice(0,n);t.length<n;)t.push(1);for(var a=n;a<e.length;a++)t[n-1]*=e[a];return t}var U=p.backend_util.RowPartitionType,G=function(){function RaggedTensorToTensorOp(e,n,t,a,r,o,i,c,s,u){this.shape=e,this.shapeShape=n,this.values=t,this.valuesShape=a,this.valuesDType=r,this.defaultValue=o,this.defaultValueShape=i,this.rowPartitionValues=c,this.rowPartitionValuesShapes=s,this.rowPartitionTypes=p.backend_util.getRowPartitionTypesHelper(u),this.raggedRank=p.backend_util.getRaggedRank(this.rowPartitionTypes)}return RaggedTensorToTensorOp.prototype.getRowPartitionTypeByDimension=function(e){return this.rowPartitionTypes[0]===U.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]},RaggedTensorToTensorOp.prototype.getRowPartitionTensor=function(e){return this.rowPartitionTypes[0]===U.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]},RaggedTensorToTensorOp.prototype.getMaxWidth=function(e){var n=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case U.VALUE_ROWIDS:return RaggedTensorToTensorOp.getMaxWidthValueRowID(n);case U.ROW_SPLITS:return RaggedTensorToTensorOp.getMaxWidthRowSplit(n);default:throw Error("Cannot handle partition type ".concat(U[this.getRowPartitionTypeByDimension(e-1)]))}},RaggedTensorToTensorOp.getMaxWidthRowSplit=function(e){var n=e.length;if(0===n||1===n)return 0;for(var t=0,a=0;a<n-1;++a){var r=e[a+1]-e[a];r>t&&(t=r)}return t},RaggedTensorToTensorOp.getMaxWidthValueRowID=function(e){var n=e.length;if(0===n)return 0;for(var t=0,a=e[0],r=0,o=1;o<n;++o){var i=e[o];i!==a&&(a=i,r=Math.max(o-t,r),t=o)}return Math.max(n-t,r)},RaggedTensorToTensorOp.prototype.tensorShapeFromTensor=function(e,n,t){if(void 0===t&&(t=!0),0===n.length){if(-1===e[0])return[];throw Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return makeShape(e,t)},RaggedTensorToTensorOp.prototype.calculateOutputSize=function(e){var n=this.valuesShape,t=this.defaultValueShape;p.backend_util.validateDefaultValueShape(t,n);var a=this.tensorShapeFromTensor(this.shape,this.shapeShape),r=p.backend_util.combineRaggedTensorToTensorShapes(this.raggedRank,a,n);r[0]<0&&(r[0]=e);for(var o=1;o<=this.raggedRank;++o)r[o]<0&&(r[o]=this.getMaxWidth(o));return r},RaggedTensorToTensorOp.prototype.calculateFirstParentOutputIndex=function(e,n,t){for(var a=Math.min(e,t),r=[],o=0,i=0;i<a;++i,o+=n)r.push(o);for(var i=a;i<e;++i)r.push(-1);return p.util.assert(r.length===e,function(){return"Final length of result must be equal to firstDimension."}),r},RaggedTensorToTensorOp.prototype.calculateOutputIndexRowSplit=function(e,n,t,a){for(var r=e.length,o=[],i=0;i<r-1;++i){var c=e[i+1]-e[i],s=Math.min(a,c),u=n[i];-1===u&&(s=0);for(var l=0;l<s;++l)o.push(u),u+=t;for(var l=0;l<c-s;++l)o.push(-1)}if(r>0&&o.length!==e[r-1])throw Error("Invalid row split size.");return o},RaggedTensorToTensorOp.prototype.calculateOutputIndexValueRowID=function(e,n,t,a){var r=e.length,o=[];if(0===r)return[];var i=0,c=e[0];if(c>=n.length)throw Error("Got currentValueRowId=".concat(c,", which is not less than ").concat(n.length));var s=n[c];o.push(s);for(var u=1;u<r;++u){var l=e[u];if(l===c)s>=0&&(++i<a?s+=t:s=-1);else{if(i=0,c=l,l>=n.length)throw Error("Got nextValueRowId=".concat(l," which is not less than ").concat(n.length));s=n[l]}o.push(s)}if(o.length!==e.length)throw Error("Invalid row ids.");return o},RaggedTensorToTensorOp.prototype.calculateOutputIndex=function(e,n,t,a){var r=this.getRowPartitionTensor(e),o=this.getRowPartitionTypeByDimension(e);switch(o){case U.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(r,n,t,a);case U.ROW_SPLITS:if(r.length-1>n.length)throw Error("Row partition size is greater than output size: ".concat(r.length-1," > ").concat(n.length));return this.calculateOutputIndexRowSplit(r,n,t,a);default:throw Error("Unsupported partition type: ".concat(U[o]))}},RaggedTensorToTensorOp.prototype.getFirstDimensionSize=function(){var e=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw Error("No row_partition_types given.");var n=this.rowPartitionTypes[0];switch(n){case U.FIRST_DIM_SIZE:return e[0];case U.VALUE_ROWIDS:throw Error("Cannot handle VALUE_ROWIDS in first dimension.");case U.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw Error("Cannot handle type ".concat(U[n]))}},RaggedTensorToTensorOp.prototype.compute=function(){if(this.rowPartitionValues[0].length<=0)throw Error("Invalid first partition input. Tensor requires at least one element.");var e=this.getFirstDimensionSize(),n=this.calculateOutputSize(e),t=Array(this.raggedRank+1);t[t.length-1]=1;for(var a=t.length-2;a>=0;--a)t[a]=t[a+1]*n[a+1];var r=makeShape(n,!1),o=p.util.getArrayFromDType(this.valuesDType,p.util.sizeFromShape(r));if(t[0]*n[0]>0){for(var i=this.calculateFirstParentOutputIndex(e,t[0],n[0]),a=1;a<=this.raggedRank;++a)i=this.calculateOutputIndex(a-1,i,t[a],n[a]);this.setOutput(this.raggedRank,i,o,r)}return[r,o]},RaggedTensorToTensorOp.prototype.setOutput=function(e,n,t,a){if(0!==t.length){var r=this.values,o=a.slice();o=o.slice(e+1);var i=p.util.sizeFromShape(o),c=n.length,s=this.defaultValue;if(s.length!==i&&1!==s.length){var u=this.defaultValueShape;p.tidy(function(){var e=p.reshape(s,u);s=p.broadcastTo(e,o).dataSync()})}for(var l=0,d=0,h=0,f=0;f<=c;++f){var x=f<c?n[f]:-1;if(x===h){++h;continue}if(d<h){var m=r.subarray(l*i),g=t.subarray(d*i);copyArray(g,m,(h-d)*i)}if(f>=c&&(x=Math.floor(t.length/i)),x>h){if(1===this.defaultValue.length)t.subarray(h*i,x*i).fill(this.defaultValue[0]),h=x;else for(;x>h;){var g=t.slice(h*i);copyArray(g,s,i),++h}}x<0?(l=f+1,d=h):(l=f,h=(d=h)+1)}}},RaggedTensorToTensorOp}();function copyArray(e,n,t){for(var a=0;a<t;a++)e[a]=n[a]}function makeShape(e,n){var t,a,r=[];try{for(var o=__values(e),i=o.next();!i.done;i=o.next()){var c=i.value;if(c<0){if(!n)throw Error("Dimension ".concat(c," must be >= 0"));if(c<-1)throw Error("Dimension ".concat(c," must be >= -1"));c=-1}r.push(c)}}catch(e){t={error:e}}finally{try{i&&!i.done&&(a=o.return)&&a.call(o)}finally{if(t)throw t.error}}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var M=createSimpleUnaryImpl(function(e){return 1/Math.sqrt(e)}),W=createSimpleUnaryImpl(function(e){return 1/(1+Math.exp(-e))}),V=createSimpleUnaryImpl(function(e){return Math.sqrt(e)}),z=createSimpleUnaryImpl(function(e,n){var t=n.pattern,a=n.replaceGlobal,r=n.rewrite;return e.replace(new RegExp(t,a?"g":""),r)}),X=function(){function StringNGramsOp(e,n,t,a,r,o){this.separator=p.util.encodeString(e),this.nGramWidths=n,this.leftPad=p.util.encodeString(t),this.rightPad=p.util.encodeString(a),this.padWidth=r,this.preserveShort=o}return StringNGramsOp.prototype.getPadWidth=function(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)},StringNGramsOp.prototype.getNumNGrams=function(e,n){return Math.max(0,e+2*this.getPadWidth(n)-n+1)},StringNGramsOp.prototype.createNGrams=function(e,n,t,a,r,o){for(var i=this,c=0;c<r;++c)!function(c){var s,u=i.getPadWidth(o),l=Math.max(0,u-c),d=Math.max(0,u-(r-(c+1))),p=o-(l+d),h=n+(l>0?0:c-u);s=0+l*i.leftPad.length;for(var f=0;f<p;++f)s+=e[h+f].length;s+=d*i.rightPad.length+(l+d+p-1)*i.separator.length,t[a+c]=new Uint8Array(s);for(var x=t[a+c],m=0,appendToNGram=function(e){return e.forEach(function(e){return x[m++]=e})},f=0;f<l;++f)appendToNGram(i.leftPad),appendToNGram(i.separator);for(var f=0;f<p-1;++f)appendToNGram(e[h+f]),appendToNGram(i.separator);if(p>0){appendToNGram(e[h+p-1]);for(var f=0;f<d;++f)appendToNGram(i.separator),appendToNGram(i.rightPad)}else{for(var f=0;f<d-1;++f)appendToNGram(i.rightPad),appendToNGram(i.separator);appendToNGram(i.rightPad)}}(c)},StringNGramsOp.prototype.compute=function(e,n){var t=this,a=e.length,r=n.length;if(r>0){var o=n[0];if(0!==o)throw Error("First split value must be 0, got ".concat(o));for(var i=1;i<r;++i){var c=n[i]>=o;if(!(c=c&&n[i]<=a))throw Error("Invalid split value ".concat(n[i],", must be in [").concat(o,", ").concat(a,"]"));o=n[i]}if(o!==a)throw Error("Last split value must be data size. Expected ".concat(a,", got ").concat(o))}var s=r-1,u=p.util.getArrayFromDType("int32",r);if(0===a||0===r){for(var l=Array(a),i=0;i<=s;++i)u[i]=0;return[l,u]}u[0]=0;for(var d=this,i=1;i<=s;++i)!function(e){var a=n[e]-n[e-1],r=0;d.nGramWidths.forEach(function(e){r+=t.getNumNGrams(a,e)}),d.preserveShort&&a>0&&0===r&&(r=1),u[e]=u[e-1]+r}(i);for(var h=Array(u[s]),_loop_3=function(a){var r=n[a],o=u[a];if(f.nGramWidths.forEach(function(i){var c=n[a+1]-n[a],s=t.getNumNGrams(c,i);t.createNGrams(e,r,h,o,s,i),o+=s}),f.preserveShort&&o===u[a]){var i=n[a+1]-n[a];if(0===i)return"continue";var c=i+2*f.padWidth;f.createNGrams(e,r,h,o,1,c)}},f=this,i=0;i<s;++i)_loop_3(i);return[h,u]},StringNGramsOp}(),H=createSimpleBinaryKernelImpl(function(e,n){return e-n}),comparePair=function(e,n){var t=n.value-e.value;return 0===t?e.index-n.index:t},bincountImplCPU=/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e,n,t,a,r){for(var o=p.util.sizeFromShape(a),i=p.util.makeZerosTypedArray(r,t),c=0;c<e.length;c++){var s=e[c];if(s<0)throw Error("Input x must be non-negative!");s>=r||(o>0?i[s]+=n[c]:i[s]+=1)}return i},bincountReduceImplCPU=function(e,n,t,a){void 0===a&&(a=!1);for(var r=e.shape[0],o=e.shape[1],i=p.buffer([r,t],n.dtype),c=0;c<r;c++)for(var s=0;s<o;s++){var u=e.get(c,s);if(u<0)throw Error("Input x must be non-negative!");u>=t||(a?i.set(1,c,u):n.size>0?i.set(i.get(c,u)+n.get(c,s),c,u):i.set(i.get(c,u)+1,c,u))}return i},castImplCPU=function(e,n,t,a){if("int32"===a)return[n,"int32",Int32Array.from(e)];if("bool"===a){var r=p.util.toTypedArray([0],t),o=__read(createSimpleBinaryKernelImpl(function(e,n){return e!==n?1:0})(n,[],e,r,"bool"),2),i=o[0];return[o[1],"bool",i]}throw Error("Error in Cast: failed to cast ".concat(t," to ").concat(a))},concatImplCPU=/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e,n,t,a){var r=p.util.getArrayFromDType(t,p.util.sizeFromShape(n));if(a&&"string"!==t){var o=0;e.forEach(function(e){var n=p.util.sizeFromShape(e.shape);r.set(e.vals,o),o+=n})}else{var i=0;e.forEach(function(e){for(var a="string"===t?p.backend_util.fromUint8ToStringArray(e.vals):e.vals,o=0,c=0;c<e.shape[0];++c)for(var s=c*n[1]+i,u=0;u<e.shape[1];++u)r[s+u]=a[o++];i+=e.shape[1]})}return r},gatherNdImplCPU=function(e,n,t,a,r,o,i,c,s){for(var u=p.buffer([a,o],t),l=0;l<a;l++){for(var d=[],h=0,f=0;f<r;f++){var x=e[l*r+f];h+=x*i[f],d.push(x)}if(h<0||h>=s/o)throw Error("Invalid indices: ".concat(d," does not index into ").concat(c));for(var m=0;m<o;m++)u.values[l*o+m]=n.get.apply(n,__spreadArray([],__read(n.indexToLoc(h*o+m)),!1))}return u},gatherV2ImplCPU=/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e,n,t){for(var a=p.buffer(t,e.dtype),r=0;r<a.size;++r){var o=a.indexToLoc(r).slice(),i=o[0],c=o[2],s=n.locToIndex([i,c]);o[2]=n.values[s];var u=e.locToIndex(o);0<=u&&u<e.values.length&&(a.values[r]=e.values[u])}return a},linSpaceImplCPU=/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e,n,t){var a=(n-e)/(t-1),r=p.util.makeZerosTypedArray(t,"float32");r[0]=e;for(var o=1;o<r.length;o++)r[o]=r[o-1]+a;return r},maxImplCPU=/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e,n,t,a){for(var r=p.util.getTypedArrayFromDType(a,p.util.sizeFromShape(t)),o=0;o<r.length;++o){for(var i=o*n,c=e[i],s=0;s<n;++s){var u=e[i+s];(Number.isNaN(u)||u>c)&&(c=u)}r[o]=c}return r},prodImplCPU=function(e,n,t,a){for(var r=__read(p.backend_util.computeOutAndReduceShapes(e,a),2),o=r[0],i=r[1],c=p.upcastType(n,"int32"),s=p.util.makeZerosTypedArray(p.util.sizeFromShape(o),c),u=p.util.sizeFromShape(i),l=0;l<s.length;++l){for(var d=l*u,h=1,f=0;f<u;++f)h*=t[d+f];s[l]=h}return{outVals:s,outShape:o,outDtype:c}},raggedGatherImplCPU=function(e,n,t,a,r,o,i,c){if(0===e.length)throw Error("paramsNestedSplits must be non empty");if(0===n[0].length)throw Error("Split tensors must not be scalars");if(function(e,n,t){e.forEach(function(e,a){if(e<0||e>=t){var r=p.util.indexToLoc(a,n.length,p.util.computeStrides(n)).join(",");throw Error("indices[".concat(r,"] = ").concat(e," is not in [0, ").concat(t,")"))}})}(o,i,n[0][0]-1),0===a.length)throw Error("params.rank must be nonzero");var s,u,l,d,h=function(e,n,t,a){var r=[],o=0,i=Array(n.length-1+t.length).fill(null).map(function(){return[0]});!function(e,n){for(var t=0;t<e.length;++t){var a=e[t],r=t===e.length-1?n:e[t+1].length;if(0===a.length)throw Error("Ragged splits may not be empty");if(a[0]<0)throw Error("Ragged splits must be non-negative");if(a[a.length-1]>r)throw Error("Ragged splits must not point past values");for(var o=1;o<a.length;++o)if(a[o-1]>a[o])throw Error("Ragged splits must be sorted in ascending order")}}(t,a);for(var c=1,s=0;s<n.length-1;++s){c*=n[s];for(var u=n[s+1],l=1;l<c+1;++l)i[s].push(l*u)}for(var l=0;l<e.length;++l){for(var d=e[l],p=e[l]+1,s=0;s<t.length;++s){var h=t[s],f=s+n.length-1;if(f>=0)for(var x=i[f],m=x[x.length-1]-h[d],g=d;g<p;++g)i[f].push(h[g+1]+m);d=h[d],p=h[p]}p!==d&&(r.push([d,p]),o+=p-d)}return{outSplits:i,valueSlices:r,numValues:o}}(o,i,e,a[0]),f=h.outSplits,x=h.valueSlices,m=h.numValues,g=function(e){for(var n=[],t=0;t<e.length;++t)!function(t){var a=e[t].length,r=p.util.getArrayFromDType("int32",a);n.push(r),e[t].forEach(function(e,n){return r[n]=e})}(t);return n}(f),v=((s=a.slice())[0]=m,u=p.util.getArrayFromDType(r,p.util.sizeFromShape(s)),d=0===(l=t.length)?0:l/a[0],function(e,n,t,a,r,o){var i,c,s=computeFlatOuterDims(n,2)[1],u=computeFlatOuterDims(o,2)[1],l=0;try{for(var d=__values(t),p=d.next();!p.done;p=d.next())for(var h=p.value,f=h[0];f<h[1];++f){for(var x=0;x<a;++x)r[l*u+x]=e[f*s+x];++l}}catch(e){i={error:e}}finally{try{p&&!p.done&&(c=d.return)&&c.call(d)}finally{if(i)throw i.error}}}(t,a,x,d,u,s),[u,s]);return[g,v[0],v[1]]},raggedRangeImplCPU=function(e,n,t,a,r,o,i){if(n.length>1)throw Error("starts must be a scalar or vector");if(r.length>1)throw Error("limits must be a scalar or vector");if(i.length>1)throw Error("deltas must be a scalar or vector");var c=0===n.length,s=0===r.length,u=0===i.length,l=[];c||l.push(n[0]),s||l.push(r[0]),u||l.push(i[0]);for(var d=1;d<l.length;++d)if(l[d]!==l[d-1])throw Error("starts, limits, and deltas must have the same shape");var h=0===l.length?1:l[0],f=p.util.getArrayFromDType("int32",h+1);f[0]=0;for(var x=0;x<h;++x){var m=c?e[0]:e[x],g=s?a[0]:a[x],v=u?o[0]:o[x];if(0===v)throw Error("Requires delta != 0");var b=void 0;if(v>0&&g<m||v<0&&g>m)b=0;else if((b=Math.ceil(Math.abs((g-m)/v)))>2147483647)throw Error("Requires ((limit - start) / delta) <= ".concat(2147483647));f[x+1]=f[x]+b}for(var C=f[h],y=p.util.getArrayFromDType(t,C),k=0,x=0;x<h;++x)for(var I=f[x+1]-f[x],T=c?e[0]:e[x],v=u?o[0]:o[x],d=0;d<I;++d)y[k++]=T,T+=v;return[f,y]},rangeImplCPU=/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e,n,t,a){var r=e<n&&t<0,o=n<e&&t>1;if(e===n||r||o)return p.util.makeZerosTypedArray(0,a);var i=Math.abs(Math.ceil((n-e)/t)),c=p.util.makeZerosTypedArray(i,a);n<e&&1===t&&(t=-1),c[0]=e;for(var s=1;s<c.length;s++)c[s]=c[s-1]+t;return c},scatterImplCPU=/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e,n,t,a,r,o,i,c,s,u){var l=[a/r,r],d=e.values,h=n.values;if(0===a)return p.buffer(t,n.dtype);var f=s instanceof p.TensorBuffer?s:p.buffer(l,n.dtype);"string"==typeof s?f.values.fill(s):"number"==typeof s?f.values.fill(s):"boolean"==typeof s&&f.values.fill(+s);for(var x=0;x<o;x++){for(var m=[],g=0,v=0;v<i;v++){var b=d[x*i+v];m.push(b),g+=b*c[v]}if(g<0||g>=a/r)throw Error("Invalid indices: ".concat(m," does not index into ").concat(t));for(var C=0;C<r;C++)u?f.values[g*r+C]+=h[x*r+C]:f.values[g*r+C]=0===n.rank?h[0]:h[x*r+C]}return f},simpleAbsImplCPU=/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){for(var n=new Float32Array(e.length),t=0;t<e.length;++t)n[t]=Math.abs(e[t]);return n},sliceImplCPU=function(e,n,t,a,r){var o=p.slice_util.isSliceContinous(a,n,t),i=p.util.sizeFromShape(t),c=p.util.computeStrides(a);if(o){var s=p.slice_util.computeFlatOffset(n,c);return"string"===r?e.slice(s,s+i):e.subarray(s,s+i)}for(var u="string"===r?p.backend_util.fromUint8ToStringArray(e):e,l=p.buffer(a,r,u),d=p.buffer(t,r),h=0;h<d.size;++h){var f=d.indexToLoc(h),x=f.map(function(e,t){return e+n[t]});d.set.apply(d,__spreadArray([l.get.apply(l,__spreadArray([],__read(x),!1))],__read(f),!1))}return"string"===r?p.backend_util.fromStringArrayToUint8(d.values):d.values},sparseFillEmptyRowsImplCPU=/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e,n,t,a,r,o,i){var c=n[0],s=o[0],u=Array(s),l=Array(c),d=n[1];if(0===s){if(0!==c)throw Error(p.backend_util.getSparseFillEmptyRowsIndicesDenseShapeMismatch(c));var h=p.util.getArrayFromDType(t,0),f=p.util.getArrayFromDType(r,0);return[h,[0,d],f,u,l]}for(var x=!0,m=0,g=Array(s).fill(0),v=0;v<c;++v){var b=e[v*d];if(b<0)throw Error(p.backend_util.getSparseFillEmptyRowsNegativeIndexErrorMessage(v,b));if(b>=s)throw Error(p.backend_util.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(v,b,s));++g[b],x=x&&b>=m,m=b}for(var C=!0,b=0;b<s;++b){var y=0===g[b];u[b]=y,C=C&&!y,g[b]=Math.max(g[b],1),b>0&&(g[b]+=g[b-1])}if(C&&x){for(var h=e,f=a,v=0;v<c;++v)l[v]=v;return[h,[c,d],f,u,l]}for(var k=g[s-1],h=p.util.getArrayFromDType(t,k*d),f=p.util.getArrayFromDType(r,k),I=Array(s).fill(0),v=0;v<c;++v){var b=e[v*d],T=I[b],S=(0===b?0:g[b-1])+T;I[b]++;for(var R=0;R<d;++R)h[S*d+R]=e[v*d+R];f[S]=a[v],l[v]=S}for(var b=0;b<s;++b)if(0===I[b]){var w=0===b?0:g[b-1];h[w*d+0]=b;for(var P=1;P<d;++P)h[w*d+P]=0;f[w]=i}return[h,[k,d],f,u,l]},sparseReshapeImplCPU=/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e,n,t,a,r){for(var o=p.util.sizeFromShape(a),i=n[0],c=r.length,s=[],u=1,l=-1,d=0;d<c;++d){var h=r[d];if(-1===h){if(-1!==l)throw Error(p.backend_util.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(l,d));l=d,s.push(1)}else{if(h<0)throw Error(p.backend_util.getSparseReshapeNegativeOutputDimErrorMessage(d,h));u*=h,s.push(h)}}if(-1!==l){if(u<=0)throw Error(p.backend_util.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());var f=Math.trunc(o/u);if(u*f!==o)throw Error(p.backend_util.getSparseReshapeInputOutputMultipleErrorMessage(a,s));s[l]=f}if(p.util.sizeFromShape(s)!==o)throw Error(p.backend_util.getSparseReshapeInputOutputMismatchErrorMessage(a,s));var x=a.length,m=[];if(x>0){m[x-1]=1;for(var d=x-2;d>=0;--d)m[d]=m[d+1]*a[d+1]}var g=[];if(c>0){g[c-1]=1;for(var d=c-2;d>=0;--d)g[d]=g[d+1]*s[d+1]}for(var v=p.util.getArrayFromDType(t,i*c),b=0;b<i;++b){for(var C=0,y=0;y<x;++y)C+=e[b*x+y]*m[y];for(var y=0;y<c;++y)v[b*c+y]=Math.trunc(C/g[y]),C%=g[y]}return[v,[i,c],s]},sparseSegmentReductionImplCPU=/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e,n,t,a,r,o,i){void 0===o&&(o=!1),void 0===i&&(i=0);var c=a.length,s=[n[0],e.length/n[0]],u=s[1],l=c>0?r[c-1]+1:0;if(l<0)throw Error(p.backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());var d=n.slice();d[0]=l;var h=d.reduce(function(e,n){return e*n},1),f=p.util.getArrayFromDType(t,h);if(0===c)return l>0&&f.fill(i),[f,d];if(l<=0)throw Error(p.backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());for(var x=0,m=1,g=0,v=r[0];;){var b=0;if(m<c){if(v===(b=r[m])){++m;continue}if(v>=b)throw Error(p.backend_util.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(v<0||v>=l)throw Error(p.backend_util.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(v,l));v>g&&f.fill(i,g*u,v*u);for(var C=x;C<m;++C){var y=a[C];if(y<0||y>=s[0])throw Error(p.backend_util.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(C,a[C],s[0]));for(var k=0;k<u;k++)f[v*u+k]+=e[y*u+k]}if(o)for(var k=0;k<u;k++)f[v*u+k]/=m-x;if(x=m,++m,g=v+1,v=b,m>c)break}return g<l&&f.fill(i,g*u,l*u),[f,d]},stridedSliceImplCPU=function(e,n,t,a){for(var r=p.buffer(e,n.dtype),o=0;o<r.size;o++){for(var i=r.indexToLoc(o),c=Array(i.length),s=0;s<c.length;s++)c[s]=i[s]*t[s]+a[s];r.set.apply(r,__spreadArray([n.get.apply(n,__spreadArray([],__read(c),!1))],__read(i),!1))}return r},stringSplitImplCPU=function(e,n,t){for(var a=e.length,r=[],o=0,i=0,c=Array(a),s=0;s<a;++s){var u=r.length;!/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e,n,t,a){if(e.length){if(0===n.length){for(var r=0;r<e.length;++r)a.push(e.subarray(r,r+1));return}if(1===n.length){for(var o=n[0],i=e.indexOf(o);-1!==i;){var c=e.subarray(0,i);t&&0===c.length||a.push(c),i=(e=e.subarray(i+1)).indexOf(o)}t&&0===e.length||a.push(e);return}for(var s=0,r=0;r<e.length+1;r++)if(r===e.length||-1!==n.indexOf(e[r])){var c=e.subarray(s,r);t&&0===c.length||a.push(c),s=r+1}}}(e[s],n,t,r);var l=r.length-u;c[s]=l,o+=l,i=Math.max(i,l)}for(var d=p.util.getArrayFromDType("int32",2*o),h=Array(o),f=[a,i],x=0,s=0;s<a;++s)for(var m=0;m<c[s];++m)d[2*x]=s,d[2*x+1]=m,h[x]=r[x],++x;return[d,h,f]},stringToHashBucketFastImplCPU=/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e,n){for(var t=p.util.getArrayFromDType("int32",e.length),a=0;a<e.length;++a)t[a]=p.util.fingerPrint64(e[a]).modulo(n).getLowBitsUnsigned();return t},tileImplCPU=/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e,n){for(var t=Array(e.rank),a=0;a<t.length;a++)t[a]=e.shape[a]*n[a];for(var r=p.buffer(t,e.dtype),a=0;a<r.values.length;++a){for(var o=r.indexToLoc(a),i=Array(e.rank),c=0;c<i.length;c++)i[c]=o[c]%e.shape[c];var s=e.locToIndex(i);r.values[a]=e.values[s]}return r},topKImplCPU=function(e,n,t,a,r){for(var o=n[n.length-1],i=__read([e.length/o,o],2),c=i[0],s=i[1],u=p.util.getTypedArrayFromDType(t,c*a),l=p.util.getTypedArrayFromDType("int32",c*a),d=0;d<c;d++)!function(n){var t=n*s,o=e.subarray(t,t+s),i=Array(o.length);o.forEach(function(e,n){return i[n]={value:e,index:n}}),a<i.length&&(function select$1(e,n,t,a){for(void 0===t&&(t=0),void 0===a&&(a=e.length-1);a>t;){if(a-t>600){var r=a-t+1,o=n-t+1,i=Math.log(r),c=.5*Math.exp(2*i/3),s=.5*Math.sqrt(i*c*(r-c)/r)*Math.sign(o-r/2),u=Math.max(t,Math.floor(n-o*c/r+s)),l=Math.min(a,Math.floor(n+(r-o)*c/r+s));select$1(e,n,u,l)}var d=e[n],h=t,f=a;for(p.util.swap(e,t,n),comparePair(e[a],d)>0&&p.util.swap(e,t,a);h<f;){for(p.util.swap(e,h,f),h++,f--;0>comparePair(e[h],d);)h+=1;for(;comparePair(e[f],d)>0;)f-=1}0===comparePair(e[t],d)?p.util.swap(e,t,f):(f+=1,p.util.swap(e,f,a)),f<=n&&(t=f+1),n<=f&&(a=f-1)}}(i,a),i=i.slice(0,a)),r&&i.sort(comparePair);for(var c=n*a,d=u.subarray(c,c+a),h=l.subarray(c,c+a),f=0;f<a;f++)d[f]=i[f].value,h[f]=i[f].index}(d);var h=n.slice();return h[h.length-1]=a,[p.buffer(h,t,u),p.buffer(h,"int32",l)]},transposeImplCPU=/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e,n,t,a,r){for(var o=n.length,i=p.util.sizeFromShape(n),c=p.util.computeStrides(n),s=p.util.computeStrides(r),u=p.util.getTypedArrayFromDType(t,p.util.sizeFromShape(r)),l=0;l<i;++l){for(var d=p.util.indexToLoc(l,o,c),h=Array(d.length),f=0;f<h.length;f++)h[f]=d[a[f]];u[p.util.locToIndex(h,o,s)]=e[l]}return u},uniqueImplCPU=/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e,n,t,a){for(var r=p.util.parseAxisParam(n,t)[0],o=[1,t[0],1],i=0;i<r;i++)o[0]*=t[i];o[1]=t[r];for(var i=r+1;i<t.length;i++)o[2]*=t[i];for(var c=new Map,s=new Int32Array(t[r]),u=new p.TensorBuffer(o,a,e),l=[],d=1===o[0]&&1===o[2],i=0;i<t[r];i++){var h=void 0;if(d)h=e[i].toString();else{for(var f=[],x=0;x<o[0];x++)for(var m=0;m<o[2];m++)f.push(u.get(x,i,m));h=f.join(",")}var g=c.get(h);if(null!=g)s[i]=g;else{var v=c.size;c.set(h,v),s[i]=v,l.push(i)}}var b=o.slice();b[1]=c.size;var C=new p.TensorBuffer(b,a);l.forEach(function(e,n){for(var t=0;t<o[0];t++)for(var a=0;a<o[2];a++)C.set(u.get(t,e,a),t,n,a)});var y=t.slice();return y[r]=b[1],{outputValues:C.values,outputShape:y,indices:s}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function getVecChannels(e,n){return["x","y","z","w","u","v"].slice(0,n).map(function(n){return"".concat(e,".").concat(n)})}function getChannels(e,n){return 1===n?[e]:getVecChannels(e,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var K=function(){function PackProgram(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=useShapeUniforms(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{var n=getChannels("rc",this.rank),t=getCoordsDataType(this.rank),a=this.getOutOfBoundsCondition(n),r=this.getSetup(n),o=this.getOutput(n);this.userCode="\n        void main() {\n          ".concat(t," rc = getOutputCoords();\n\n          if(").concat(a,") {\n            setOutput(vec4(0));\n          } else {\n            ").concat(r,"\n\n            setOutput(vec4(").concat(o,"));\n          }\n        }\n      ")}}return PackProgram.prototype.getSourceCoordsArr=function(e){for(var n=[],t=0;t<=1;t++)for(var a=0;a<=1;a++){for(var r="".concat(0===t?"r":"rp1",", ").concat(0===a?"c":"cp1"),o=2;o<this.rank;o++)r="".concat(e[e.length-1-o],",")+r;n.push(r)}return n},PackProgram.prototype.getOutOfBoundsCondition=function(e){if(1===this.rank)return"rc > ".concat(this.enableShapeUniforms?"outShape":this.outputShape[0]);for(var n="",t=this.rank-2;t<this.rank;t++)n+="".concat(e[t]," >= ").concat(this.enableShapeUniforms?"outShape[".concat(t,"]"):this.outputShape[t]),t<this.rank-1&&(n+="||");return n},PackProgram.prototype.getSetup=function(e){if(1===this.rank)return"";var n=e.slice(-2),t=this.enableShapeUniforms?"outShape[".concat(this.rank," - 1]"):this.outputShape[this.rank-1],a=this.enableShapeUniforms?"outShape[".concat(this.rank," - 2]"):this.outputShape[this.rank-2];return"\n      int r = ".concat(n[0],";\n      int c = ").concat(n[1],";\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ").concat(t,";\n      bool rEdge = rp1 >= ").concat(a,";\n    ")},PackProgram.prototype.getOutput=function(e){var n=this.getSourceCoordsArr(e);if(1===this.rank){var t=this.enableShapeUniforms?"outShape":this.outputShape[0];return"getA(rc), (rc + 1 >= ".concat(t," ? 0. : getA(rc + 1)), 0, 0")}return"getA(".concat(n[0],"),\n            cEdge ? 0. : getA(").concat(n[1],"),\n            rEdge ? 0. : getA(").concat(n[2],"),\n            rEdge || cEdge ? 0. : getA(").concat(n[3],")")},PackProgram}(),ReshapePackedProgram=function(e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=useShapeUniforms(this.outputShape.length);for(var t,a,r,o,i,c="",s=0;s<4;s++){var u="thisRC = rc;";s%2==1&&(u+="thisRC.z += 1;"),s>1&&(u+="thisRC.y += 1;"),c+="\n        ".concat(u,"\n        ").concat(s>0?"if(thisRC.y < rows && thisRC.z < cols){":"","\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[").concat(s,"] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ").concat(s>0?"}":"","\n      ")}this.userCode="\n      ".concat((t=n,i=this.enableShapeUniforms?(void 0===r&&(r="index"),(o=function(e,n){var t=e.length,a=e.map(function(e){return"".concat(n,"[").concat(e,"]")}),r=Array(t-1);r[t-2]=a[t-1];for(var o=t-3;o>=0;--o)r[o]="(".concat(r[o+1]," * ").concat(a[o+1],")");return r}((a=["r","c","d"]).map(function(e,n){return n}),"inputShape")).map(function(e,n){var t="int ".concat(a[n]," = ").concat(r," / ").concat(o[n]),i=n===o.length-1?"int ".concat(a[n+1]," = ").concat(r," - ").concat(a[n]," * ").concat(o[n]):"index -= ".concat(a[n]," * ").concat(o[n]);return"".concat(t,"; ").concat(i,";")}).join("")):getLogicalCoordinatesFromFlatIndex(["r","c","d"],t),"\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ".concat(i,"\n      return ivec3(r, c, d);\n    }\n  ")),"\n      ").concat(this.enableShapeUniforms?getFlatIndexFrom3DOutput():getFlatIndexFrom3D(e),"\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ").concat(this.enableShapeUniforms?"outShape[1]":e[1],";\n        int cols = ").concat(this.enableShapeUniforms?"outShape[2]":e[2],";\n\n        ").concat(c,"\n\n        setOutput(result);\n      }\n    ")},j=function(){function TextureManager(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}return TextureManager.prototype.acquireTexture=function(e,n,t){var a,r=getPhysicalFromLogicalTextureType(n,t),i=getKeyFromTextureShape(e,r,t);i in this.freeTextures||(this.freeTextures[i]=[]),i in this.usedTextures||(this.usedTextures[i]=[]);var c=computeBytes(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,t);if(this.freeTextures[i].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=c,this.log();var s=this.freeTextures[i].pop();return this.usedTextures[i].push(s),s}return r===o.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===o.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===o.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===o.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===o.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[i].push(a),this.numUsedTextures++,this._numBytesAllocated+=c,this.log(),a},TextureManager.prototype.releaseTexture=function(e,n,t,a){if(null!=this.freeTextures){var r=getPhysicalFromLogicalTextureType(t,a),o=getKeyFromTextureShape(n,r,a);o in this.freeTextures||(this.freeTextures[o]=[]);var i=computeBytes(n,r,this.gpgpu.gl,this.gpgpu.textureConfig,a),c=p.env().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==c&&this._numBytesAllocated>c?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=i):(this.freeTextures[o].push(e),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;var s=this.usedTextures[o],u=s&&s.indexOf(e);if(null==u||u<0)throw Error("Cannot release a texture that was never provided by this texture manager");s[u]=s[s.length-1],s.pop(),this.log()}},TextureManager.prototype.log=function(){if(this.logEnabled){var e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used","".concat(this.numFreeTextures," / ").concat(this.numUsedTextures),"(".concat(e,")"));var n=this._numBytesFree/this._numBytesAllocated;console.log("Bytes allocated: ".concat(this._numBytesAllocated)),console.log("Bytes unused: ".concat(this._numBytesFree," (").concat(Math.round(100*n),"%)"))}},Object.defineProperty(TextureManager.prototype,"numBytesAllocated",{get:function(){return this._numBytesAllocated},enumerable:!1,configurable:!0}),Object.defineProperty(TextureManager.prototype,"numBytesFree",{get:function(){return this._numBytesFree},enumerable:!1,configurable:!0}),TextureManager.prototype.getNumUsedTextures=function(){return this.numUsedTextures},TextureManager.prototype.getNumFreeTextures=function(){return this.numFreeTextures},TextureManager.prototype.dispose=function(){var e=this;if(null!=this.freeTextures){for(var n in this.freeTextures)this.freeTextures[n].forEach(function(n){e.gpgpu.deleteMatrixTexture(n.texture)});for(var n in this.usedTextures)this.usedTextures[n].forEach(function(n){e.gpgpu.deleteMatrixTexture(n.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}},TextureManager}();function computeBytes(e,n,t,a,r){var i,c=function(e,n){switch(e){case o.PACKED_2X2_FLOAT32:return getInternalFormatForPackedMatrixTexture(n);case o.PACKED_2X2_FLOAT16:return getInternalFormatForFloat16PackedMatrixTexture(n);case o.UNPACKED_FLOAT32:return getInternalFormatForFloat32MatrixTexture(n);case o.UNPACKED_FLOAT16:return getInternalFormatForFloat16MatrixTexture(n);case o.PACKED_4X1_UNSIGNED_BYTE:return getInternalFormatForUnsignedBytesMatrixTexture(n);default:throw Error("Unknown physical texture type ".concat(e))}}(n,a);if(r){var s=__read(getPackedMatrixTextureShapeWidthHeight(e[0],e[1]),2);i=s[0]*s[1]}else{var u,l=__read((u=e[0],[e[1],u]),2);i=l[0]*l[1]}return i*function(e,n){if(n===e.R32F)return 4;if(n===e.R16F)return 2;if(n===e.RGBA32F||n===e.RGBA)return 16;if(n===e.RGBA16F)return 8;if(n===e.RGBA8)return 4;throw Error("Unknown internal format ".concat(n))}(t,c)}function getPhysicalFromLogicalTextureType(e,n){if(e===r.UPLOAD)return o.PACKED_2X2_FLOAT32;if(e===r.RENDER||null==e)return p.env().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?n?o.PACKED_2X2_FLOAT32:o.UNPACKED_FLOAT32:n?o.PACKED_2X2_FLOAT16:o.UNPACKED_FLOAT16;if(e===r.DOWNLOAD||e===r.PIXELS)return o.PACKED_4X1_UNSIGNED_BYTE;throw Error("Unknown logical texture type ".concat(e))}function getKeyFromTextureShape(e,n,t){return"".concat(e[0],"_").concat(e[1],"_").concat(n,"_").concat(t)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var UnaryOpProgram=function(e,n){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=useShapeUniforms(this.outputShape.length),this.userCode="\n      float unaryOperation(float x) {\n        ".concat(n,"\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ")},q="if (isnan(x)) return x;",Y="return abs(x);",Q=q+"\n  return (x < 0.0) ? 0.0 : x;\n",Z=q+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",J="return x;",UnaryOpPackedProgram=function(e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=useShapeUniforms(this.outputShape.length),this.userCode="\n      vec4 unaryOperation(vec4 x) {\n        ".concat(n,"\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ")},UnpackProgram=function(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=useShapeUniforms(this.outputShape.length);var n=e.length,t=getChannels("rc",n),a=getCoordsDataType(n),r=function(e,n){if(1===e)return"rc";for(var t="",a=0;a<e;a++)t+=n[a],a<e-1&&(t+=",");return t}(n,t),o=t.slice(-2),i=n<=1?"rc":"vec2(".concat(o.join(","),")");this.userCode="\n      void main() {\n        ".concat(a," rc = getOutputCoords();\n        vec4 packedInput = getA(").concat(r,");\n\n        setOutput(getChannel(packedInput, ").concat(i,"));\n      }\n    ")},$=p.kernel_impls.whereImpl,ee={},en=p.env().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),et=function(e){function MathBackendWebGL(n){var t,a=e.call(this)||this;if(a.pendingRead=new WeakMap,a.pendingDisposal=new WeakSet,a.dataRefCount=new WeakMap,a.numBytesInGPU=0,a.uploadWaitMs=0,a.downloadWaitMs=0,a.lastGlFlushTime=0,a.warnedAboutMemory=!1,a.pendingDeletes=0,a.disposed=!1,!p.env().getBool("HAS_WEBGL"))throw Error("WebGL is not supported on this device");if(null!=n){if(n instanceof y)t=n;else{var r=getWebGLContext(p.env().getNumber("WEBGL_VERSION"),n);t=new y(r)}a.binaryCache={},a.gpgpuCreatedLocally=!1}else{var o,r=getWebGLContext(p.env().getNumber("WEBGL_VERSION"));t=new y(r),a.binaryCache=((o=p.env().getNumber("WEBGL_VERSION"))in ee||(ee[o]={}),ee[o]),a.gpgpuCreatedLocally=!0}return a.gpgpu=t,a.canvas=a.gpgpu.gl.canvas,a.textureManager=new j(a.gpgpu),a.numMBBeforeWarning=null==p.env().global.screen?1024:p.env().global.screen.height*p.env().global.screen.width*window.devicePixelRatio*600/1024/1024,a.texData=new p.DataStorage(a,p.engine()),a}return function(e,n){if("function"!=typeof n&&null!==n)throw TypeError("Class extends value "+String(n)+" is not a constructor or null");function __(){this.constructor=e}extendStatics(e,n),e.prototype=null===n?Object.create(n):(__.prototype=n.prototype,new __)}(MathBackendWebGL,e),MathBackendWebGL.prototype.nextDataId=function(){return MathBackendWebGL.nextDataId++},MathBackendWebGL.prototype.numDataIds=function(){return this.texData.numDataIds()-this.pendingDeletes},MathBackendWebGL.prototype.writeTexture=function(e,n,t,a,r,o){var i=this.makeTensorInfo(n,t),c=this.texData.get(i.dataId);c.isPacked=!1,c.texture={texture:e,texShape:[a,r]},c.texShape=[a,r];var s=getShapeAs3D(n),u=new EncodeMatrixProgram(s,!1,o),l=this.runWebGLProgram(u,[i],t,[[a,r]]);return l.shape=n,c.texture=null,this.disposeIntermediateTensorInfo(i),l.dataId},MathBackendWebGL.prototype.write=function(e,n,t){if((p.env().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||p.env().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===t&&null!=e)throw Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");var a={id:this.nextDataId()};return this.texData.set(a,{shape:n,dtype:t,values:e,usage:r.UPLOAD,refCount:1}),a},MathBackendWebGL.prototype.refCount=function(e){return this.texData.has(e)?this.texData.get(e).refCount:0},MathBackendWebGL.prototype.incRef=function(e){var n=this.texData.get(e);n.refCount++},MathBackendWebGL.prototype.decRef=function(e){if(this.texData.has(e)){var n=this.texData.get(e);n.refCount--}},MathBackendWebGL.prototype.move=function(e,n,t,a,o){if(p.env().getBool("DEBUG")&&this.checkNumericalProblems(n),"complex64"===a)throw Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:t,dtype:a,values:n,usage:r.UPLOAD,refCount:o})},MathBackendWebGL.prototype.disposeIntermediateTensorInfo=function(e){this.disposeData(e.dataId)},MathBackendWebGL.prototype.readSync=function(e){var n,t,a=this.texData.get(e),r=a.values,o=a.dtype,i=a.complexTensorInfos,c=a.slice,s=a.shape,u=a.isPacked;if(null!=c){var l=void 0;l=u?new UnaryOpPackedProgram(s,J):new UnaryOpProgram(s,J);var d=this.runWebGLProgram(l,[{dataId:e,shape:s,dtype:o}],o),h=this.readSync(d.dataId);return this.disposeIntermediateTensorInfo(d),h}if(null!=r)return this.convertAndCacheOnCPU(e);if("string"===o)return r;var f=null!=this.activeTimers;if(f&&(n=p.util.now()),"complex64"===o){var x=this.readSync(i.real.dataId),m=this.readSync(i.imag.dataId);t=p.backend_util.mergeRealAndImagArrays(x,m)}else t=this.getValuesFromTexture(e);return f&&(this.downloadWaitMs+=p.util.now()-n),this.convertAndCacheOnCPU(e,t)},MathBackendWebGL.prototype.read=function(e){return __awaiter(this,void 0,void 0,function(){var n,t,a,r,o,i,c,s,u,l,d,h,f,x,m,g,v,b,C,y,k,I,T;return __generator(this,function(S){switch(S.label){case 0:if(this.pendingRead.has(e))return n=this.pendingRead.get(e),[2,new Promise(function(e){return n.push(e)})];if(a=(t=this.texData.get(e)).values,r=t.shape,o=t.slice,i=t.dtype,c=t.complexTensorInfos,s=t.isPacked,null!=o)return u=void 0,u=s?new UnaryOpPackedProgram(r,J):new UnaryOpProgram(r,J),l=this.runWebGLProgram(u,[{dataId:e,shape:r,dtype:i}],i),d=this.read(l.dataId),this.disposeIntermediateTensorInfo(l),[2,d];if(null!=a)return[2,this.convertAndCacheOnCPU(e)];if(p.env().getBool("DEBUG")&&!p.env().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===p.env().getNumber("WEBGL_VERSION"))throw Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");if(h=null,"complex64"!==i&&p.env().get("WEBGL_BUFFER_SUPPORTED")&&(f=this.decode(e),x=this.texData.get(f.dataId),h=(T=this.gpgpu).createBufferFromTexture.apply(T,__spreadArray([x.texture.texture],__read(getDenseTexShape(r)),!1))),this.pendingRead.set(e,[]),!("complex64"!==i))return[3,2];return[4,this.gpgpu.createAndWaitForFence()];case 1:S.sent(),S.label=2;case 2:if("complex64"!==i)return[3,4];return[4,Promise.all([this.read(c.real.dataId),this.read(c.imag.dataId)])];case 3:return v=(g=S.sent())[0],b=g[1],m=p.backend_util.mergeRealAndImagArrays(v,b),[3,5];case 4:null==h?m=this.getValuesFromTexture(e):(C=p.util.sizeFromShape(r),m=this.gpgpu.downloadFloat32MatrixFromBuffer(h,C)),S.label=5;case 5:return null!=f&&this.disposeIntermediateTensorInfo(f),null!=h&&callAndCheck(y=this.gpgpu.gl,function(){return y.deleteBuffer(h)}),k=this.convertAndCacheOnCPU(e,m),I=this.pendingRead.get(e),this.pendingRead.delete(e),I.forEach(function(e){return e(k)}),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&p.engine().removeDataId(e,this),this.pendingDeletes--),[2,k]}})})},MathBackendWebGL.prototype.readToGPU=function(e,n){void 0===n&&(n={});var t=this.texData.get(e),a=t.values,r=t.shape,o=t.slice,i=t.dtype,c=t.isPacked,s=t.texture;if("complex64"===i)throw Error("Does not support reading texture for complex64 dtype.");if(null!=o){var u=void 0;u=c?new UnaryOpPackedProgram(r,J):new UnaryOpProgram(r,J);var l=this.runWebGLProgram(u,[{dataId:e,shape:r,dtype:i}],i),d=this.readToGPU(l,n);return this.disposeIntermediateTensorInfo(l),d}if(null==s){if(null!=a)throw Error("Data is not on GPU but on CPU.");throw Error("There is no data on GPU or CPU.")}var h=this.decode(e,n.customTexShape);return Object.assign({tensorRef:p.engine().makeTensorFromTensorInfo(h)},this.texData.get(h.dataId).texture)},MathBackendWebGL.prototype.bufferSync=function(e){var n=this.readSync(e.dataId);if("string"===e.dtype)try{var t=n.map(function(e){return p.util.decodeString(e)});return p.buffer(e.shape,e.dtype,t)}catch(e){throw Error("Failed to decode encoded string bytes into utf-8")}return p.buffer(e.shape,e.dtype,n)},MathBackendWebGL.prototype.checkNumericalProblems=function(e){if(null!=e)for(var n=0;n<e.length;n++){var t=e[n];if(!canBeRepresented(t)){if(p.env().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error("The value ".concat(t," cannot be represented with your ")+"current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'");throw Error("The value ".concat(t," cannot be represented on this device."))}}},MathBackendWebGL.prototype.getValuesFromTexture=function(e){var n,t=this.texData.get(e),a=t.shape,r=t.dtype,o=t.isPacked,i=p.util.sizeFromShape(a);if(p.env().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){var c=this.decode(e),s=this.texData.get(c.dataId),u=(n=this.gpgpu).downloadMatrixFromPackedTexture.apply(n,__spreadArray([s.texture.texture],__read(getDenseTexShape(a)),!1)).subarray(0,i);return this.disposeIntermediateTensorInfo(c),u}var l=p.env().getBool("WEBGL_PACK")&&!0===o,d=l?getShapeAs3D(a):a,h=l?new EncodeFloatPackedProgram(d):new EncodeFloatProgram(d),f=this.runWebGLProgram(h,[{shape:d,dtype:r,dataId:e}],"float32"),x=this.texData.get(f.dataId),m=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(x.texture.texture,x.texShape[0],x.texShape[1]).subarray(0,i);return this.disposeIntermediateTensorInfo(f),m},MathBackendWebGL.prototype.timerAvailable=function(){return p.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0},MathBackendWebGL.prototype.time=function(e){var n=this.activeTimers,t=[],a=!1;null==this.programTimersStack?(this.programTimersStack=t,a=!0):this.activeTimers.push(t),this.activeTimers=t,e();var r=p.util.flatten(this.activeTimers.map(function(e){return e.query})).filter(function(e){return null!=e}),o=p.util.flatten(this.activeTimers.map(function(e){return e.name})).filter(function(e){return null!=e});this.activeTimers=n,a&&(this.programTimersStack=null);var i={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return __awaiter(this,void 0,void 0,function(){var e;return __generator(this,function(n){switch(n.label){case 0:if(!(p.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0))return[3,2];return[4,Promise.all(r)];case 1:return e=n.sent(),i.kernelMs=p.util.sum(e),i.getExtraProfileInfo=function(){return e.map(function(e,n){return{name:o[n],ms:e}}).map(function(e){return"".concat(e.name,": ").concat(e.ms)}).join(", ")},[3,3];case 2:i.kernelMs={error:"WebGL query timers are not supported in this environment."},n.label=3;case 3:return this.uploadWaitMs=0,this.downloadWaitMs=0,[2,i]}})})},MathBackendWebGL.prototype.memory=function(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}},MathBackendWebGL.prototype.startTimer=function(){return p.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:p.util.now(),endMs:null}},MathBackendWebGL.prototype.endTimer=function(e){return p.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.endQuery():e.endMs=p.util.now(),e},MathBackendWebGL.prototype.getQueryTime=function(e){return __awaiter(this,void 0,void 0,function(){var n;return __generator(this,function(t){return p.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?[2,this.gpgpu.waitForQueryAndGetTime(e)]:[2,(n=e).endMs-n.startMs]})})},MathBackendWebGL.prototype.disposeData=function(e,n){if(void 0===n&&(n=!1),this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(n?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!n&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);var t=this.texData.get(e).complexTensorInfos;return null!=t&&(this.disposeData(t.real.dataId,n),this.disposeData(t.imag.dataId,n)),this.texData.delete(e),!0},MathBackendWebGL.prototype.releaseGPUData=function(e){var n=this.texData.get(e),t=n.texture,a=n.dtype,r=n.texShape,o=n.usage,i=n.isPacked,c=n.slice,s=c&&c.origDataId||e,u=this.dataRefCount.get(s);u>1?this.dataRefCount.set(s,u-1):(this.dataRefCount.delete(s),null!=t&&(this.numBytesInGPU-=this.computeBytes(r,a),this.textureManager.releaseTexture(t,r,o,i)));var l=this.texData.get(e);l.texture=null,l.texShape=null,l.isPacked=!1,l.slice=null},MathBackendWebGL.prototype.getTexture=function(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture},MathBackendWebGL.prototype.getDataInfo=function(e){return this.texData.get(e)},MathBackendWebGL.prototype.shouldExecuteOnCPU=function(e,n){var t=this;return void 0===n&&(n=en),p.env().getBool("WEBGL_CPU_FORWARD")&&e.every(function(e){return null==t.texData.get(e.dataId).texture&&p.util.sizeFromShape(e.shape)<n})},MathBackendWebGL.prototype.getGPGPUContext=function(){return this.gpgpu},MathBackendWebGL.prototype.where=function(e){p.backend_util.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");var n=e.dataSync();return $(e.shape,n)},MathBackendWebGL.prototype.packedUnaryOp=function(e,n,t){var a=new UnaryOpPackedProgram(e.shape,n),r=this.compileAndRun(a,[e],t);return p.engine().makeTensorFromTensorInfo(r)},MathBackendWebGL.prototype.abs=function(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){var n=simpleAbsImplCPU(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,n)}if(p.env().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,Y,e.dtype);var t=new UnaryOpProgram(e.shape,Y),a=this.compileAndRun(t,[e]);return p.engine().makeTensorFromTensorInfo(a)},MathBackendWebGL.prototype.makeTensorInfo=function(e,n,t){var a;if("string"===n&&null!=t&&t.length>0&&p.util.isString(t[0])){var r=t.map(function(e){return p.util.encodeString(e)});a=this.write(r,e,n)}else a=this.write(t,e,n);return this.texData.get(a).usage=null,{dataId:a,shape:e,dtype:n}},MathBackendWebGL.prototype.makeOutput=function(e,n,t){return p.engine().makeTensorFromTensorInfo(this.makeTensorInfo(e,n,t),this)},MathBackendWebGL.prototype.unpackTensor=function(e){var n=new UnpackProgram(e.shape);return this.runWebGLProgram(n,[e],e.dtype)},MathBackendWebGL.prototype.packTensor=function(e){var n=new K(e.shape);return this.runWebGLProgram(n,[e],e.dtype,null,!0)},MathBackendWebGL.prototype.packedReshape=function(e,n){var t=__spreadArray([getBatchDim(e.shape)],__read(getRowsCols(e.shape)),!1),a={dtype:e.dtype,shape:t,dataId:e.dataId},r=__spreadArray([getBatchDim(n)],__read(getRowsCols(n)),!1),o=new ReshapePackedProgram(r,t),i=[t],c=this.runWebGLProgram(o,[a],e.dtype,i,!0);return{dataId:c.dataId,shape:n,dtype:c.dtype}},MathBackendWebGL.prototype.decode=function(e,n){var t,a=this.texData.get(e),r=a.isPacked,o=a.shape,i=a.dtype;if(null!=n){var c=p.util.sizeFromShape(o),s=n[0]*n[1]*4;p.util.assert(c<=s,function(){return"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data."})}var u=getShapeAs3D(o);t=r?new DecodeMatrixPackedProgram(u):new DecodeMatrixProgram(u);var l=[null!=n?n:getDenseTexShape(u)],d=this.runWebGLProgram(t,[{shape:u,dtype:i,dataId:e}],i,l,!0,n);return{dtype:i,shape:o,dataId:d.dataId}},MathBackendWebGL.prototype.runWebGLProgram=function(e,n,t,r,o,i){var c,s=this;void 0===o&&(o=!1);var u=this.makeTensorInfo(e.outputShape,t),l=this.texData.get(u.dataId);if(e.packedOutput&&(l.isPacked=!0),e.outPackingScheme===a.DENSE){var d=null!=i?i:getDenseTexShape(e.outputShape);l.texShape=d.map(function(e){return 2*e})}if(null!=e.outTexUsage&&(l.usage=e.outTexUsage),0===p.util.sizeFromShape(u.shape))return l.values=p.util.getTypedArrayFromDType(u.dtype,0),u;var h=[],f=n.map(function(n){if("complex64"===n.dtype)throw Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");var t=s.texData.get(n.dataId);if(null==t.texture){if(!e.packedInputs&&p.util.sizeFromShape(n.shape)<=p.env().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:n.shape,texData:null,isUniform:!0,uniformValues:t.values};e.packedInputs&&(t.isPacked=!0,t.shape=n.shape)}if(s.uploadToGPU(n.dataId),!!t.isPacked!=!!e.packedInputs)n=t.isPacked?s.unpackTensor(n):s.packTensor(n),h.push(n),t=s.texData.get(n.dataId);else if(t.isPacked&&!isReshapeFree(t.shape,n.shape)){var a=n,r=n.shape;n.shape=t.shape,n=s.packedReshape(n,r),h.push(n),t=s.texData.get(n.dataId),a.shape=r}return{shape:n.shape,texData:t,isUniform:!1}});this.uploadToGPU(u.dataId);var x={shape:u.shape,texData:l,isUniform:!1},m=function(e,n,t){var a="";n.concat(t).forEach(function(n){var r=null!=n.texData&&null!=n.texData.slice&&n.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!n.isUniform){var o=n.texData.texShape,i=getUniformInfoFromShape(e.packedInputs,n.shape,o),c=i.useSqueezeShape,s=i.uniformShape,u=i.keptDims,l="",d="",h="";if(1===s.length&&e.packedInputs){var f=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];l="".concat(f[0]>1,"_").concat(f[1]>1)}else if(2!==s.length||e.packedInputs){if(s.length>2&&!e.packedInputs){var x=p.util.computeStrides(s);h="".concat(x[0]===o[1],"_").concat(x[x.length-1]===o[1])}}else d="".concat(s[0]>1,"_").concat(s[1]>1);var m=n.shape.length,g=2===s.length&&p.util.arraysEqual(n.shape,o),v=1===p.util.sizeFromShape(n.shape),b=p.backend_util.getBroadcastDims(n.shape,t.shape),C=!e.packedInputs&&m===t.shape.length&&p.util.arraysEqual(o,t.texData.texShape),y=e.packedInputs||s.length>2?"":"".concat(o[0]>1,"_").concat(o[1]>1);a+="".concat(m,"_").concat(C,"_").concat(c?u:"","_").concat(s.length,"_").concat(v,"_").concat(b,"_").concat(g,"_").concat(l,"_").concat(d,"_").concat(h,"_").concat(y,"_").concat(r)}else{var k=n.isUniform?"uniform":n.texData.texShape;a+="".concat(n.shape,"_").concat(k,"_").concat(r)}});var r=e.userCode;return e.constructor.name+("_"+a+"_"+r)+"".concat(p.env().getNumber("WEBGL_VERSION"))}(e,f,x),g=this.getAndSaveBinary(m,function(){var n,t,a,r,o,i,c;return n=s.gpgpu,a=(t=f.map(function(n,t){var a={logicalShape:n.shape,texShape:n.isUniform?null:n.texData.texShape,isUniform:n.isUniform,isPacked:!n.isUniform&&n.texData.isPacked,flatOffset:null};return null!=n.texData&&null!=n.texData.slice&&n.texData.slice.flatOffset>0&&(a.flatOffset=n.texData.slice.flatOffset),{name:e.variableNames[t],shapeInfo:a}})).map(function(e){return e.shapeInfo}),o=function(e,n,t){var a,r,o=[];if(e.forEach(function(e){var n=p.util.sizeFromShape(e.shapeInfo.logicalShape);if(e.shapeInfo.isUniform?o.push("uniform float ".concat(e.name).concat(n>1?"[".concat(n,"]"):"",";")):(o.push("uniform sampler2D ".concat(e.name,";")),o.push("uniform int offset".concat(e.name,";"))),t.enableShapeUniforms){switch(getUniformInfoFromShape(t.packedInputs,e.shapeInfo.logicalShape,e.shapeInfo.texShape).uniformShape.length){case 1:o.push("uniform int ".concat(e.name,"Shape;"));break;case 2:o.push("uniform ivec2 ".concat(e.name,"Shape;"));break;case 3:o.push("uniform ivec3 ".concat(e.name,"Shape;"));break;case 4:o.push("uniform ivec4 ".concat(e.name,"Shape;"))}o.push("uniform ivec2 ".concat(e.name,"TexShape;"))}}),t.enableShapeUniforms){switch(n.logicalShape.length){case 1:o.push("uniform int outShape;");break;case 2:o.push("uniform ivec2 outShape;"),o.push("uniform int outShapeStrides;");break;case 3:o.push("uniform ivec3 outShape;"),o.push("uniform ivec2 outShapeStrides;");break;case 4:o.push("uniform ivec4 outShape;"),o.push("uniform ivec3 outShapeStrides;")}o.push("uniform ivec2 outTexShape;")}t.customUniforms&&t.customUniforms.forEach(function(e){o.push("uniform ".concat(e.type," ").concat(e.name).concat(e.arrayIndex?"[".concat(e.arrayIndex,"]"):"",";"))});var i=o.join("\n"),c=e.map(function(e){var a,r,o,i,c;return a=t.packedInputs,r=t.enableShapeUniforms,void 0===a&&(a=!1),o="",a?o+=function getPackedSamplerFromInInfo(e,n){switch(e.shapeInfo.logicalShape.length){case 0:var t,a,r;return a="get"+(t=e.name).charAt(0).toUpperCase()+t.slice(1),r=getGlslDifferences(),"\n    vec4 ".concat(a,"() {\n      return ").concat(r.texture2D,"(").concat(t,", halfCR);\n    }\n  ");case 1:return function(e,n){var t=e.name,a="get"+t.charAt(0).toUpperCase()+t.slice(1),r=e.shapeInfo.texShape,o=getGlslDifferences();if(n)return"\n    vec4 ".concat(a,"(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(t,"TexShape[0]) / 2.0), ceil(float(").concat(t,"TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ").concat(o.texture2D,"(").concat(t,", uv);\n    }\n  ");var i=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];return"\n    vec4 ".concat(a,"(int index) {\n      vec2 uv = packedUVfrom1D(\n        ").concat(i[0],", ").concat(i[1],", index);\n      return ").concat(o.texture2D,"(").concat(t,", uv);\n    }\n  ")}(e,n);case 2:return function(e,n){var t=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),o=e.shapeInfo.texShape,i=o[0],c=o[1],s=getGlslDifferences();if(null!=o&&p.util.arraysEqual(t,o))return n?"\n      vec4 ".concat(r,"(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n\n        return ").concat(s.texture2D,"(").concat(a,", uv);\n      }\n    "):"\n      vec4 ".concat(r,"(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(c,".0, ").concat(i,".0);\n\n        return ").concat(s.texture2D,"(").concat(a,", uv);\n      }\n    ");if(n)return"\n    vec4 ".concat(r,"(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(a,"TexShape[0]) / 2.0), ceil(float(").concat(a,"TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(").concat(a,"Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ").concat(s.texture2D,"(").concat(a,", uv);\n    }\n  ");var u=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],l=Math.ceil(t[1]/2);return"\n    vec4 ".concat(r,"(int row, int col) {\n      vec2 uv = packedUVfrom2D(").concat(l,", ").concat(u[0],", ").concat(u[1],", row, col);\n      return ").concat(s.texture2D,"(").concat(a,", uv);\n    }\n  ")}(e,n);case 3:return function(e,n){var t=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),o=e.shapeInfo.texShape,i=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];if(1===t[0]){var c=squeezeInputInfo(e,t.slice(1));return"\n        ".concat(getPackedSamplerFromInInfo(c,n),"\n        vec4 ").concat(r,"(int b, int row, int col) {\n          return ").concat(r,"(").concat(getSqueezedParams(["b","row","col"],[1,2]),");\n        }\n      ")}var s=getGlslDifferences();if(n)return"\n    vec4 ".concat(r,"(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(a,"TexShape[0]) / 2.0), ceil(float(").concat(a,"TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(").concat(a,"Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(").concat(a,"Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ").concat(s.texture2D,"(").concat(a,", uv);\n    }\n  ");var u=i[0],l=i[1],d=Math.ceil(t[2]/2),p=d*Math.ceil(t[1]/2);return"\n    vec4 ".concat(r,"(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ").concat(u,", ").concat(l,", ").concat(p,", ").concat(d,", b, row, col);\n      return ").concat(s.texture2D,"(").concat(a,", uv);\n    }\n  ")}(e,n);default:return function(e,n){var t=e.name,a="get"+t.charAt(0).toUpperCase()+t.slice(1),r=getGlslDifferences();if(n)return"\n    vec4 ".concat(a,"(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(").concat(t,"Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(").concat(t,"Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ").concat(t,"Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(t,"TexShape[0]) / 2.0), ceil(float(").concat(t,"TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ").concat(r.texture2D,"(").concat(t,", uv);\n    }\n  ");for(var o=e.shapeInfo.logicalShape,i=o.length,c=e.shapeInfo.texShape,s=[Math.ceil(c[0]/2),Math.ceil(c[1]/2)],u=s[0],l=s[1],d=Math.ceil(o[i-1]/2),p=d*Math.ceil(o[i-2]/2),h="int b, int row, int col",f="b * ".concat(p," + (row / 2) * ").concat(d," + (col / 2)"),x=2;x<i-1;x++)h="int b".concat(x,", ")+h,p*=o[i-x-1],f="b".concat(x," * ").concat(p," + ")+f;return"\n    vec4 ".concat(a,"(").concat(h,") {\n      int index = ").concat(f,";\n      int texR = index / ").concat(l,";\n      int texC = index - texR * ").concat(l,";\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(l,", ").concat(u,");\n      return ").concat(r.texture2D,"(").concat(t,", uv);\n    }\n  ")}(e,n)}}(e,r):o+=function getSamplerFromInInfo(e,n){void 0===n&&(n=!1);var t=e.shapeInfo.logicalShape;switch(t.length){case 0:return function(e,n){var t=e.name,a="get"+t.charAt(0).toUpperCase()+t.slice(1);if(e.shapeInfo.isUniform)return"float ".concat(a,"() {return ").concat(t,";}");var r=__read(e.shapeInfo.texShape,2),o=r[0],i=r[1];if(1===o&&1===i)return"\n      float ".concat(a,"() {\n        return sampleTexture(").concat(t,", halfCR);\n      }\n    ");var c=getFlatOffsetUniformName(t);if(n)return"\n    float ".concat(a,"() {\n      vec2 uv = uvFromFlat(").concat(t,"TexShape[0], ").concat(t,"TexShape[1], ").concat(c,");\n      return sampleTexture(").concat(t,", uv);\n    }\n  ");var s=__read(e.shapeInfo.texShape,2),u=s[0],l=s[1];return"\n    float ".concat(a,"() {\n      vec2 uv = uvFromFlat(").concat(u,", ").concat(l,", ").concat(c,");\n      return sampleTexture(").concat(t,", uv);\n    }\n  ")}(e,n);case 1:return function(e,n){var t=e.name,a="get"+t.charAt(0).toUpperCase()+t.slice(1);if(e.shapeInfo.isUniform)return"\n      float ".concat(a,"(int index) {\n        ").concat(getUniformSampler(e),"\n      }\n    ");var r=e.shapeInfo.texShape,o=r[0],i=r[1];if(1===i&&1===o)return"\n      float ".concat(a,"(int index) {\n        return sampleTexture(").concat(t,", halfCR);\n      }\n    ");var c=getFlatOffsetUniformName(t);return 1===i?n?"\n      float ".concat(a,"(int index) {\n        vec2 uv = vec2(0.5, (float(index + ").concat(c,") + 0.5) / float(").concat(t,"TexShape[0]));\n        return sampleTexture(").concat(t,", uv);\n      }\n    "):"\n      float ".concat(a,"(int index) {\n        vec2 uv = vec2(0.5, (float(index + ").concat(c,") + 0.5) / ").concat(o,".0);\n        return sampleTexture(").concat(t,", uv);\n      }\n    "):1===o?n?"\n      float ".concat(a,"(int index) {\n        vec2 uv = vec2((float(index + ").concat(c,") + 0.5) / float(").concat(t,"TexShape[1]), 0.5);\n        return sampleTexture(").concat(t,", uv);\n      }\n    "):"\n      float ".concat(a,"(int index) {\n        vec2 uv = vec2((float(index + ").concat(c,") + 0.5) / ").concat(i,".0, 0.5);\n        return sampleTexture(").concat(t,", uv);\n      }\n    "):n?"\n    float ".concat(a,"(int index) {\n      vec2 uv = uvFromFlat(").concat(t,"TexShape[0], ").concat(t,"TexShape[1], index + ").concat(c,");\n      return sampleTexture(").concat(t,", uv);\n    }\n  "):"\n    float ".concat(a,"(int index) {\n      vec2 uv = uvFromFlat(").concat(o,", ").concat(i,", index + ").concat(c,");\n      return sampleTexture(").concat(t,", uv);\n    }\n  ")}(e,n);case 2:return function(e,n){var t=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),o=e.shapeInfo.texShape;if(null!=o&&p.util.arraysEqual(t,o)){if(n)return"\n      float ".concat(r,"(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n        return sampleTexture(").concat(a,", uv);\n      }\n    ");var i=o[0],c=o[1];return"\n    float ".concat(r,"(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(c,".0, ").concat(i,".0);\n      return sampleTexture(").concat(a,", uv);\n    }\n  ")}var s=p.util.squeezeShape(t),u=s.newShape,l=s.keptDims;if(u.length<t.length){var d=squeezeInputInfo(e,u);return"\n      ".concat(getSamplerFromInInfo(d,n),"\n      float ").concat(r,"(int row, int col) {\n        return ").concat(r,"(").concat(getSqueezedParams(["row","col"],l),");\n      }\n    ")}if(e.shapeInfo.isUniform)return"\n      float ".concat(r,"(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(").concat(t[1],", 1)));\n        ").concat(getUniformSampler(e),"\n      }\n    ");var h=o[0],f=o[1],x=getFlatOffsetUniformName(a);return 1===f?n?"\n      float ".concat(r,"(int row, int col) {\n        float index = dot(vec3(row, col, ").concat(x,"), vec3(").concat(a,"Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(").concat(a,"TexShape[0]));\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n    float ".concat(r,"(int row, int col) {\n      float index = dot(vec3(row, col, ").concat(x,"), vec3(").concat(t[1],", 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ").concat(h,".0);\n      return sampleTexture(").concat(a,", uv);\n    }\n  "):1===h?n?"\n      float ".concat(r,"(int row, int col) {\n        float index = dot(vec3(row, col, ").concat(x,"), vec3(").concat(a,"Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(").concat(a,"TexShape[1]), 0.5);\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n    float ".concat(r,"(int row, int col) {\n      float index = dot(vec3(row, col, ").concat(x,"), vec3(").concat(t[1],", 1, 1));\n      vec2 uv = vec2((index + 0.5) / ").concat(f,".0, 0.5);\n      return sampleTexture(").concat(a,", uv);\n    }\n  "):n?"\n      float ".concat(r,"(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ").concat(a,"Shape[1] + col + ").concat(x,";\n        vec2 uv = uvFromFlat(").concat(a,"TexShape[0], ").concat(a,"TexShape[1], index);\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n  float ".concat(r,"(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ").concat(t[1]," + col + ").concat(x,";\n    vec2 uv = uvFromFlat(").concat(h,", ").concat(f,", index);\n    return sampleTexture(").concat(a,", uv);\n  }\n")}(e,n);case 3:return function(e,n){var t=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),o=t[1]*t[2],i=t[2],c=p.util.squeezeShape(t),s=c.newShape,u=c.keptDims;if(s.length<t.length){var l=squeezeInputInfo(e,s);return"\n        ".concat(getSamplerFromInInfo(l,n),"\n        float ").concat(r,"(int row, int col, int depth) {\n          return ").concat(r,"(").concat(getSqueezedParams(["row","col","depth"],u),");\n        }\n      ")}if(e.shapeInfo.isUniform)return"\n      float ".concat(r,"(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(").concat(o,", ").concat(i,", 1)));\n        ").concat(getUniformSampler(e),"\n      }\n    ");var d=e.shapeInfo.texShape,h=d[0],f=d[1],x=e.shapeInfo.flatOffset;if(f===o&&null==x)return n?"\n      float ".concat(r,"(int row, int col, int depth) {\n        int stride1 = ").concat(a,"Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n        float ".concat(r,"(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(").concat(i,", 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(").concat(f,".0, ").concat(h,".0);\n          return sampleTexture(").concat(a,", uv);\n        }\n      ");if(f===i&&null==x)return n?"\n      float ".concat(r,"(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(").concat(a,"Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n    float ".concat(r,"(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(").concat(t[1],", 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(f,".0, ").concat(h,".0);\n      return sampleTexture(").concat(a,", uv);\n    }\n  ");var m=getFlatOffsetUniformName(a);return n?"\n    float ".concat(r,"(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ").concat(a,"Shape[1] * ").concat(a,"Shape[2];\n      int stride1 = ").concat(a,"Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ").concat(m,";\n      vec2 uv = uvFromFlat(").concat(a,"TexShape[0], ").concat(a,"TexShape[1], index);\n      return sampleTexture(").concat(a,", uv);\n    }\n    "):"\n      float ".concat(r,"(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ").concat(o," + col * ").concat(i," + depth + ").concat(m,";\n        vec2 uv = uvFromFlat(").concat(h,", ").concat(f,", index);\n        return sampleTexture(").concat(a,", uv);\n      }\n  ")}(e,n);case 4:return function(e,n){var t=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),o=t[3],i=t[2]*o,c=t[1]*i,s=p.util.squeezeShape(t),u=s.newShape,l=s.keptDims;if(u.length<t.length){var d=squeezeInputInfo(e,u);return"\n      ".concat(getSamplerFromInInfo(d,n),"\n      float ").concat(r,"(int row, int col, int depth, int depth2) {\n        return ").concat(r,"(").concat(getSqueezedParams(["row","col","depth","depth2"],l),");\n      }\n    ")}if(e.shapeInfo.isUniform)return"\n      float ".concat(r,"(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(").concat(c,", ").concat(i,", ").concat(o,", 1)));\n        ").concat(getUniformSampler(e),"\n      }\n    ");var h=e.shapeInfo.flatOffset,f=e.shapeInfo.texShape,x=f[0],m=f[1],g="int stride2 = ".concat(a,"Shape[3];"),v="int stride1 = ".concat(a,"Shape[2] * stride2;"),b="int stride0 = ".concat(a,"Shape[1] * stride1;");if(m===c&&null==h)return n?"\n      float ".concat(r,"(int row, int col, int depth, int depth2) {\n        ").concat(g,"\n        ").concat(v,"\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n      float ".concat(r,"(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(").concat(i,", ").concat(o,", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(m,".0, ").concat(x,".0);\n        return sampleTexture(").concat(a,", uv);\n      }\n    ");if(m===o&&null==h)return n?"\n      float ".concat(r,"(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(").concat(a,"Shape[1] * ").concat(a,"Shape[2], ").concat(a,"Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n      float ".concat(r,"(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(").concat(t[1]*t[2],", ").concat(t[2],", 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(m,".0, ").concat(x,".0);\n        return sampleTexture(").concat(a,", uv);\n      }\n    ");var C=getFlatOffsetUniformName(a);return n?"\n    float ".concat(r,"(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ").concat(g,"\n      ").concat(v,"\n      ").concat(b,"\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(").concat(a,"TexShape[0], ").concat(a,"TexShape[1], index + ").concat(C,");\n      return sampleTexture(").concat(a,", uv);\n    }\n  "):"\n    float ".concat(r,"(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(c," + col * ").concat(i," +\n          depth * ").concat(o," + depth2;\n      vec2 uv = uvFromFlat(").concat(x,", ").concat(m,", index + ").concat(C,");\n      return sampleTexture(").concat(a,", uv);\n    }\n  ")}(e,n);case 5:return function(e){var n=e.shapeInfo.logicalShape,t=e.name,a="get"+t.charAt(0).toUpperCase()+t.slice(1),r=n[4],o=n[3]*r,i=n[2]*o,c=n[1]*i,s=p.util.squeezeShape(n),u=s.newShape,l=s.keptDims;if(u.length<n.length){var d=squeezeInputInfo(e,u);return"\n      ".concat(getSamplerFromInInfo(d),"\n      float ").concat(a,"(int row, int col, int depth, int depth2, int depth3) {\n        return ").concat(a,"(").concat(getSqueezedParams(["row","col","depth","depth2","depth3"],l),");\n      }\n    ")}if(e.shapeInfo.isUniform)return"\n      float ".concat(a,"(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(c,", ").concat(i,", ").concat(o,", ").concat(r,")) +\n          depth3;\n        ").concat(getUniformSampler(e),"\n      }\n    ");var h=e.shapeInfo.flatOffset,f=e.shapeInfo.texShape,x=f[0],m=f[1];if(m===c&&null==h)return"\n      float ".concat(a,"(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(").concat(i,", ").concat(o,", ").concat(r,", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(m,".0, ").concat(x,".0);\n        return sampleTexture(").concat(t,", uv);\n      }\n    ");if(m===r&&null==h)return"\n      float ".concat(a,"(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(n[1]*n[2]*n[3],",\n               ").concat(n[2]*n[3],", ").concat(n[3],", 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(m,".0, ").concat(x,".0);\n        return sampleTexture(").concat(t,", uv);\n      }\n    ");var g=getFlatOffsetUniformName(t);return"\n    float ".concat(a,"(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(c," + col * ").concat(i," + depth * ").concat(o," +\n          depth2 * ").concat(r," + depth3 + ").concat(g,";\n      vec2 uv = uvFromFlat(").concat(x,", ").concat(m,", index);\n      return sampleTexture(").concat(t,", uv);\n    }\n  ")}(e);case 6:return function(e){var n=e.shapeInfo.logicalShape,t=e.name,a="get"+t.charAt(0).toUpperCase()+t.slice(1),r=p.util.squeezeShape(n),o=r.newShape,i=r.keptDims;if(o.length<n.length){var c=squeezeInputInfo(e,o);return"\n      ".concat(getSamplerFromInInfo(c),"\n      float ").concat(a,"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ").concat(a,"(").concat(getSqueezedParams(["row","col","depth","depth2","depth3","depth4"],i),");\n      }\n    ")}var s=n[5],u=n[4]*s,l=n[3]*u,d=n[2]*l,h=n[1]*d;if(e.shapeInfo.isUniform)return"\n      float ".concat(a,"(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(h,", ").concat(d,", ").concat(l,", ").concat(u,")) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(").concat(s,", 1)));\n        ").concat(getUniformSampler(e),"\n      }\n    ");var f=e.shapeInfo.flatOffset,x=e.shapeInfo.texShape,m=x[0],g=x[1];if(g===h&&null==f)return"\n      float ".concat(a,"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(").concat(d,", ").concat(l,", ").concat(u,", ").concat(s,")) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(g,".0, ").concat(m,".0);\n        return sampleTexture(").concat(t,", uv);\n      }\n    ");if(g===s&&null==f)return"\n      float ".concat(a,"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(").concat(n[1]*n[2]*n[3]*n[4],",\n               ").concat(n[2]*n[3]*n[4],",\n               ").concat(n[3]*n[4],",\n               ").concat(n[4],")) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(g,".0, ").concat(m,".0);\n        return sampleTexture(").concat(t,", uv);\n      }\n    ");var v=getFlatOffsetUniformName(t);return"\n    float ".concat(a,"(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(h," + col * ").concat(d," + depth * ").concat(l," +\n          depth2 * ").concat(u," + depth3 * ").concat(s," + depth4 + ").concat(v,";\n      vec2 uv = uvFromFlat(").concat(m,", ").concat(g,", index);\n      return sampleTexture(").concat(t,", uv);\n    }\n  ")}(e);default:throw Error("".concat(t.length,"-D input sampling")+" is not yet supported")}}(e,r),i=e.shapeInfo.logicalShape,c=n.logicalShape,i.length<=c.length&&(a?o+=function(e,n){var t,a=e.name,r=a.charAt(0).toUpperCase()+a.slice(1),o="get"+r+"AtOutCoords",i=e.shapeInfo.logicalShape.length,c=n.logicalShape.length,s=b(e.shapeInfo.logicalShape,n.logicalShape),u=getCoordsDataType(c),l=c-i,d=["x","y","z","w","u","v"];t=0===i?"":c<2&&s.length>=1?"coords = 0;":s.map(function(e){return"coords.".concat(d[e+l]," = 0;")}).join("\n");var h="";h=c<2&&i>0?"coords":e.shapeInfo.logicalShape.map(function(e,n){return"coords.".concat(d[n+l])}).join(", ");var f="return outputValue;",x=1===p.util.sizeFromShape(e.shapeInfo.logicalShape),m=1===p.util.sizeFromShape(n.logicalShape);if(1!==i||x||m){if(x&&!m)f=1===c?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(s.length){var g=i-2,v=i-1;s.indexOf(g)>-1&&s.indexOf(v)>-1?f="return vec4(outputValue.x);":s.indexOf(g)>-1?f="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":s.indexOf(v)>-1&&(f="return vec4(outputValue.xx, outputValue.zz);")}}else f="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return"\n    vec4 ".concat(o,"() {\n      ").concat(u," coords = getOutputCoords();\n      ").concat(t,"\n      vec4 outputValue = get").concat(r,"(").concat(h,");\n      ").concat(f,"\n    }\n  ")}(e,n):o+=function(e,n){var t,a=e.name,r=a.charAt(0).toUpperCase()+a.slice(1),o="get"+r+"AtOutCoords",i=n.texShape,c=e.shapeInfo.texShape,s=e.shapeInfo.logicalShape.length,u=n.logicalShape.length;if(!e.shapeInfo.isUniform&&s===u&&null==e.shapeInfo.flatOffset&&p.util.arraysEqual(c,i))return"\n      float ".concat(o,"() {\n        return sampleTexture(").concat(a,", resultUV);\n      }\n    ");var l=getCoordsDataType(u),d=b(e.shapeInfo.logicalShape,n.logicalShape),h=u-s,f=["x","y","z","w","u","v"];t=0===s?"":u<2&&d.length>=1?"coords = 0;":d.map(function(e){return"coords.".concat(f[e+h]," = 0;")}).join("\n");var x="";return x=u<2&&s>0?"coords":e.shapeInfo.logicalShape.map(function(e,n){return"coords.".concat(f[n+h])}).join(", "),"\n    float ".concat(o,"() {\n      ").concat(l," coords = getOutputCoords();\n      ").concat(t,"\n      return get").concat(r,"(").concat(x,");\n    }\n  ")}(e,n)),o}).join("\n"),s=n.texShape,u=getGlslDifferences(),l="\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ".concat(u.texture2D,"(textureSampler, uv).r;\n    }\n  "),d="".concat(u.version,"\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ").concat(u.varyingFs," vec2 resultUV;\n    ").concat(u.defineOutput,"\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ").concat(u.defineSpecialNaN,"\n    ").concat(u.defineSpecialInf,"\n    ").concat(u.defineRound,"\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ").concat("\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n","\n    ").concat("\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n","\n    ").concat("\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n","\n  ");return n.isPacked?(a=function(e,n,t){switch(e.length){case 0:return getOutputScalarCoords();case 1:var a;return 1===(a=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)])[0]?t?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ".concat(a[1],".0);\n      }\n    "):1===a[1]?t?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ".concat(a[0],".0);\n      }\n    "):t?"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ":"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(a[0],", ").concat(a[1],"));\n      return 2 * (resTexRC.x * ").concat(a[1]," + resTexRC.y);\n    }\n  ");case 2:return function(e,n,t){var a=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)];if(p.util.arraysEqual(e,n))return t?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(".concat(a[0],", ").concat(a[1],"));\n      }\n    ");var r=Math.ceil(e[1]/2);return t?"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ":"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(a[0],", ").concat(a[1],"));\n\n      int index = resTexRC.x * ").concat(a[1]," + resTexRC.y;\n      int r = 2 * (index / ").concat(r,");\n      int c = imod(index, ").concat(r,") * 2;\n\n      return ivec2(r, c);\n    }\n  ")}(e,n,t);case 3:return function(e,n,t){if(t)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";var a=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)],r=Math.ceil(e[2]/2),o=r*Math.ceil(e[1]/2);return"\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(a[0],", ").concat(a[1],"));\n      int index = resTexRC.x * ").concat(a[1]," + resTexRC.y;\n\n      int b = index / ").concat(o,";\n      index -= b * ").concat(o,";\n\n      int r = 2 * (index / ").concat(r,");\n      int c = imod(index, ").concat(r,") * 2;\n\n      return ivec3(b, r, c);\n    }\n  ")}(e,n,t);default:return function(e,n,t){if(t)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";for(var a=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)],r=Math.ceil(e[e.length-1]/2),o=r*Math.ceil(e[e.length-2]/2),i=o,c="",s="b, r, c",u=2;u<e.length-1;u++)i*=e[e.length-u-1],c="\n      int b".concat(u," = index / ").concat(i,";\n      index -= b").concat(u," * ").concat(i,";\n    ")+c,s="b".concat(u,", ")+s;return"\n    ivec".concat(e.length," getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(").concat(a[0],", ").concat(a[1],"));\n      int index = resTexRC.x * ").concat(a[1]," + resTexRC.y;\n\n      ").concat(c,"\n\n      int b = index / ").concat(o,";\n      index -= b * ").concat(o,";\n\n      int r = 2 * (index / ").concat(r,");\n      int c = imod(index, ").concat(r,") * 2;\n\n      return ivec").concat(e.length,"(").concat(s,");\n    }\n  ")}(e,n,t)}}(n.logicalShape,s,t.enableShapeUniforms),r="\n    void setOutput(vec4 val) {\n      ".concat(u.output," = val;\n    }\n  ")):(a=function(e,n,t){var a,r;switch(e.length){case 0:return getOutputScalarCoords();case 1:return 1===n[0]?t?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":"\n      int getOutputCoords() {\n        return int(resultUV.x * ".concat(n[1],".0);\n      }\n    "):1===n[1]?t?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":"\n      int getOutputCoords() {\n        return int(resultUV.y * ".concat(n[0],".0);\n      }\n    "):t?"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ":"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(n[0],", ").concat(n[1],"));\n      return resTexRC.x * ").concat(n[1]," + resTexRC.y;\n    }\n  ");case 2:return p.util.arraysEqual(e,n)?t?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(".concat(n[0],", ").concat(n[1],"));\n      }\n    "):1===e[1]?t?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(".concat(n[0],", ").concat(n[1],"));\n        int index = resTexRC.x * ").concat(n[1]," + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    "):1===e[0]?t?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(".concat(n[0],", ").concat(n[1],"));\n        int index = resTexRC.x * ").concat(n[1]," + resTexRC.y;\n        return ivec2(0, index);\n      }\n    "):t?"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ":"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(n[0],", ").concat(n[1],"));\n      int index = resTexRC.x * ").concat(n[1]," + resTexRC.y;\n      int r = index / ").concat(e[1],";\n      int c = index - r * ").concat(e[1],";\n      return ivec2(r, c);\n    }\n  ");case 3:return function(e,n,t){if(t){var a=getOutputLogicalCoordinatesFromFlatIndexByUniform(["r","c","d"],e);return"\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ".concat(a,"\n    return ivec3(r, c, d);\n  }\n")}var r=getLogicalCoordinatesFromFlatIndex(["r","c","d"],e);return"\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(n[0],", ").concat(n[1],"));\n      int index = resTexRC.x * ").concat(n[1]," + resTexRC.y;\n      ").concat(r,"\n      return ivec3(r, c, d);\n    }\n  ")}(e,n,t);case 4:return function(e,n,t){if(t){var a=getOutputLogicalCoordinatesFromFlatIndexByUniform(["r","c","d","d2"],e);return"\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ".concat(a,"\n      return ivec4(r, c, d, d2);\n    }\n  ")}var r=getLogicalCoordinatesFromFlatIndex(["r","c","d","d2"],e);return"\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(".concat(n[0],", ").concat(n[1],"));\n      int index = resTexRC.x * ").concat(n[1]," + resTexRC.y;\n      ").concat(r,"\n      return ivec4(r, c, d, d2);\n    }\n  ")}(e,n,t);case 5:return a=getLogicalCoordinatesFromFlatIndex(["r","c","d","d2","d3"],e),"\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(".concat(n[0],",\n                             ").concat(n[1],"));\n\n      int index = resTexRC.x * ").concat(n[1]," + resTexRC.y;\n\n      ").concat(a,"\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  ");case 6:return r=getLogicalCoordinatesFromFlatIndex(["r","c","d","d2","d3","d4"],e),"\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(".concat(n[0],", ").concat(n[1],"));\n      int index = resTexRC.x * ").concat(n[1]," + resTexRC.y;\n\n      ").concat(r,"\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  ");default:throw Error("".concat(e.length,"-D output sampling is not yet supported"))}}(n.logicalShape,s,t.enableShapeUniforms),r="\n    void setOutput(float val) {\n      ".concat(u.output," = vec4(val, 0, 0, 0);\n    }\n  ")),t.packedInputs&&(d+="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n"),[d,l,r,i,a,c,t.userCode].join("\n")}(t,r={logicalShape:x.shape,texShape:x.texData.texShape,isUniform:!1,isPacked:x.texData.isPacked,flatOffset:null},e),i=createFragmentShader(n.gl,o),c=n.createProgram(i),p.env().get("ENGINE_COMPILE_ONLY")?{program:e,fragmentShader:i,source:o,webGLProgram:c,inShapeInfos:a,outShapeInfo:r,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(n.buildVao(c),Object.assign({program:e,fragmentShader:i,source:o,webGLProgram:c,inShapeInfos:a,outShapeInfo:r},getUniformLocations(n,e,c)))}),v=null!=this.activeTimers;v&&(c=this.startTimer()),p.env().get("ENGINE_COMPILE_ONLY")||function(e,n,t,a,r){n.program.enableShapeUniforms||(validateBinaryAndProgram(n.inShapeInfos,t),validateBinaryAndProgram([n.outShapeInfo],[a]));var o=a.texData.texture,i=a.texData.texShape;a.texData.isPacked?e.setOutputPackedMatrixTexture(o.texture,i[0],i[1]):e.setOutputMatrixTexture(o.texture,i[0],i[1]),e.setProgram(n.webGLProgram),e.bindVertexArray(n.webGLProgram.vao),1===p.env().getNumber("WEBGL_VERSION")&&null!==n.infLoc&&e.gl.uniform1f(n.infLoc,1/0),null!==n.nanLoc&&e.gl.uniform1f(n.nanLoc,NaN);for(var c=0;c<t.length;++c){var s=t[c],u=n.variablesLocations[c],l=u.uniform,d=u.offset,h=u.shape,f=u.texShape;if(h){var x=getUniformInfoFromShape(n.program.packedInputs,s.shape,s.texData.texShape).uniformShape;switch(x.length){case 1:e.gl.uniform1iv(h,new Int32Array(x));break;case 2:e.gl.uniform2iv(h,new Int32Array(x));break;case 3:e.gl.uniform3iv(h,new Int32Array(x));break;case 4:e.gl.uniform4iv(h,new Int32Array(x))}}if(f&&e.gl.uniform2i(f,s.texData.texShape[0],s.texData.texShape[1]),null!=l){if(s.isUniform){if(2>p.util.sizeFromShape(s.shape))e.gl.uniform1f(l,s.uniformValues[0]);else{var m=s.uniformValues;m instanceof Float32Array||(m=new Float32Array(m)),e.gl.uniform1fv(l,m)}continue}null!=s.texData.slice&&null!=d&&e.gl.uniform1i(d,s.texData.slice.flatOffset),e.setInputMatrixTexture(s.texData.texture.texture,l,c)}}var g=n.outShapeLocation;if(g)switch(a.shape.length){case 1:e.gl.uniform1iv(g,new Int32Array(a.shape));break;case 2:e.gl.uniform2iv(g,new Int32Array(a.shape));break;case 3:e.gl.uniform3iv(g,new Int32Array(a.shape));break;case 4:e.gl.uniform4iv(g,new Int32Array(a.shape))}if(n.outShapeStridesLocation){var v=p.util.computeStrides(a.shape);switch(a.shape.length){case 2:e.gl.uniform1iv(n.outShapeStridesLocation,new Int32Array(v));break;case 3:e.gl.uniform2iv(n.outShapeStridesLocation,new Int32Array(v));break;case 4:e.gl.uniform3iv(n.outShapeStridesLocation,new Int32Array(v))}}if(n.outTexShapeLocation&&e.gl.uniform2i(n.outTexShapeLocation,a.texData.texShape[0],a.texData.texShape[1]),n.program.customUniforms&&r)for(var c=0;c<n.program.customUniforms.length;++c){var b=n.program.customUniforms[c],C=n.customUniformLocations[c],y=r[c];if("float"===b.type)e.gl.uniform1fv(C,y);else if("vec2"===b.type)e.gl.uniform2fv(C,y);else if("vec3"===b.type)e.gl.uniform3fv(C,y);else if("vec4"===b.type)e.gl.uniform4fv(C,y);else if("int"===b.type)e.gl.uniform1iv(C,y);else if("ivec2"===b.type)e.gl.uniform2iv(C,y);else if("ivec3"===b.type)e.gl.uniform3iv(C,y);else if("ivec4"===b.type)e.gl.uniform4iv(C,y);else throw Error("uniform type ".concat(b.type," is not supported yet."))}e.executeProgram()}(this.gpgpu,g,f,x,r),h.forEach(function(e){return s.disposeIntermediateTensorInfo(e)}),v&&(c=this.endTimer(c),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(c)}));var C=p.env().getNumber("WEBGL_FLUSH_THRESHOLD");if(C>0){var y=p.util.now();y-this.lastGlFlushTime>C&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=y)}if(!p.env().getBool("WEBGL_LAZILY_UNPACK")&&l.isPacked&&!1===o){var k=this.unpackTensor(u);return this.disposeIntermediateTensorInfo(u),k}return u},MathBackendWebGL.prototype.compileAndRun=function(e,n,t,a,r){return void 0===r&&(r=!1),t=t||n[0].dtype,this.runWebGLProgram(e,n,t,a,r)},MathBackendWebGL.prototype.getAndSaveBinary=function(e,n){return e in this.binaryCache||(this.binaryCache[e]=n()),this.binaryCache[e]},MathBackendWebGL.prototype.getTextureManager=function(){return this.textureManager},MathBackendWebGL.prototype.dispose=function(){var e=this;this.disposed||(p.env().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(function(n){e.gpgpu.deleteProgram(e.binaryCache[n].webGLProgram),delete e.binaryCache[n]}),this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)},MathBackendWebGL.prototype.floatPrecision=function(){var e=this;return null==this.floatPrecisionValue&&(this.floatPrecisionValue=p.tidy(function(){if(!p.env().get("WEBGL_RENDER_FLOAT32_ENABLED")){var n=p.env().getBool("DEBUG");p.env().set("DEBUG",!1);var t=e.abs(p.scalar(1e-8)).dataSync()[0];if(p.env().set("DEBUG",n),t>0)return 32}return 16})),this.floatPrecisionValue},MathBackendWebGL.prototype.epsilon=function(){return 32===this.floatPrecision()?1e-7:1e-4},MathBackendWebGL.prototype.uploadToGPU=function(e){var n,t,a=this.texData.get(e),o=a.shape,i=a.dtype,c=a.values,s=a.texture,u=a.usage,l=a.isPacked;if(null==s){var d=null!=this.activeTimers;d&&(t=p.util.now());var h=a.texShape;if(null==h&&(h=getTextureShapeFromLogicalShape(o,l),a.texShape=h),null!=c){var f=getShapeAs3D(o),x=void 0,m=h[1],g=h[0],v=c instanceof Uint8Array||c instanceof Uint8ClampedArray;(l||!v)&&(m=(n=__read(getPackedMatrixTextureShapeWidthHeight(h[0],h[1]),2))[0],g=n[1]),x=l?new EncodeMatrixPackedProgram(f,v):new EncodeMatrixProgram(f,v);var b=v?[g,m]:h,C=this.makeTensorInfo(b,i),y=this.texData.get(C.dataId);v?y.usage=r.PIXELS:y.usage=r.UPLOAD,y.texShape=b,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(C.dataId),m,g,c);var k=[[g,m]],I=this.runWebGLProgram(x,[C],i,k,!0),T=this.texData.get(I.dataId);a.texShape=T.texShape,a.isPacked=T.isPacked,a.usage=T.usage,p.env().get("ENGINE_COMPILE_ONLY")?this.disposeData(I.dataId):(a.texture=T.texture,a.values=null,this.texData.delete(I.dataId)),this.disposeIntermediateTensorInfo(C),d&&(this.uploadWaitMs+=p.util.now()-t)}else{var S=this.acquireTexture(h,u,i,l);a.texture=S}}},MathBackendWebGL.prototype.convertAndCacheOnCPU=function(e,n){var t=this.texData.get(e),a=t.dtype;return null!=n&&(t.values=function(e,n){if("float32"===n||"complex64"===n)return e;if("int32"===n||"bool"===n){for(var t="int32"===n?new Int32Array(e.length):new Uint8Array(e.length),a=0;a<t.length;++a)t[a]=Math.round(e[a]);return t}throw Error("Unknown dtype ".concat(n))}(n,a)),t.values},MathBackendWebGL.prototype.acquireTexture=function(e,n,t,a){if(this.numBytesInGPU+=this.computeBytes(e,t),!this.warnedAboutMemory&&this.numBytesInGPU>1048576*this.numMBBeforeWarning){var r=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn("High memory usage in GPU: ".concat(r," MB, ")+"most likely due to a memory leak")}return this.textureManager.acquireTexture(e,n,a)},MathBackendWebGL.prototype.computeBytes=function(e,n){return e[0]*e[1]*p.util.bytesPerElement(n)},MathBackendWebGL.prototype.checkCompileCompletion=function(){var e,n;try{for(var t=__values(Object.entries(this.binaryCache)),a=t.next();!a.done;a=t.next()){var r=__read(a.value,2)[1];this.checkCompletion_(r)}}catch(n){e={error:n}}finally{try{a&&!a.done&&(n=t.return)&&n.call(t)}finally{if(e)throw e.error}}},MathBackendWebGL.prototype.checkCompileCompletionAsync=function(){return __awaiter(this,void 0,void 0,function(){var e,n,t,a,r,o,i,c,s,u,l,d=this;return __generator(this,function(p){if(e=[],this.gpgpu.parallelCompilationExtension){try{for(t=(n=__values(Object.entries(this.binaryCache))).next();!t.done;t=n.next())a=__read(t.value,2)[1],e.push(this.checkCompletionAsync_(a))}catch(e){c={error:e}}finally{try{t&&!t.done&&(s=n.return)&&s.call(n)}finally{if(c)throw c.error}}return[2,Promise.all(e)]}r=function(n){var t=new Promise(function(e){try{d.checkCompletion_(n),e(!0)}catch(e){throw e}});e.push(t)};try{for(i=(o=__values(Object.entries(this.binaryCache))).next();!i.done;i=o.next())a=__read(i.value,2)[1],r(a)}catch(e){u={error:e}}finally{try{i&&!i.done&&(l=o.return)&&l.call(o)}finally{if(u)throw u.error}}return[2,Promise.all(e)]})})},MathBackendWebGL.prototype.checkCompletionAsync_=function(e){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(n){switch(n.label){case 0:if(!this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR))return[3,1];return[2,this.checkCompletion_(e)];case 1:return[4,p.nextFrame()];case 2:return n.sent(),[2,this.checkCompletionAsync_(e)]}})})},MathBackendWebGL.prototype.checkCompletion_=function(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)){if(console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS))throw logShaderSourceAndInfoLog(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),Error("Failed to compile fragment shader.");throw Error("Failed to link vertex and fragment shaders.")}return!0},MathBackendWebGL.prototype.getUniformLocations=function(){var e,n;try{for(var t=__values(Object.values(this.binaryCache)),a=t.next();!a.done;a=t.next()){var r=a.value;this.gpgpu.buildVao(r.webGLProgram);var o=getUniformLocations(this.gpgpu,r.program,r.webGLProgram),i=o.variablesLocations,c=o.customUniformLocations,s=o.infLoc,u=o.nanLoc,l=o.outShapeLocation,d=o.outShapeStridesLocation,p=o.outTexShapeLocation;r.variablesLocations=i,r.customUniformLocations=c,r.infLoc=s,r.nanLoc=u,r.outShapeLocation=l,r.outShapeStridesLocation=d,r.outTexShapeLocation=p}}catch(n){e={error:n}}finally{try{a&&!a.done&&(n=t.return)&&n.call(t)}finally{if(e)throw e.error}}},MathBackendWebGL.prototype.createTensorFromGPUData=function(e,n,t){e.channels=e.channels||"RGBA";var a=e.texture,r=e.height,o=e.width,i=e.channels,c=p.engine().backend;if(!c.gpgpu.gl.isTexture(a))throw Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");var s=c.writeTexture(a,n,t,r,o,i);return p.engine().makeTensorFromDataId(s,n,t,c)},MathBackendWebGL}(p.KernelBackend);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function forceHalfFloat(){p.env().set("WEBGL_FORCE_F16_TEXTURES",!0)}et.nextDataId=0,p.device_util.isBrowser()&&p.registerBackend("webgl",function(){return new et},2);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var ea="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n",BinaryOpProgram=function(e,n,t){this.variableNames=["A","B"],this.outputShape=p.backend_util.assertAndGetBroadcastShape(n,t),this.enableShapeUniforms=useShapeUniforms(this.outputShape.length),this.userCode="\n      float binaryOperation(float a, float b) {\n        ".concat(e,"\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    ")},er="\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n",BinaryOpPackedProgram=function(e,n,t,a){void 0===a&&(a=!1),this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=p.backend_util.assertAndGetBroadcastShape(n,t);var r=this.outputShape.length;this.enableShapeUniforms=useShapeUniforms(r);var o="";if(a){if(0===r||1===p.util.sizeFromShape(this.outputShape))o="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else{var i=getCoordsDataType(r);if(o="\n          ".concat(i," coords = getOutputCoords();\n        "),1===r)this.enableShapeUniforms?o+="\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":o+="\n            result.y = (coords + 1) >= ".concat(this.outputShape[0]," ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ");else{var c=getChannels("coords",r);this.enableShapeUniforms?o+="\n            bool nextRowOutOfBounds =\n              (".concat(c[r-2]," + 1) >= outShape[").concat(r," - 2];\n            bool nextColOutOfBounds =\n              (").concat(c[r-1]," + 1) >= outShape[").concat(r," - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          "):o+="\n            bool nextRowOutOfBounds =\n              (".concat(c[r-2]," + 1) >= ").concat(this.outputShape[r-2],";\n            bool nextColOutOfBounds =\n              (").concat(c[r-1]," + 1) >= ").concat(this.outputShape[r-1],";\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          ")}}}this.userCode="\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ".concat(e,"\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ").concat(o,"\n\n        setOutput(result);\n      }\n    ")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function identity(e){var n=e.inputs,t=e.backend,a=n.x;return t.incRef(a.dataId),{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}var eo={kernelName:p.Identity,backendName:"webgl",kernelFunc:identity};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function complex(e){var n=e.inputs,t=e.backend,a=n.real,r=n.imag,o=t.makeTensorInfo(a.shape,"complex64"),i=t.texData.get(o.dataId),c=identity({inputs:{x:a},backend:t}),s=identity({inputs:{x:r},backend:t});return i.complexTensorInfos={real:c,imag:s},o}var ei={kernelName:p.Complex,backendName:"webgl",kernelFunc:complex},ec="return (a < 0.) ? b * a : a;",es="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",eu={kernelName:p.LeakyRelu,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.x,o=a.alpha,i=t.makeTensorInfo([],"float32",p.util.createScalarValue(o,"float32")),c=p.env().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new BinaryOpPackedProgram(es,r.shape,i.shape):new BinaryOpProgram(ec,r.shape,i.shape),s=t.runWebGLProgram(c,[r,i],"float32");return t.disposeIntermediateTensorInfo(i),s}},el="return (a < 0.) ? b * a : a;",ed="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",ep={kernelName:p.Prelu,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=n.x,r=n.alpha,o=p.env().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new BinaryOpPackedProgram(ed,a.shape,r.shape):new BinaryOpProgram(el,a.shape,r.shape);return t.runWebGLProgram(o,[a,r],"float32")}},eh="if (isnan(x)) return x;";function unaryKernelFunc(e){var n=e.opSnippet,t=e.packedOpSnippet,a=e.cpuKernelImpl,r=e.dtype;return function(e){var o,i=e.inputs,c=e.backend,s=i.x,u=r||s.dtype;if(c.shouldExecuteOnCPU([s])&&null!=a){var l=a(c.texData.get(s.dataId).values,u);return c.makeTensorInfo(s.shape,u,l)}return o=p.env().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=t?new UnaryOpPackedProgram(s.shape,t):new UnaryOpProgram(s.shape,n),c.runWebGLProgram(o,[s],u)}}function binaryKernelFunc(e){var n=e.opSnippet,t=e.packedOpSnippet,a=e.checkOutOfBounds,r=void 0!==a&&a,o=e.supportsComplex,i=void 0!==o&&o,c=e.cpuKernelImpl,s=e.dtype;return function(e){var a,o=e.inputs,u=e.backend,l=o.a,d=o.b;if(i&&"complex64"===l.dtype){var h=u.texData.get(l.dataId),f=u.texData.get(d.dataId),x=__read([[h.complexTensorInfos.real,f.complexTensorInfos.real],[h.complexTensorInfos.imag,f.complexTensorInfos.imag]].map(function(e){var t=__read(e,2),a=t[0],r=t[1],o={dataId:a.dataId,dtype:a.dtype,shape:l.shape},i={dataId:r.dataId,dtype:r.dtype,shape:d.shape},c=new BinaryOpProgram(n,l.shape,d.shape);return u.runWebGLProgram(c,[o,i],p.upcastType(a.dtype,r.dtype))}),2),m=x[0],g=x[1],v=complex({inputs:{real:m,imag:g},backend:u});return u.disposeIntermediateTensorInfo(m),u.disposeIntermediateTensorInfo(g),v}var b=s||p.upcastType(l.dtype,d.dtype);if(("string"===l.dtype||"string"===d.dtype||u.shouldExecuteOnCPU([l,d]))&&null!=c){var C=u.texData.get(l.dataId).values,y=u.texData.get(d.dataId).values,k="string"===l.dtype?p.backend_util.fromUint8ToStringArray(C):C,I="string"===l.dtype?p.backend_util.fromUint8ToStringArray(y):y,T=__read(c(l.shape,d.shape,k,I,b),2),S=T[0],R=T[1],w=u.makeTensorInfo(R,b);return u.texData.get(w.dataId).values=S,w}return a=p.env().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=t?new BinaryOpPackedProgram(t,l.shape,d.shape,r):new BinaryOpProgram(n,l.shape,d.shape),u.runWebGLProgram(a,[l,d],b)}}function mapActivationToShaderProgram(e,n){if(void 0===n&&(n=!1),"linear"===e)return"return x;";if("relu"===e)return n?"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":Q;if("elu"===e)return n?"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n":"return (x >= 0.0) ? x : (exp(x) - 1.0);";if("relu6"===e)return n?"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":Z;if("prelu"===e)return n?ed:el;if("leakyrelu"===e)return n?es:ec;if("sigmoid"===e)return"return 1.0 / (1.0 + exp(-1.0 * x));";throw Error("Activation ".concat(e," has not been implemented for the WebGL backend."))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var MatMulPackedProgram=function(e,n,t,a,r,o,i,c,s){void 0===a&&(a=!1),void 0===r&&(r=!1),void 0===o&&(o=!1),void 0===i&&(i=null),void 0===c&&(c=!1),void 0===s&&(s=!1),this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.enableShapeUniforms=useShapeUniforms(this.outputShape.length);var u=Math.ceil((a?e[1]:e[2])/2),l=a?"i * 2, rc.y":"rc.y, i * 2",d=r?"rc.z, i * 2":"i * 2, rc.z",p=a?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],h=r?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],f="",x="";i&&(f=c?"vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ".concat(i,"\n        }"):s?"vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ".concat(i,"\n        }"):"vec4 activation(vec4 x) {\n          ".concat(i,"\n        }"),x="result = activation(result);");var m=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),c&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha");var g="rc.x",v="rc.x";e[0]<n[0]?g="imod(rc.x, ".concat(e[0],")"):n[0]<e[0]&&(v="imod(rc.x, ".concat(n[0],")")),this.userCode="\n      ".concat(f,"\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ").concat(u,".0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        int batchA = ").concat(g,";\n        int batchB = ").concat(v,";\n        for (int i = 0; i < ").concat(u,"; i++) {\n          vec4 a = getMatrixA(batchA, ").concat(l,");\n          vec4 b = getMatrixB(batchB, ").concat(d,");\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (").concat(p[0]," * ").concat(h[0],");\n          result += (").concat(p[1]," * ").concat(h[1],");\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ").concat(m,"\n\n        ").concat(x,"\n\n        setOutput(result);\n      }\n    ")},ef={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"},BinaryOpComplexProgram=function(e,n,t){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=p.backend_util.assertAndGetBroadcastShape(n,t),this.userCode="\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ".concat(e,"\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    ")},ex="return a * b;";function multiply(e){var n,t=e.inputs,a=e.backend,r=t.a,o=t.b,i=p.backend_util.upcastType(r.dtype,o.dtype);if("complex64"===r.dtype){var c=a.texData.get(r.dataId),s=a.texData.get(o.dataId),u=new BinaryOpComplexProgram(ef.REAL,r.shape,o.shape),l=new BinaryOpComplexProgram(ef.IMAG,r.shape,o.shape),d=[{dataId:c.complexTensorInfos.real.dataId,dtype:c.complexTensorInfos.real.dtype,shape:r.shape},{dataId:c.complexTensorInfos.imag.dataId,dtype:c.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:s.complexTensorInfos.real.dataId,dtype:s.complexTensorInfos.real.dtype,shape:o.shape},{dataId:s.complexTensorInfos.imag.dataId,dtype:s.complexTensorInfos.imag.dtype,shape:o.shape}],h=a.runWebGLProgram(u,d,"float32"),f=a.runWebGLProgram(l,d,"float32"),x=complex({inputs:{real:h,imag:f},backend:a});return a.disposeIntermediateTensorInfo(h),a.disposeIntermediateTensorInfo(f),x}if(a.shouldExecuteOnCPU([r,o])){var c=a.texData.get(r.dataId),s=a.texData.get(o.dataId),m=__read(L(r.shape,o.shape,c.values,s.values,i),2),g=m[0],v=m[1],b=a.makeTensorInfo(v,i);return a.texData.get(b.dataId).values=g,b}return n=p.env().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new BinaryOpPackedProgram(ex,r.shape,o.shape):new BinaryOpProgram(ex,r.shape,o.shape),a.runWebGLProgram(n,[r,o],i)}var em={kernelName:p.Multiply,backendName:"webgl",kernelFunc:multiply};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function reshape(e){var n,t,a,r,o,i,c=e.inputs,s=e.backend,u=e.attrs,l=c.x,d=u.shape,h=p.util.sizeFromShape(l.shape),f=p.util.inferFromImplicitShape(d,h),x=p.util.sizeFromShape(f);p.util.assert(h===x,function(){return"The new shape (".concat(f,") has ").concat(x," elements and the old ")+"shape (".concat(l.shape,") has ").concat(h," elements. The new shape and old ")+"shape must have the same number of elements."});var m=s.texData.get(l.dataId);return!m.isPacked||isReshapeFree(l.shape,f)||null!==m.texture&&isReshapeFree(m.shape,f)?(s.incRef(l.dataId),{dataId:l.dataId,shape:f,dtype:l.dtype}):(n=__spreadArray([getBatchDim(l.shape)],__read(getRowsCols(l.shape)),!1),t={dtype:l.dtype,shape:n,dataId:l.dataId},a=__spreadArray([getBatchDim(f)],__read(getRowsCols(f)),!1),r=new ReshapePackedProgram(a,n),o=[n],{dataId:(i=s.runWebGLProgram(r,[t],l.dtype,o,!0)).dataId,shape:f,dtype:i.dtype})}var eg={kernelName:p.Reshape,backendName:"webgl",kernelFunc:reshape},MeanProgram=function(e,n){this.variableNames=["x"];var t=e.windowSize,a=e.batchSize,r=e.inSize,o=e.outSize;this.outputShape=[a,o];var i=4*Math.floor(t/4),c=t%4,s="sumValue += dot(values, ones);";if(null!=n){var u=1/n;s="sumValue += dot(values * ".concat(p.util.isInt(u)?u.toPrecision(2):u,", ones);")}var l="";r%t>0&&(l="\n        if (inIdx < 0 || inIdx >= ".concat(r,") {\n          return 0.0;\n        }\n      ")),this.userCode="\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ".concat(l,"\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ").concat(t,";\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ").concat(i,"; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ").concat(s,"\n        }\n\n        int inIdx = inOffset + ").concat(i,";\n        if (").concat(1===c,") {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ").concat(s,"\n        } else if (").concat(2===c,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ").concat(s,"\n        } else if (").concat(3===c,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ").concat(s,"\n        }\n        setOutput(sumValue);\n      }\n    ")},ReduceProgram=function(e,n){this.variableNames=["x"];var t=e.windowSize,a=e.batchSize,r=e.inSize,o=e.outSize;this.outputShape=[a,o];var i="0.0",c="";"prod"===n?i="1.0":"min"===n?(i="1.0 / 1e-20",c="min"):"max"===n&&(i="-1.0 / 1e-20",c="max");var s="".concat(n,"(").concat(n,"(").concat(n,"(")+"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"sum"===n?s="sumValue":"prod"===n?s="prodValue":"all"===n?s="allValue":"any"===n&&(s="anyValue");var u=4*Math.floor(t/4),l=t%4,d="\n      if (".concat("sum"===n,") {\n        sumValue += dot(values, ones);\n      } else if (").concat("prod"===n,") {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ").concat(c,"(values, minMaxValue);\n        if (").concat("min"===n," || ").concat("max"===n,") {\n          minMaxValue = ").concat(c,"(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    "),p="vec4";"all"===n?(i="1.0",d="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",p="bvec4"):"any"===n&&(i="0.0",d="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",p="bvec4");var h="";r%t>0&&(h="\n        if (inIdx < 0 || inIdx >= ".concat(r,") {\n          return initializationValue;\n        }\n      ")),this.userCode="\n      const float initializationValue = ".concat(i,";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ").concat(h,"\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ").concat(t,";\n\n        vec4 minMaxValue = vec4(").concat(i,");\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ").concat(u,"; i += 4) {\n          int inIdx = inOffset + i;\n          ").concat(p," values = ").concat(p,"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ").concat(d,"\n        }\n\n        int inIdx = inOffset + ").concat(u,";\n        if (").concat(1===l,") {\n          ").concat(p," values = ").concat(p,"(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ").concat(d,"\n        } else if (").concat(2===l,") {\n          ").concat(p," values = ").concat(p,"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ").concat(d,"\n        } else if (").concat(3===l,") {\n          ").concat(p," values = ").concat(p,"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ").concat(d,"\n        }\n        setOutput(").concat(s,");\n      }\n    ")};function reduce(e,n,t,a){for(var r=/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){for(var n=[];0===n.length||1!==n[n.length-1].outSize;){var t=n.length?n[n.length-1].outSize:e[1],a=p.backend_util.computeOptimalWindowSize(t);n.push({inSize:t,windowSize:a,outSize:Math.ceil(t/a)})}return n}(e.shape),o=e,i=0;i<r.length;i++){var c=r[i],s=c.inSize,u=c.windowSize,l=c.outSize,d=void 0,h=void 0;d="mean"===t?0===i?new MeanProgram({windowSize:u,inSize:s,batchSize:e.shape[0],outSize:l},s):new MeanProgram({windowSize:u,inSize:s,batchSize:e.shape[0],outSize:l}):new ReduceProgram({windowSize:u,inSize:s,batchSize:e.shape[0],outSize:l},t),h=o,o=a.runWebGLProgram(d,[o],n),h.dataId!==e.dataId&&a.disposeIntermediateTensorInfo(h)}return o}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var TransposeProgram=function(e,n){this.variableNames=["A"];for(var t=Array(e.length),a=0;a<t.length;a++)t[a]=e[n[a]];this.outputShape=t,this.rank=t.length;var r=getCoordsDataType(this.rank),o=function(e){var n=e.length;if(n>6)throw Error("Transpose for rank ".concat(n," is not yet supported"));for(var t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],a=Array(n),r=0;r<e.length;r++)a[e[r]]=t[r];return a.join()}(n);this.userCode="\n    void main() {\n      ".concat(r," resRC = getOutputCoords();\n      setOutput(getA(").concat(o,"));\n    }\n    ")},TransposePackedProgram=function(e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;for(var t=Array(e.length),a=0;a<t.length;a++)t[a]=e[n[a]];if(this.outputShape=t,this.rank=t.length,this.rank>6)throw Error("Packed transpose for rank ".concat(this.rank," is not yet supported."));for(var r=getCoordsDataType(this.rank),o=getVecChannels("rc",this.rank),i=Array(this.rank),a=0;a<n.length;a++)i[n[a]]=o[a];var c="vec2(".concat(i.slice(-2).join(),")"),s="++".concat(o[this.rank-1]," < ").concat(t[this.rank-1]),u="getChannel(getA(".concat(i.join(),"), ").concat(c,")");this.userCode="\n    void main() {\n      ".concat(r," rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ").concat(u,";\n      if(").concat(s,") {\n        result[1] = ").concat(u,";\n      }\n      --").concat(o[this.rank-1],";\n      if(++").concat(o[this.rank-2]," < ").concat(t[this.rank-2],") {\n        result[2] = ").concat(u,";\n        if(").concat(s,") {\n          result[3] = ").concat(u,";\n        }\n      }\n      setOutput(result);\n    }\n    ")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function transposeImpl(e,n,t){var a=p.env().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new TransposePackedProgram(e.shape,n):new TransposeProgram(e.shape,n);return t.runWebGLProgram(a,[e],e.dtype)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sum(e){var n,t,a,r,o,i,c,s,u,l,d,h,f,x,m=e.inputs,g=e.backend,v=e.attrs,b=m.x,C=v.axis,y=v.keepDims;return n=b.shape.length,a=t=p.util.parseAxisParam(C,b.shape),o=null!=(r=p.backend_util.getAxesPermutation(a,n)),i=b,o&&(i=transposeImpl(b,r,g),a=p.backend_util.getInnerMostAxes(a.length,n)),p.backend_util.assertAxesAreInnerMostDims("sum",a,n),s=(c=__read(p.backend_util.computeOutAndReduceShapes(i.shape,a),2))[0],u=c[1],l=s,y&&(l=p.backend_util.expandShapeToKeepDim(s,t)),d=p.util.sizeFromShape(u),f=reduce(h=reshape({inputs:{x:i},attrs:{shape:[p.util.sizeFromShape(b.shape)/d,d]},backend:g}),p.sumOutType(b.dtype),"sum",g),x=reshape({inputs:{x:f},attrs:{shape:l},backend:g}),g.disposeIntermediateTensorInfo(h),g.disposeIntermediateTensorInfo(f),o&&g.disposeIntermediateTensorInfo(i),x}var ev={kernelName:p.Sum,backendName:"webgl",kernelFunc:sum};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function transpose(e){for(var n,t=e.inputs,a=e.backend,r=e.attrs,o=t.x,i=r.perm,c=Array(o.shape.length),s=0;s<c.length;s++)c[s]=o.shape[i[s]];if(a.shouldExecuteOnCPU([o])){var u=transposeImplCPU(a.texData.get(o.dataId).values,o.shape,o.dtype,i,c);n=a.makeTensorInfo(c,o.dtype),a.texData.get(n.dataId).values=u}else n=transposeImpl(o,i,a);return n}var eb={kernelName:p.Transpose,backendName:"webgl",kernelFunc:transpose};function batchMatMulImpl(e){var n,t,a,r=e.a,o=e.b,i=e.transposeA,c=e.transposeB,s=e.backend,u=e.bias,l=void 0===u?null:u,d=e.preluActivationWeights,h=void 0===d?null:d,f=e.leakyreluAlpha,x=e.activation,m=void 0===x?null:x,g=r.shape.length,v=o.shape.length,b=i?r.shape[g-2]:r.shape[g-1],C=c?o.shape[v-1]:o.shape[v-2],y=i?r.shape[g-1]:r.shape[g-2],k=c?o.shape[v-2]:o.shape[v-1],I=r.shape.slice(0,-2),T=o.shape.slice(0,-2),S=p.util.sizeFromShape(I),R=p.util.sizeFromShape(T),w=p.broadcast_util.assertAndGetBroadcastShape(r.shape.slice(0,-2),o.shape.slice(0,-2)).concat([y,k]);p.util.assert(b===C,function(){return"Error in matMul: inner shapes (".concat(b,") and (")+"".concat(C,") of Tensors with shapes ").concat(r.shape," and ")+"".concat(o.shape," and transposeA=").concat(i)+" and transposeB=".concat(c," must match.")});var P=i?[S,b,y]:[S,y,b],_=c?[R,k,C]:[R,C,k],E=reshape({inputs:{x:r},backend:s,attrs:{shape:P}}),F=reshape({inputs:{x:o},backend:s,attrs:{shape:_}}),N=[E,F],A=Math.max(S,R),O=i?E.shape[1]:E.shape[2],D=null!=l,L=null!=h,B="leakyrelu"===m,U=null!=m?mapActivationToShaderProgram(m,!0):null,G=D||L||B||null!=U;if((1===y||1===k)&&O>1e3&&!1===G){var M=E,W=F;i&&(M=transpose({inputs:{x:E},backend:s,attrs:{perm:[0,2,1]}}),N.push(M)),c&&(W=transpose({inputs:{x:F},backend:s,attrs:{perm:[0,2,1]}}),N.push(W));var V=1!==k,z=1===k,X=M;V&&(X=reshape({inputs:{x:M},backend:s,attrs:{shape:[A,O,1]}}),N.push(X));var H=1===k?2:1,K=W;z&&(K=reshape({inputs:{x:W},backend:s,attrs:{shape:[A,1,O]}}),N.push(K));var j=multiply({inputs:{a:X,b:K},backend:s});a=sum({inputs:{x:j},backend:s,attrs:{axis:H,keepDims:!0}}),N.push(j)}else{var q=p.upcastType(r.dtype,o.dtype),Y=new MatMulPackedProgram(P,_,[A,y,k],i,c,D,U,L,B),Q=[E,F];if(null!=l&&Q.push(l),L&&Q.push(h),B){var Z=s.makeTensorInfo([],"float32",p.util.createScalarValue(void 0===f?0:f,"float32"));Q.push(Z),N.push(Z)}a=s.runWebGLProgram(Y,Q,q)}var J=reshape({inputs:{x:a},backend:s,attrs:{shape:w}});N.push(a);try{for(var $=__values(N),ee=$.next();!ee.done;ee=$.next()){var en=ee.value;s.disposeIntermediateTensorInfo(en)}}catch(e){n={error:e}}finally{try{ee&&!ee.done&&(t=$.return)&&t.call($)}finally{if(n)throw n.error}}return J}var eC={kernelName:p._FusedMatMul,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.a,o=n.b,i=n.bias,c=n.preluActivationWeights,s=a.transposeA,u=a.transposeB,l=a.activation;return batchMatMulImpl({a:r,b:o,transposeA:s,transposeB:u,backend:t,bias:i,preluActivationWeights:c,leakyreluAlpha:a.leakyreluAlpha,activation:l})}},ey="return abs(x);",ek={kernelName:p.Abs,backendName:"webgl",kernelFunc:function(e){var n,t=e.inputs,a=e.backend,r=t.x;if(a.shouldExecuteOnCPU([r])&&"complex64"!==r.dtype){var o=simpleAbsImplCPU(a.texData.get(r.dataId).values);return a.makeTensorInfo(r.shape,r.dtype,o)}return n=p.env().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new UnaryOpPackedProgram(r.shape,ey):new UnaryOpProgram(r.shape,ey),a.runWebGLProgram(n,[r],r.dtype)}},eI=unaryKernelFunc({opSnippet:q+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),eT={kernelName:p.Acos,backendName:"webgl",kernelFunc:eI},eS=unaryKernelFunc({opSnippet:q+"\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),eR={kernelName:p.Acosh,backendName:"webgl",kernelFunc:eS},ew="return a + b;",eP=binaryKernelFunc({opSnippet:ew,packedOpSnippet:ew,supportsComplex:!0,cpuKernelImpl:k}),e_={kernelName:p.Add,backendName:"webgl",kernelFunc:eP},AddNProgram=function(e,n){this.outputShape=[],this.outputShape=e,this.variableNames=n.map(function(e,n){return"T".concat(n)});var t=[];this.variableNames.forEach(function(e){t.push("float v".concat(e," = get").concat(e,"AtOutCoords();"))});var a=this.variableNames.map(function(e){return"v".concat(e)}).join(" + ");this.userCode="\n      void main() {\n        ".concat(t.join("\n        "),"\n\n        float result = ").concat(a,";\n        setOutput(result);\n      }\n    ")},AddNPackedProgram=function(e,n){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=n.map(function(e,n){return"T".concat(n)});var t=[];this.variableNames.forEach(function(e){t.push("vec4 v".concat(e," = get").concat(e,"AtOutCoords();"))});var a=this.variableNames.map(function(e){return"v".concat(e)}).join(" + ");this.userCode="\n      void main() {\n        ".concat(t.join("\n        "),"\n\n        vec4 result = ").concat(a,";\n        setOutput(result);\n      }\n    ")},eE={kernelName:p.AddN,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function addN(e){var n=e.inputs,t=e.backend;if(1===n.length)return identity({inputs:{x:n[0]},backend:t});if(n.length>p.env().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){var a=Math.floor(n.length/2),r=addN({inputs:n.slice(0,a),backend:t}),o=addN({inputs:n.slice(a),backend:t});return addN({inputs:[r,o],backend:t})}var i=n.map(function(e){return e.dtype}).reduce(function(e,n){return p.upcastType(e,n)}),c=n.map(function(e){return e.shape}),s=p.env().getBool("WEBGL_PACK")?new AddNPackedProgram(n[0].shape,c):new AddNProgram(n[0].shape,c);return t.runWebGLProgram(s,n,i)}},eF={kernelName:p.All,backendName:"webgl",kernelFunc:function(e){var n,t=e.inputs,a=e.backend,r=e.attrs,o=t.x,i=r.axis,c=r.keepDims,s=o.shape.length,u=p.util.parseAxisParam(i,o.shape),l=u,d=p.backend_util.getAxesPermutation(l,s),h=o;null!=d&&(h=transpose({inputs:{x:o},backend:a,attrs:{perm:d}}),l=p.backend_util.getInnerMostAxes(l.length,s)),p.backend_util.assertAxesAreInnerMostDims("all",l,s);var f=__read(p.backend_util.computeOutAndReduceShapes(h.shape,l),2),x=f[0],m=f[1],g=reshape({inputs:{x:h},backend:a,attrs:{shape:[-1,p.util.sizeFromShape(m)]}}),v=reduce(g,g.dtype,"all",a);return n=c?reshape({inputs:{x:v},backend:a,attrs:{shape:p.backend_util.expandShapeToKeepDim(x,u)}}):reshape({inputs:{x:v},backend:a,attrs:{shape:x}}),a.disposeIntermediateTensorInfo(g),a.disposeIntermediateTensorInfo(v),null!=d&&a.disposeIntermediateTensorInfo(h),n}},eN={kernelName:p.Any,backendName:"webgl",kernelFunc:function(e){var n,t=e.inputs,a=e.backend,r=e.attrs,o=t.x,i=r.axis,c=r.keepDims,s=o.shape.length,u=p.util.parseAxisParam(i,o.shape),l=u,d=p.backend_util.getAxesPermutation(l,s),h=o;null!=d&&(h=transpose({inputs:{x:o},backend:a,attrs:{perm:d}}),l=p.backend_util.getInnerMostAxes(l.length,s)),p.backend_util.assertAxesAreInnerMostDims("any",l,s);var f=__read(p.backend_util.computeOutAndReduceShapes(h.shape,l),2),x=f[0],m=f[1],g=reshape({inputs:{x:h},backend:a,attrs:{shape:[-1,p.util.sizeFromShape(m)]}}),v=reduce(g,g.dtype,"any",a);return n=c?reshape({inputs:{x:v},backend:a,attrs:{shape:p.backend_util.expandShapeToKeepDim(x,u)}}):reshape({inputs:{x:v},backend:a,attrs:{shape:x}}),a.disposeIntermediateTensorInfo(g),a.disposeIntermediateTensorInfo(v),null!=d&&a.disposeIntermediateTensorInfo(h),n}},ArgMinMaxProgram=function(e,n,t){this.variableNames=["A"];var a=e.windowSize,r=e.batchSize,o=e.outSize;t||this.variableNames.push("bestIndicesA"),this.outputShape=[r,o],this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ".concat(a,";\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ").concat(a,"; i++) {\n          int inIdx = ").concat(t?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));",";\n          float candidate = getA(batch, inIdx);\n          if (candidate ").concat("max"===n?">":"<"," bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    ")},ArgMinMaxPackedProgram=function(e,n,t,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,p.util.assert(e.length>2,function(){return"Packed arg".concat(t.charAt(0).toUpperCase()+t.slice(1)," supports only inputs with rank above 2.")});var r,o,i=Math.ceil(e[e.length-1]/n);this.outputShape=e.slice(0,-1),i>1&&this.outputShape.push(i),a||this.variableNames.push("bestIndicesA");var c=this.outputShape,s=c.length,u=getCoordsDataType(s),l=getChannels("coords",s);if(1===i){var d=getCoordsDataType(o=s+1);r="\n        ".concat(d," sourceLocR = ").concat(d,"(").concat(l.join(),", 0);\n        ++").concat(l[s-1],";\n        ").concat(d," sourceLocG = ").concat(d,"(").concat(l.join(),", 0);\n        ++").concat(l[s-2],";\n        ").concat(d," sourceLocA = ").concat(d,"(").concat(l.join(),", 0);\n        --").concat(l[s-1],";\n        ").concat(d," sourceLocB = ").concat(d,"(").concat(l.join(),", 0);\n        --").concat(l[s-2],";")}else o=s,r="\n        ".concat(u," sourceLocR = coords;\n        ++").concat(l[s-1],";\n        ").concat(u," sourceLocG = coords;\n        ++").concat(l[s-2],";\n        ").concat(u," sourceLocA = coords;\n        --").concat(l[s-1],";\n        ").concat(u," sourceLocB = coords;\n        --").concat(l[s-2],";");var h=["x","y","z","w","u","v"].slice(0,o),f="."+h[o-1],x=h.map(function(e){return"int "+e}),m=getChannels("sourceLocR",o-1).concat("inIdx.r"),g=getChannels("sourceLocG",o-1).concat("inIdx.g"),v=getChannels("sourceLocB",o-1).concat("inIdx.b"),b=getChannels("sourceLocA",o-1).concat("inIdx.a"),C=a?"":"\n          inIdx = round(vec4(getBestIndicesAChannel(".concat(m.join(),"),\n                             getBestIndicesAChannel(").concat(g.join(),"),\n                             getBestIndicesAChannel(").concat(v.join(),"),\n                             getBestIndicesAChannel(").concat(b.join(),")));"),y="vec4(\n            getAChannel(".concat(m.join(),"),\n            hasNextCol ? getAChannel(").concat(g.join(),") : 0.,\n            hasNextRow ? getAChannel(").concat(v.join(),") : 0.,\n            hasNextRow && hasNextCol ? getAChannel(").concat(b.join(),") : 0.)"),k=a?"":"\n      float getBestIndicesAChannel(".concat(x.join(),") {\n        return getChannel(getBestIndicesA(").concat(h.join(),"),\n                                          vec2(").concat(h.slice(-2).join(),"));\n      }");this.userCode="\n      float getAChannel(".concat(x.join(),") {\n        return getChannel(getA(").concat(h.join(),"),\n                               vec2(").concat(h.slice(-2).join(),"));\n      }\n      ").concat(k,"\n      void main() {\n        ").concat(u," coords = getOutputCoords();\n        bool hasNextCol = ").concat(l[s-1]," < ").concat(c[s-1]-1,";\n        bool hasNextRow = ").concat(l[s-2]," < ").concat(c[s-2]-1,";\n        ").concat(r,"\n        ivec4 srcIdx = ivec4(sourceLocR").concat(f,", sourceLocG").concat(f,",\n          sourceLocB").concat(f,", sourceLocA").concat(f,") * ").concat(n,";\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ").concat(y,";\n\n        for (int i = 0; i < ").concat(n,"; i++) {\n          inIdx = srcIdx;\n          ").concat(C,"\n          vec4 candidate = ").concat(y,";\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(").concat("max"===t?"greaterThan":"lessThan","(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    ")};function argMinMaxReduce(e,n,t,a){var r=[t];if(p.backend_util.assertAxesAreInnerMostDims("arg"+a.charAt(0).toUpperCase()+a.slice(1),r,n.shape.length),!p.env().getBool("WEBGL_PACK_REDUCE")||n.shape.length<=2){var o=[],i=e.texData.get(n.dataId),c=null!==i&&i.isPacked,s=n;c&&o.push(s=e.unpackTensor(n));var u=__read(p.backend_util.computeOutAndReduceShapes(s.shape,r),2),l=u[0],d=u[1],h=reshape({inputs:{x:s},backend:e,attrs:{shape:[-1,p.util.sizeFromShape(d)]}});o.push(h);var f=function argReduce(e,n,t,a){void 0===a&&(a=null);var r=n.shape[0],o=n.shape[1];null!=a&&(r=a.shape[0],o=a.shape[1]);var i=p.backend_util.computeOptimalWindowSize(o),c={windowSize:i,inSize:o,batchSize:r,outSize:Math.ceil(o/i)},s=new ArgMinMaxProgram(c,t,null==a),u=[n];null!=a&&u.push(a);var l=e.runWebGLProgram(s,u,"int32");if(1===l.shape[1])return l;var d=argReduce(e,n,t,l);return e.disposeIntermediateTensorInfo(l),d}(e,h,a);o.push(f);var x=reshape({inputs:{x:f},backend:e,attrs:{shape:l}});return o.forEach(function(n){return e.disposeIntermediateTensorInfo(n)}),x}return function argReducePacked(e,n,t,a){void 0===a&&(a=null);var r=null!=a?a.shape:n.shape,o=r[r.length-1],i=p.backend_util.computeOptimalWindowSize(o),c=new ArgMinMaxPackedProgram(r,i,t,null==a),s=null==a?[n]:[n,a],u=e.runWebGLProgram(c,s,"int32");if(u.shape.length===n.shape.length){var l=argReducePacked(e,n,t,u);return e.disposeIntermediateTensorInfo(u),l}return u}(e,n,a)}var eA={kernelName:p.ArgMax,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.x,o=a.axis,i=p.util.parseAxisParam(o,r.shape),c=p.backend_util.getAxesPermutation(i,r.shape.length),s=r,u=[];null!=c&&(u.push(s=transpose({inputs:{x:r},backend:t,attrs:{perm:c}})),i=p.backend_util.getInnerMostAxes(i.length,s.shape.length)),p.backend_util.assertAxesAreInnerMostDims("argMax",[i[0]],s.shape.length);var l=argMinMaxReduce(t,s,i[0],"max");return u.forEach(function(e){return t.disposeIntermediateTensorInfo(e)}),l}},eO={kernelName:p.ArgMin,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.x,o=a.axis,i=p.util.parseAxisParam(o,r.shape),c=p.backend_util.getAxesPermutation(i,r.shape.length),s=r,u=[];null!=c&&(u.push(s=transpose({inputs:{x:r},backend:t,attrs:{perm:c}})),i=p.backend_util.getInnerMostAxes(i.length,s.shape.length)),p.backend_util.assertAxesAreInnerMostDims("argMin",[i[0]],s.shape.length);var l=argMinMaxReduce(t,s,i[0],"min");return u.forEach(function(e){return t.disposeIntermediateTensorInfo(e)}),l}},eD=unaryKernelFunc({opSnippet:q+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),eL={kernelName:p.Asin,backendName:"webgl",kernelFunc:eD},eB=unaryKernelFunc({opSnippet:q+"return log(x + sqrt(x * x + 1.0));"}),eU={kernelName:p.Asinh,backendName:"webgl",kernelFunc:eB},eG=unaryKernelFunc({opSnippet:q+"\n  return atan(x);\n"}),eM={kernelName:p.Atan,backendName:"webgl",kernelFunc:eG},eW=binaryKernelFunc({opSnippet:ea+"\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+er+"\n  return result;\n"}),eV={kernelName:p.Atan2,backendName:"webgl",kernelFunc:eW},ez=unaryKernelFunc({opSnippet:q+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),eX={kernelName:p.Atanh,backendName:"webgl",kernelFunc:ez},Pool2DProgram=function(e,n,t,a,r){if(void 0===a&&(a=!1),void 0===r&&(r=!1),this.variableNames=["x"],"avg"===n&&t)throw Error("Cannot compute positions for average pool.");var o=e.filterWidth,i=e.strideHeight,c=e.strideWidth,s=e.dilationHeight,u=e.dilationWidth,l=e.effectiveFilterHeight,d=e.effectiveFilterWidth,p=e.padInfo.top,h=e.padInfo.left;this.outputShape=e.outShape;var f="avg"===n,x="((batch  * ".concat(e.inHeight," + xR) * ").concat(e.inWidth," + xC) * ").concat(e.inChannels," + d"),m="(xR * ".concat(e.inWidth," + xC) * ").concat(e.inChannels," + d"),g="0.0";if(f||(g="-1.0 / 1e-20"),t){this.userCode="\n        const ivec2 strides = ivec2(".concat(i,", ").concat(c,");\n        const ivec2 pads = ivec2(").concat(p,", ").concat(h,");\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ").concat(l,";\n              wR += ").concat(s,") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ").concat(e.inHeight,") {\n              continue;\n            }\n\n            for (int wC = 0; wC < ").concat(d,";\n                wC += ").concat(u,") {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ").concat(">="," currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ").concat(a?r?x:m:"wR * ".concat(d," + wC"),";\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ");return}var v="".concat(n,"(").concat(n,"(").concat(n,"(")+"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"avg"===n&&(v="avgValue / max(count, 1.0)");var b=4*Math.floor(o/4),C=o%4,y="\n      if (".concat(f,") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ").concat("max","(values, minMaxValue);\n      }\n    ");this.userCode="\n      const ivec2 strides = ivec2(".concat(i,", ").concat(c,");\n      const ivec2 pads = ivec2(").concat(p,", ").concat(h,");\n      const float initializationValue = ").concat(g,";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ").concat(e.inWidth,") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(").concat(g,");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ").concat(l,";\n            wR += ").concat(s,") {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ").concat(e.inHeight,") {\n            continue;\n          }\n\n          for (int wC = 0; wC < ").concat(b,"; wC += 4) {\n            int xC = xCCorner + wC * ").concat(u,";\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ").concat(u,", d),\n              getValue(batch, xR, xC + 2 * ").concat(u,", d),\n              getValue(batch, xR, xC + 3 * ").concat(u,", d)\n            );\n\n            ").concat(y,"\n          }\n\n          int xC = xCCorner + ").concat(b,";\n          if (").concat(1===C,") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ").concat(y,"\n          } else if (").concat(2===C,") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ").concat(u,", d),\n              initializationValue,\n              initializationValue\n            );\n\n            ").concat(y,"\n          } else if (").concat(3===C,") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ").concat(u,", d),\n              getValue(batch, xR, xC + 2 * ").concat(u,", d),\n              initializationValue\n            );\n\n            ").concat(y,"\n          }\n        }\n        setOutput(").concat(v,");\n      }\n    ")},Pool3DProgram=function(e,n,t,a,r){if(void 0===a&&(a=!1),void 0===r&&(r=!1),this.variableNames=["x"],"avg"===n&&t)throw Error("Cannot compute positions for average pool.");var o=e.filterWidth,i=e.strideDepth,c=e.strideHeight,s=e.strideWidth,u=e.dilationDepth,l=e.dilationHeight,d=e.dilationWidth,p=e.effectiveFilterDepth,h=e.effectiveFilterHeight,f=e.effectiveFilterWidth,x=e.padInfo.front,m=e.padInfo.top,g=e.padInfo.left;this.outputShape=e.outShape;var v="avg"===n,b="0.0";if(v||(b="-1.0 / 1e-20"),t){this.userCode="\n        const ivec3 strides =\n            ivec3(".concat(i,", ").concat(c,", ").concat(s,");\n        const ivec3 pads = ivec3(").concat(x,", ").concat(m,", ").concat(g,");\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ").concat(p,";\n              wD += ").concat(u,") {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ").concat(e.inDepth,") {\n              continue;\n            }\n\n            for (int wR = 0; wR < ").concat(h,";\n                wR += ").concat(l,") {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ").concat(e.inHeight,") {\n                continue;\n              }\n\n              for (int wC = 0; wC < ").concat(f,";\n                  wC += ").concat(d,") {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ").concat(">="," currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ").concat(a?r?"(((batch * ".concat(e.inDepth," + xD) * ").concat(e.inHeight," + xR) * ").concat(e.inWidth," + xC) * ").concat(e.inChannels," + ch"):"((xD * ".concat(e.inHeight," + xR) * ").concat(e.inWidth," + xC) * ").concat(e.inChannels," + ch"):"wD * ".concat(h," * ").concat(f," +\n                      wR * ").concat(f," + wC"),";\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ");return}var C="".concat(n,"(").concat(n,"(").concat(n,"(")+"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"avg"===n&&(C="avgValue / max(count, 1.0)");var y=4*Math.floor(o/4),k=o%4,I="\n      if (".concat(v,") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ").concat("max","(values, minMaxValue);\n      }\n    ");this.userCode="\n      const ivec3 strides =\n        ivec3(".concat(i,", ").concat(c,", ").concat(s,");\n      const ivec3 pads = ivec3(").concat(x,", ").concat(m,", ").concat(g,");\n      const float initializationValue = ").concat(b,";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ").concat(e.inWidth,") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(").concat(b,");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ").concat(p,";\n            wD += ").concat(u,") {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ").concat(e.inDepth,") {\n            continue;\n          }\n\n          for (int wR = 0; wR < ").concat(h,";\n            wR += ").concat(l,") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ").concat(e.inHeight,") {\n              continue;\n            }\n\n            for (int wC = 0; wC < ").concat(y,"; wC += 4) {\n              int xC = xCCorner + wC * ").concat(d,";\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ").concat(d,", ch),\n                getValue(batch, xD, xR, xC + 2 * ").concat(d,", ch),\n                getValue(batch, xD, xR, xC + 3 * ").concat(d,", ch)\n              );\n\n              ").concat(I,"\n            }\n\n            int xC = xCCorner + ").concat(y,";\n            if (").concat(1===k,") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ").concat(I,"\n            } else if (").concat(2===k,") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ").concat(d,", ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ").concat(I,"\n            } else if (").concat(3===k,") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ").concat(d,", ch),\n                getValue(batch, xD, xR, xC + 2 * ").concat(d,", ch),\n                initializationValue\n              );\n\n              ").concat(I,"\n            }\n          }\n        }\n        setOutput(").concat(C,");\n      }\n    ")},eH={kernelName:p.AvgPool,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.x;assertNotComplex(r,"avgPool");var o=a.filterSize,i=a.strides,c=a.pad,s=a.dimRoundingMode;p.util.assert(p.backend_util.eitherStridesOrDilationsAreOne(i,1),function(){return"Error in avgPool: Either strides or dilations must be 1. "+"Got strides ".concat(i," and dilations '").concat(1,"'")});var u=p.backend_util.computePool2DInfo(r.shape,o,i,1,c,s);if(1===u.filterWidth&&1===u.filterHeight&&p.util.arraysEqual(u.inShape,u.outShape))return identity({inputs:{x:r},backend:t});var l=new Pool2DProgram(u,"avg",!1);return t.runWebGLProgram(l,[r],"float32")}},eK={kernelName:p.AvgPool3D,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.x,o=a.filterSize,i=a.strides,c=a.pad,s=a.dimRoundingMode,u=a.dataFormat,l=p.backend_util.computePool3DInfo(r.shape,o,i,[1,1,1],c,s,u),d=new Pool3DProgram(l,"avg",!1);return t.runWebGLProgram(d,[r],"float32")}},AvgPool2DBackpropProgram=function(e){this.variableNames=["dy"],this.outputShape=e.inShape;var n=e.filterHeight,t=e.filterWidth,a=e.strideHeight,r=e.strideWidth,o=e.dilationHeight,i=e.dilationWidth,c=e.effectiveFilterHeight,s=e.effectiveFilterWidth,u=c-1-e.padInfo.top,l=s-1-e.padInfo.left;this.userCode="\n      const ivec2 pads = ivec2(".concat(u,", ").concat(l,");\n      const float avgMultiplier = float(").concat(1/(n*t),");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(c,";\n            wR += ").concat(o,") {\n          float dyR = float(dyRCorner + wR) / ").concat(a,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ").concat(s,";\n            wC+= ").concat(i,") {\n            float dyC = float(dyCCorner + wC) / ").concat(r,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")},AvgPool3DBackpropProgram=function(e){this.variableNames=["dy"],this.outputShape=e.inShape;var n=e.filterDepth,t=e.filterHeight,a=e.filterWidth,r=e.strideDepth,o=e.strideHeight,i=e.strideWidth,c=e.dilationDepth,s=e.dilationHeight,u=e.dilationWidth,l=e.effectiveFilterDepth,d=e.effectiveFilterHeight,p=e.effectiveFilterWidth,h=l-1-e.padInfo.front,f=d-1-e.padInfo.top,x=p-1-e.padInfo.left;this.userCode="\n      const ivec3 pads = ivec3(".concat(h,", ").concat(f,", ").concat(x,");\n      const float avgMultiplier = float(").concat(1/(n*t*a),");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ").concat(l,";\n            wD += ").concat(c,") {\n          float dyD = float(dyDCorner + wD) / ").concat(r,".0;\n\n          if (dyD < 0.0 || dyD >= ").concat(e.outDepth,".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ").concat(d,";\n              wR += ").concat(s,") {\n            float dyR = float(dyRCorner + wR) / ").concat(o,".0;\n\n            if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ").concat(p,";\n                wC += ").concat(u,") {\n              float dyC = float(dyCCorner + wC) / ").concat(i,".0;\n\n              if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")},ej={kernelName:p.AvgPool3DGrad,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.dy,o=n.input,i=a.filterSize,c=a.strides,s=a.pad,u=a.dimRoundingMode,l=p.backend_util.computePool3DInfo(o.shape,i,c,[1,1,1],s,u),d=new AvgPool3DBackpropProgram(l);return t.runWebGLProgram(d,[r],o.dtype)}},eq={kernelName:p.AvgPoolGrad,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.dy,o=n.input;assertNotComplex([r,o],"avgPoolGrad");var i=a.filterSize,c=a.strides,s=a.pad,u=p.backend_util.computePool2DInfo(o.shape,i,c,1,s),l=new AvgPool2DBackpropProgram(u);return t.runWebGLProgram(l,[r],o.dtype)}},eY={kernelName:p.BatchMatMul,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var n=e.inputs,t=e.backend,a=e.attrs;return batchMatMulImpl({a:n.a,b:n.b,transposeA:a.transposeA,transposeB:a.transposeB,backend:t})}},BatchNormProgram=function(e,n,t,a,r,o){this.outputShape=[],this.variableNames=["x","mean","variance"],p.backend_util.assertAndGetBroadcastShape(e,n),p.backend_util.assertAndGetBroadcastShape(e,t);var i="0.0";null!=a&&(p.backend_util.assertAndGetBroadcastShape(e,a),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");var c="1.0";null!=r&&(p.backend_util.assertAndGetBroadcastShape(e,r),this.variableNames.push("scale"),c="getScaleAtOutCoords()"),this.outputShape=e,this.userCode="\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ".concat(i,";\n        float scale = ").concat(c,";\n        float inv = scale * inversesqrt(variance + float(").concat(o,"));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    ")},BatchNormPackedProgram=function(e,n,t,a,r,o){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],p.backend_util.assertAndGetBroadcastShape(e,n),p.backend_util.assertAndGetBroadcastShape(e,t);var i="vec4(0.0)";null!=a&&(p.backend_util.assertAndGetBroadcastShape(e,a),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");var c="vec4(1.0)";null!=r&&(p.backend_util.assertAndGetBroadcastShape(e,r),this.variableNames.push("scale"),c="getScaleAtOutCoords()"),this.outputShape=e,this.userCode="\n      void main() {\n        vec4 offset = ".concat(i,";\n        vec4 scale = ").concat(c,";\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(").concat(o,"));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    ")},eQ={kernelName:p.FusedBatchNorm,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.x,o=n.mean,i=n.variance,c=n.offset,s=n.scale;p.util.assert(o.shape.length===i.shape.length,function(){return"Batch normalization gradient requires mean and variance to have equal ranks."}),p.util.assert(null==c||o.shape.length===c.shape.length,function(){return"Batch normalization gradient requires mean and offset to have equal ranks."}),p.util.assert(null==s||o.shape.length===s.shape.length,function(){return"Batch normalization gradient requires mean and scale to have equal ranks."});var u=a.varianceEpsilon;null==u&&(u=.001);var l=[r,o,i],d=null;null!=c&&(d=c.shape,l.push(c));var h=null;null!=s&&(h=s.shape,l.push(s));var f=p.env().getBool("WEBGL_PACK_NORMALIZATION")?new BatchNormPackedProgram(r.shape,o.shape,i.shape,d,h,u):new BatchNormProgram(r.shape,o.shape,i.shape,d,h,u);return t.runWebGLProgram(f,l,l[0].dtype)}},SliceProgram=function(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;var n,t=getCoordsDataType(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];var a=function(e){if(1===e)return"sourceLoc";if(e<=6)return eZ.slice(0,e).map(function(e){return"sourceLoc."+e}).join(",");throw Error("Slicing for rank ".concat(e," is not yet supported"))}(this.rank),r=e.map(function(e,n){return"sourceLoc.".concat(eZ[n]," = start[").concat(n,"] + coords.").concat(eZ[n],";")});n="\n        ".concat(t," sourceLoc;\n        ").concat(t," coords = getOutputCoords();\n        ").concat(r.join("\n"),"\n      "),this.userCode="\n      void main() {\n        ".concat(n,"\n        setOutput(getSource(").concat(a,"));\n      }\n    ")},eZ=["x","y","z","w","u","v"],SlicePackedProgram=function(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];var n=getCoordsDataType(this.rank),t=getChannels("coords",this.rank),a=getChannels("sourceLoc",this.rank),r=1===this.rank?"sourceLoc":"vec2(".concat(a.slice(-2).join(),")"),o="getChannel(getSource(".concat(a.join(),"), ").concat(r,")"),i="\n      result.x = ".concat(o,";\n      if (++").concat(t[this.rank-1]," < ").concat(e[this.rank-1],") {\n        ++").concat(a[this.rank-1],";\n        result.y = ").concat(o,";\n        --").concat(a[this.rank-1],";\n      }\n    "),c=1===this.rank?"":"\n      --".concat(t[this.rank-1],";\n      if (++").concat(t[this.rank-2]," < ").concat(e[this.rank-2],") {\n        ++").concat(a[this.rank-2],";\n        result.z = ").concat(o,";\n        if (++").concat(t[this.rank-1]," < ").concat(e[this.rank-1],") {\n          ++").concat(a[this.rank-1],";\n          result.w = ").concat(o,";\n        }\n      }\n    "),s=this.rank<=4?"sourceLoc = coords +\n            ".concat(n,"(").concat(e.map(function(e,n){return"start[".concat(n,"]")}).join(),");"):e.map(function(e,n){return"".concat(a[n]," = ").concat(t[n]," + start[").concat(n,"];")}).join("\n");this.userCode="\n      void main() {\n        ".concat(n," coords = getOutputCoords();\n        ").concat(n," sourceLoc;\n        ").concat(s,"\n        vec4 result = vec4(0.);\n        ").concat(i,"\n        ").concat(c,"\n        setOutput(result);\n      }\n    ")};function slice(e){var n,t,a,r,o,i=e.inputs,c=e.backend,s=e.attrs,u=i.x,l=s.begin,d=s.size,h=__read(p.slice_util.parseSliceParams(u,l,d),2),f=h[0],x=h[1];if(p.slice_util.assertParamsValid(u,f,x),0===p.util.sizeFromShape(x))return c.makeTensorInfo(x,u.dtype,[]);if(c.shouldExecuteOnCPU([u])||"string"===u.dtype){var m=sliceImplCPU(c.texData.get(u.dataId).values,f,x,u.shape,u.dtype);return c.makeTensorInfo(x,u.dtype,m)}var g=c.texData.get(u.dataId).isPacked,v=p.slice_util.isSliceContinous(u.shape,f,x);if(g||!v){var b=p.env().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new SlicePackedProgram(x):new SliceProgram(x),C=[f];return c.runWebGLProgram(b,[u],u.dtype,C)}return c.uploadToGPU(u.dataId),n=c.texData.get(u.dataId),t=c.makeTensorInfo(x,u.dtype),Object.assign(a=c.texData.get(t.dataId),n),a.refCount=1,a.shape=x,a.dtype=u.dtype,r=p.slice_util.computeFlatOffset(f,p.util.computeStrides(u.shape)),n.slice&&(r+=n.slice.flatOffset),a.slice={flatOffset:r,origDataId:n.slice&&n.slice.origDataId||u.dataId},o=c.dataRefCount.get(a.slice.origDataId)||1,c.dataRefCount.set(a.slice.origDataId,o+1),t}var eJ={kernelName:p.Slice,backendName:"webgl",kernelFunc:slice},e$={kernelName:p.BatchToSpaceND,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.x,o=a.blockShape,i=a.crops;p.util.assert(r.shape.length<=4,function(){return"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"});var c=o.reduce(function(e,n){return e*n}),s=p.backend_util.getReshaped(r.shape,o,c),u=p.backend_util.getPermuted(s.length,o.length),l=p.backend_util.getReshapedPermuted(r.shape,o,c),d=p.backend_util.getSliceBeginCoords(i,o.length),h=p.backend_util.getSliceSize(l,i,o.length),f=[],x=reshape({inputs:{x:r},backend:t,attrs:{shape:s}}),m=transpose({inputs:{x:x},backend:t,attrs:{perm:u}}),g=reshape({inputs:{x:m},backend:t,attrs:{shape:l}}),v=slice({inputs:{x:g},backend:t,attrs:{begin:d,size:h}});return f.push(x),f.push(m),f.push(g),f.forEach(function(e){return t.disposeIntermediateTensorInfo(e)}),v}},e0={kernelName:p.Bincount,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.x,o=n.weights,i=a.size,c=bincountImplCPU(t.readSync(r.dataId),t.readSync(o.dataId),o.dtype,o.shape,i);return t.makeTensorInfo([i],o.dtype,c)}},e1={kernelName:p.BitwiseAnd,backendName:"webgl",kernelFunc:function(e){var n,t=e.inputs,a=e.backend,r=t.a,o=t.b,i=p.env().getBool("WEBGL_PACK_BINARY_OPERATIONS"),c=p.env().getNumber("WEBGL_VERSION");if(a.shouldExecuteOnCPU([r,o])||1===c){var s=a.texData.get(r.dataId).values,u=a.texData.get(o.dataId).values,l=__read(I(r.shape,o.shape,s,u,r.dtype),2),d=l[0],h=l[1],f=a.makeTensorInfo(h,r.dtype);return a.texData.get(f.dataId).values=d,f}return n=i?new BinaryOpPackedProgram("\n  int r = int(a.r) & int(b.r);\n  int g = int(a.g) & int(b.g);\n  int rb = int(a.b) & int(b.b);\n  int ra = int(a.a) & int(b.a);\n  return vec4(r, g, rb, ra);\n",r.shape,o.shape,!1):new BinaryOpProgram("\n  return float(int(a.r) & int(b.r));\n",r.shape,o.shape),a.runWebGLProgram(n,[r,o],r.dtype)}},e2={kernelName:p.BroadcastArgs,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var n=e.inputs,t=e.backend,a=n.s0,r=n.s1,o=t.readSync(a.dataId),i=t.readSync(r.dataId),c=p.backend_util.assertAndGetBroadcastShape(Array.from(o),Array.from(i));return t.makeTensorInfo([c.length],"int32",Int32Array.from(c))}},e4=binaryKernelFunc({opSnippet:"return float(a != b);",cpuKernelImpl:B,dtype:"bool"}),e3={kernelName:p.NotEqual,backendName:"webgl",kernelFunc:e4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function real(e){var n=e.inputs,t=e.backend,a=n.input;return identity({inputs:{x:t.texData.get(a.dataId).complexTensorInfos.real},backend:t})}var e5={kernelName:p.Real,backendName:"webgl",kernelFunc:real},e6={kernelName:p.Cast,backendName:"webgl",kernelFunc:function cast(e){var n,t,a=e.inputs,r=e.backend,o=e.attrs,i=a.x,c=o.dtype;if("complex64"===c){if("complex64"===i.dtype)return identity({inputs:{x:i},backend:r});var s=h.zeros(i.shape),u=cast({inputs:{x:i},backend:r,attrs:{dtype:"float32"}}),l=complex({inputs:{real:u,imag:s},backend:r});return s.dispose(),r.disposeIntermediateTensorInfo(u),l}if("complex64"===i.dtype){var d=real({inputs:{input:i},backend:r}),l=cast({inputs:{x:d},backend:r,attrs:{dtype:c}});return r.disposeIntermediateTensorInfo(d),l}if(!p.util.hasEncodingLoss(i.dtype,c)){var l=identity({inputs:{x:i},backend:r});return{dataId:l.dataId,shape:l.shape,dtype:c}}if(r.shouldExecuteOnCPU([i])){var f=__read(castImplCPU(r.texData.get(i.dataId).values,i.shape,i.dtype,c),3),x=f[0],m=f[1],g=f[2];return r.makeTensorInfo(x,m,g)}if("int32"===c)return n=new UnaryOpProgram(i.shape,"return float(int(x));"),{dataId:(t=r.runWebGLProgram(n,[i],"int32")).dataId,shape:t.shape,dtype:t.dtype};if("bool"===c){var v=r.makeTensorInfo([],"bool",p.util.getTypedArrayFromDType("bool",1)),l=e4({inputs:{a:i,b:v},backend:r});return r.disposeIntermediateTensorInfo(v),l}throw Error("Error in Cast: failed to cast ".concat(i.dtype," to ").concat(c))}},e8="return ceil(x);",e7=unaryKernelFunc({opSnippet:e8,packedOpSnippet:e8,cpuKernelImpl:T}),e9={kernelName:p.Ceil,backendName:"webgl",kernelFunc:e7},ClipProgram=function(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "},ClipPackedProgram=function(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "},ne={kernelName:p.ClipByValue,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var n,t=e.inputs,a=e.backend,r=e.attrs,o=t.x,i=r.clipValueMin,c=r.clipValueMax;n=p.env().getBool("WEBGL_PACK_CLIP")?new ClipPackedProgram(o.shape):new ClipProgram(o.shape);var s=[[i],[c]];return a.runWebGLProgram(n,[o],o.dtype,s)}},ComplexAbsProgram=function(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function makeComplexComponentTensorInfo(e,n){return{dataId:n.dataId,dtype:n.dtype,shape:e.shape}}var nn={kernelName:p.ComplexAbs,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=n.x,r=t.texData.get(a.dataId),o=new ComplexAbsProgram(a.shape),i=[makeComplexComponentTensorInfo(a,r.complexTensorInfos.real),makeComplexComponentTensorInfo(a,r.complexTensorInfos.imag)];return t.runWebGLProgram(o,i,i[0].dtype)}},ConcatProgram=function(e){this.outputShape=[],this.outputShape=p.backend_util.computeOutShape(e,1),this.variableNames=e.map(function(e,n){return"T".concat(n)});var n=Array(e.length-1);n[0]=e[0][1];for(var t=1;t<n.length;t++)n[t]=n[t-1]+e[t][1];for(var a=["if (yC < ".concat(n[0],") setOutput(getT0(yR, yC));")],t=1;t<n.length;t++){var r=n[t-1];a.push("else if (yC < ".concat(n[t],") ")+"setOutput(getT".concat(t,"(yR, yC-").concat(r,"));"))}var o=n.length,i=n[n.length-1];a.push("else setOutput(getT".concat(o,"(yR, yC-").concat(i,"));")),this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ".concat(a.join("\n        "),"\n      }\n    ")},ConcatPackedProgram=function(e,n){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=p.backend_util.computeOutShape(e,n);var t=this.outputShape,a=t.length,r=getCoordsDataType(a),o=getChannels("coords",a),i=["x","y","z","w","u","v"].slice(0,a);this.variableNames=e.map(function(e,n){return"T".concat(n)});var c=Array(e.length-1);c[0]=e[0][n];for(var s=1;s<c.length;s++)c[s]=c[s-1]+e[s][n];for(var u=i[n],l=i.slice(-2),d=i.join(),h="if (".concat(u," < ").concat(c[0],") {\n        return getChannel(\n            getT0(").concat(d,"), vec2(").concat(l.join(),"));\n        }"),s=1;s<c.length;s++){var f=c[s-1];h+="\n        if (".concat(u," < ").concat(c[s],"  && ").concat(u," >= ").concat(c[s-1],") {\n          return getChannel(\n            getT").concat(s,"(").concat(shiftedChannels(i,u,f),"),\n            vec2(").concat(shiftedChannels(l,u,f),"));\n        }")}var x=c.length,m=c[c.length-1];h+="\n        return getChannel(\n          getT".concat(x,"(").concat(shiftedChannels(i,u,m),"),\n          vec2(").concat(shiftedChannels(l,u,m),"));"),this.userCode="\n      float getValue(".concat(i.map(function(e){return"int "+e}),") {\n        ").concat(h,"\n      }\n\n      void main() {\n        ").concat(r," coords = getOutputCoords();\n        vec4 result = vec4(getValue(").concat(o,"), 0., 0., 0.);\n\n        ").concat(o[a-1]," = ").concat(o[a-1]," + 1;\n        if (").concat(o[a-1]," < ").concat(t[a-1],") {\n          result.g = getValue(").concat(o,");\n        }\n\n        ").concat(o[a-2]," = ").concat(o[a-2]," + 1;\n        if (").concat(o[a-2]," < ").concat(t[a-2],") {\n          result.a = getValue(").concat(o,");\n        }\n\n        ").concat(o[a-1]," = ").concat(o[a-1]," - 1;\n        if (").concat(o[a-2]," < ").concat(t[a-2]," &&\n            ").concat(o[a-1]," < ").concat(t[a-1],") {\n          result.b = getValue(").concat(o,");\n        }\n        setOutput(result);\n      }\n    ")};function shiftedChannels(e,n,t){var a=e.indexOf(n);return e.map(function(e,n){return n===a?"".concat(e," - ").concat(t):e}).join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function imag(e){var n=e.inputs,t=e.backend,a=n.input;return identity({inputs:{x:t.texData.get(a.dataId).complexTensorInfos.imag},backend:t})}var nt={kernelName:p.Imag,backendName:"webgl",kernelFunc:imag};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function concat(e){var n=e.inputs,t=e.backend,a=e.attrs.axis,r=p.util.parseAxisParam(a,n[0].shape)[0],o=n.map(function(e){return e.shape});p.backend_util.assertParamsConsistent(o,r);var i=p.backend_util.computeOutShape(n.map(function(e){return e.shape}),r);if(0===p.util.sizeFromShape(i))return t.makeTensorInfo(i,n[0].dtype,[]);var c=n.filter(function(e){return p.util.sizeFromShape(e.shape)>0});return 1===c.length?identity({inputs:{x:c[0]},backend:t}):function concatImpl(e,n,t){var a,r,o,i=e[0].dtype;if("complex64"===i){var c=e.map(function(e){return real({inputs:{input:e},backend:t})}),s=e.map(function(e){return imag({inputs:{input:e},backend:t})}),u=concatImpl(c,n,t),l=concatImpl(s,n,t),d=complex({inputs:{real:u,imag:l},backend:t});return c.forEach(function(e){return t.disposeIntermediateTensorInfo(e)}),s.forEach(function(e){return t.disposeIntermediateTensorInfo(e)}),t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(l),d}var h=t.shouldExecuteOnCPU(e);if("string"===i&&(h=!0),h){var f=e.map(function(e){var a=p.util.sizeFromShape(e.shape.slice(n));return reshape({inputs:{x:e},backend:t,attrs:{shape:[-1,a]}})}),x=concatImplCPU(f.map(function(e){return{vals:t.readSync(e.dataId),shape:e.shape}}),p.backend_util.computeOutShape(f.map(function(e){return e.shape}),1),i,1===f[0].shape[0]),m=p.backend_util.computeOutShape(e.map(function(e){return e.shape}),n),g=t.makeTensorInfo(m,i,x);return f.forEach(function(e){return t.disposeIntermediateTensorInfo(e)}),g}var v=e.filter(function(e){return p.util.sizeFromShape(e.shape)>0}),b=p.env().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&v[0].shape.length>1;if(1===v.length){var C=b?new UnaryOpProgram(e[0].shape,J):new UnaryOpPackedProgram(e[0].shape,J);return t.runWebGLProgram(C,e,i)}var y=p.env().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(v.length>y){for(var k=[],I=0;I<v.length;I+=y){var T=v.slice(I,I+y);k.push(concatImpl(T,n,t))}var S=concatImpl(k,n,t);try{for(var R=__values(k),w=R.next();!w.done;w=R.next()){var I=w.value;t.disposeIntermediateTensorInfo(I)}}catch(e){r={error:e}}finally{try{w&&!w.done&&(o=R.return)&&o.call(R)}finally{if(r)throw r.error}}return S}if(b){var P=new ConcatPackedProgram(v.map(function(e){return e.shape}),n);return t.runWebGLProgram(P,v,i)}var _=(a=p.backend_util.computeOutShape(v.map(function(e){return e.shape}),n),{tensors2D:v.map(function(e){return reshape({inputs:{x:e},attrs:{shape:[-1,p.util.sizeFromShape(e.shape.slice(n))]},backend:t})}),outShape:a}),E=_.tensors2D,F=_.outShape,N=new ConcatProgram(E.map(function(e){return e.shape})),A=t.runWebGLProgram(N,E,i);E.forEach(function(e){return t.disposeIntermediateTensorInfo(e)});var O=reshape({inputs:{x:A},attrs:{shape:F},backend:t});return t.disposeIntermediateTensorInfo(A),O}(c,r,t)}var na={kernelName:p.Concat,backendName:"webgl",kernelFunc:concat},Conv2DProgram=function(e,n,t,a,r){void 0===n&&(n=!1),void 0===t&&(t=null),void 0===a&&(a=!1),void 0===r&&(r=!1),this.variableNames=["x","W"],this.outputShape=e.outShape;var o=e.padInfo.top,i=e.padInfo.left,c=e.strideHeight,s=e.strideWidth,u=e.dilationHeight,l=e.dilationWidth,d=e.filterHeight,p=e.filterWidth,h=4*Math.floor(e.inChannels/4),f=e.inChannels%4,x="channelsLast"===e.dataFormat,m=x?1:2,g=x?2:3,v=x?3:1,b="",C="";t&&(b=a?"float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ".concat(t,"\n        }"):r?"float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ".concat(t,"\n        }"):"\n          float activation(float x) {\n            ".concat(t,"\n          }\n        "),C="result = activation(result);");var y=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n      ".concat(b,"\n\n      const ivec2 strides = ivec2(").concat(c,", ").concat(s,");\n      const ivec2 pads = ivec2(").concat(o,", ").concat(i,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[").concat(v,"];\n\n        ivec2 xRCCorner =\n            ivec2(coords[").concat(m,"], coords[").concat(g,"]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(d,"; wR++) {\n          int xR = xRCorner + wR * ").concat(u,";\n\n          if (xR < 0 || xR >= ").concat(e.inHeight,") {\n            continue;\n          }\n\n          for (int wC = 0; wC < ").concat(p,"; wC++) {\n            int xC = xCCorner + wC * ").concat(l,";\n\n            if (xC < 0 || xC >= ").concat(e.inWidth,") {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ").concat(h,"; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (").concat(x,") {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (").concat(1===f,") {\n\n              if (").concat(x,") {\n                dotProd +=\n                    getX(batch, xR, xC, ").concat(h,") *\n                    getW(wR, wC, ").concat(h,", d2);\n              } else {\n                dotProd +=\n                    getX(batch, ").concat(h,", xR, xC) *\n                    getW(wR, wC, ").concat(h,", d2);\n              }\n\n            } else if (").concat(2===f,") {\n              vec2 wValues = vec2(\n                getW(wR, wC, ").concat(h,", d2),\n                getW(wR, wC, ").concat(h," + 1, d2)\n              );\n\n              if (").concat(x,") {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ").concat(h,"),\n                  getX(batch, xR, xC, ").concat(h," + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ").concat(h,", xR, xC),\n                  getX(batch, ").concat(h," + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (").concat(3===f,") {\n              vec3 wValues = vec3(\n                getW(wR, wC, ").concat(h,", d2),\n                getW(wR, wC, ").concat(h," + 1, d2),\n                getW(wR, wC, ").concat(h," + 2, d2)\n              );\n\n              if (").concat(x,") {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ").concat(h,"),\n                  getX(batch, xR, xC, ").concat(h," + 1),\n                  getX(batch, xR, xC, ").concat(h," + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ").concat(h,", xR, xC),\n                  getX(batch, ").concat(h," + 1, xR, xC),\n                  getX(batch, ").concat(h," + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ").concat(y,"\n        ").concat(C,"\n        setOutput(result);\n      }\n    ")},Conv3DProgram=function(e){this.variableNames=["x","W"],this.outputShape=e.outShape;var n=e.padInfo.front,t=e.padInfo.top,a=e.padInfo.left,r=e.strideDepth,o=e.strideHeight,i=e.strideWidth,c=e.dilationDepth,s=e.dilationHeight,u=e.dilationWidth,l=e.filterDepth,d=e.filterHeight,p=e.filterWidth,h=4*Math.floor(e.inChannels/4),f=e.inChannels%4;this.userCode="\n      const ivec3 strides = ivec3(".concat(r,", ").concat(o,", ").concat(i,");\n      const ivec3 pads = ivec3(").concat(n,", ").concat(t,", ").concat(a,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ").concat(l,"; wF++) {\n          int xF = xFCorner + wF * ").concat(c,";\n\n          if (xF < 0 || xF >= ").concat(e.inDepth,") {\n            continue;\n          }\n\n          for (int wR = 0; wR < ").concat(d,"; wR++) {\n            int xR = xRCorner + wR * ").concat(s,";\n\n            if (xR < 0 || xR >= ").concat(e.inHeight,") {\n              continue;\n            }\n\n            for (int wC = 0; wC < ").concat(p,"; wC++) {\n              int xC = xCCorner + wC * ").concat(u,";\n\n              if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ").concat(h,"; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (").concat(1===f,") {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ").concat(h,") *\n                  getW(wF, wR, wC, ").concat(h,", d2);\n              } else if (").concat(2===f,") {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ").concat(h,"),\n                  getX(batch, xF, xR, xC, ").concat(h," + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ").concat(h,", d2),\n                  getW(wF, wR, wC, ").concat(h," + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (").concat(3===f,") {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ").concat(h,"),\n                  getX(batch, xF, xR, xC, ").concat(h," + 1),\n                  getX(batch, xF, xR, xC, ").concat(h," + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ").concat(h,", d2),\n                  getW(wF, wR, wC, ").concat(h," + 1, d2),\n                  getW(wF, wR, wC, ").concat(h," + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")},Conv2DPackedProgram=function(e,n,t,a,r){void 0===n&&(n=!1),void 0===t&&(t=null),void 0===a&&(a=!1),void 0===r&&(r=!1),this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=useShapeUniforms(this.outputShape.length);for(var o=e.padInfo.left,i=e.strideWidth,c=e.dilationWidth,s=e.filterHeight,u=e.filterWidth,l="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;",d=0;d<u;d++)l+="\n           vec4 xTexelC".concat(2*d,";\n           int xTexelC").concat(2*d,"Ready;\n           vec4 xTexelC").concat(2*d+1,";\n           int xTexelC").concat(2*d+1,"Ready;\n           vec4 xC").concat(d,";");l+="\n     for (int r = 0; r < ".concat(s,"; r++) {\n      for (int d1 = 0; d1 < ").concat(e.inChannels,"; d1 += 2) {\n       ");for(var d=0;d<u;d++)l+="\n           xTexelC".concat(2*d," = vec4(0.0);\n           xTexelC").concat(2*d,"Ready = 0;\n           xTexelC").concat(2*d+1," = vec4(0.0);\n           xTexelC").concat(2*d+1,"Ready = 0;\n           xC").concat(d," = vec4(0.0);");l+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(var h=0;h<(u+1)/2;h++){var f=2*h;if(l+="\n           xC = xCCorner + ".concat(f*c,";\n           "),1===i){if(f<u&&(o%2==1?(l+="\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(f,"Ready == 0) {\n                   xTexelC").concat(f," = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC").concat(f,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(f,"Ready = 1;\n                 }\n               "),1===c&&f>0?l+="\n                 xC".concat(f," = vec4(xTexelC").concat(f-2,".zw, xTexelC").concat(f,".xy);\n                 "):l+="\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC".concat(f," = vec4(previous.zw, xTexelC").concat(f,".xy);\n                   } else {\n                     xC").concat(f," = vec4(0.0, 0.0, xTexelC").concat(f,".xy);\n                   }\n                   ")):l+="\n                 if (xC >= 0 && xC < inDims[1] && xTexelC".concat(f,"Ready == 0) {\n                   xTexelC").concat(f," = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC").concat(f,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(f,"Ready = 1;\n                 }\n\n                 xC").concat(f," = xTexelC").concat(f,";\n                 "),f+1<u)){var x=o%2==0?p.util.nearestLargerEven(c):c;c%2==0&&o%2==1||c%2!=0&&o%2!=1?(l+="\n                   xCOffset = xC + imod(pads[1], 2) + ".concat(x,";\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(f+1,"Ready == 0) {\n                     xTexelC").concat(f+1," = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC").concat(f+1,".zw = vec2(0.0);\n                     }\n                     xTexelC").concat(f+1,"Ready = 1;\n                   }\n                   "),c>1?l+="\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC".concat(f+1," = vec4(previous.zw, xTexelC").concat(f+1,".xy);\n                     } else {\n                      xC").concat(f+1," = vec4(0.0, 0.0, xTexelC").concat(f+1,".xy);\n                     }\n                     "):l+="\n                     xC".concat(f+1," = vec4(xTexelC").concat(f,".zw, xTexelC").concat(f+1,".xy);\n                     ")):1===x?l+="\n                     xC".concat(f+1," = xTexelC").concat(f,";\n                     "):l+="\n                     xCOffset = xC + ".concat(x,";\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(f+1,"Ready == 0) {\n                       xTexelC").concat(f+1," = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC").concat(f+1,".zw = vec2(0.0);\n                       }\n                       xTexelC").concat(f+1,"Ready = 1;\n                     }\n\n                     xC").concat(f+1," = xTexelC").concat(f+1,";\n                     ")}}else f<u&&(o%2==1?(l+="\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(f,"Ready == 0) {\n                   xTexelC").concat(f," = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC").concat(f,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(f,"Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC").concat(f+1,"Ready == 0) {\n                   xTexelC").concat(f+1," = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC").concat(f+1,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(f+1,"Ready = 1;\n                 }\n\n                 xC").concat(f," = vec4(xTexelC").concat(f,".zw, xTexelC").concat(f+1,".zw);\n               "),f+1<u&&(l+="\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC".concat(f+1," = vec4(xTexelC").concat(f+1,".xy, final.xy);\n                 "))):(l+="\n                 if(xC >= 0 && xC < inDims[1] && xTexelC".concat(f,"Ready == 0) {\n                   xTexelC").concat(f," = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC").concat(f,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(f,"Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(f+1,"Ready == 0) {\n                   xTexelC").concat(f+1," = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC").concat(f+1,".zw = vec2(0.);\n                   }\n                   xTexelC").concat(f+1,"Ready = 1;\n                 }\n\n                 xC").concat(f," = vec4(\n                   xTexelC").concat(f,".xy, xTexelC").concat(f+1,".xy);\n               "),f+1<u&&(l+="\n                   xC".concat(f+1," = vec4(xTexelC").concat(f,".zw, xTexelC").concat(f+1,".zw);\n                 "))));f<u&&(l+="\n             wTexel = getW(r, ".concat(f,", d1, d2);\n             dotProd += xC").concat(f,".xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ").concat(e.inChannels,") {\n               dotProd += xC").concat(f,".yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           "),f+1<u&&(l+="\n               wTexel = getW(r, ".concat(f+1,", d1, d2);\n               dotProd += xC").concat(f+1,".xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ").concat(e.inChannels,") {\n                 dotProd += xC").concat(f+1,".yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             ")))}l+="\n     }\n   \n     }\n   \n     }\n   ";var m="",g="";t&&(m=a?"vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ".concat(t,"\n         }"):r?"vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ".concat(t,"\n         }"):"vec4 activation(vec4 x) {\n           ".concat(t,"\n         }"),g="result = activation(result);");var v=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n       ".concat(m,"\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ").concat(l,"\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ").concat(v,"\n         ").concat(g,"\n         setOutput(result);\n       }\n     ")},Im2ColPackedProgram=function(e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=useShapeUniforms(this.outputShape.length);for(var t=n.dataFormat,a=getGlslDifferences(),r="channelsLast"===t,o=r?1:2,i=r?2:3,c=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":"if(blockIndex < ".concat(e[2]," && pos < ").concat(e[1],") {"),s="",u=0;u<=1;u++)for(var l=0;l<=1;l++)s+="\n          blockIndex = rc.z + ".concat(l,";\n          pos = rc.y + ").concat(u,";\n\n          ").concat(c,"\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[").concat(o,"] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[").concat(i,"] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (").concat(r,") {\n                  innerDims = vec2(d1, ch);\n                  result[").concat(2*u+l,"] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[").concat(2*u+l,"] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        ");this.userCode="\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ".concat(s,"\n\n        ").concat(a.output," = result;\n      }\n    ")};function getShapeForBatchMatMul(e,n){var t=e.length;return t>=3?n?__spreadArray(__spreadArray([],__read(e.slice(0,-3)),!1),[e[t-3]*e[t-2],e[t-1]],!1):__spreadArray(__spreadArray([],__read(e.slice(0,-3)),!1),[e[t-3],e[t-2]*e[t-1]],!1):!n&&1===t&&e[0]>1?[e[0],1]:null}function conv2dByMatMul(e){var n,t,a,r=e.x,o=e.filter,i=e.convInfo,c=e.backend,s=e.bias,u=void 0===s?null:s,l=e.preluActivationWeights,d=void 0===l?null:l,h=e.leakyreluAlpha,f=void 0===h?0:h,x=e.activation,m=void 0===x?null:x,g=r.shape,v=c.texData.get(r.dataId),b=i.inChannels,C=g[0]*g[1]*g[2],y=i.outChannels,k="channelsLast"===i.dataFormat,I=[];if(null!=d){var T=getShapeForBatchMatMul(d.shape,k);null!=T&&(d=reshape({inputs:{x:d},backend:c,attrs:{shape:T}}),I.push(d))}if(null!=u){var T=getShapeForBatchMatMul(u.shape,k);null!=T&&(u=reshape({inputs:{x:u},backend:c,attrs:{shape:T}}),I.push(u))}if(!((1===C||1===y)&&b>1e3)&&v.isPacked&&k&&null!=v.texture&&g[2]%2!=0&&p.util.arraysEqual(v.shape.slice(-3),g.slice(-3))){var T=g[0]*g[1]*(g[2]+1),S={dataId:r.dataId,shape:[1,T,i.inChannels],dtype:r.dtype},R=v.shape;v.shape=v.shape.slice(),v.shape[v.shape.length-2]++,p.util.assert(isReshapeFree(v.shape,S.shape),function(){return"packed reshape ".concat(v.shape," to ").concat(S.shape," isn't free")});var w=reshape({inputs:{x:o},backend:c,attrs:{shape:[1,i.inChannels,i.outChannels]}});I.push(w);var P=batchMatMulImpl({a:S,b:w,backend:c,transposeA:!1,transposeB:!1,bias:u,activation:m,preluActivationWeights:d,leakyreluAlpha:f}),_=c.texData.get(P.dataId);p.util.assert(_.isPacked,function(){return"batchMatMul result is expected to be packed"}),v.shape=R,_.shape=i.outShape,(a=identity({inputs:{x:P},backend:c})).shape=i.outShape,I.push(P)}else{var E=i.outHeight*i.outWidth,F=reshape({inputs:{x:r},backend:c,attrs:{shape:k?[i.batchSize,E,i.inChannels]:[i.batchSize,i.inChannels,E]}}),w=reshape({inputs:{x:o},backend:c,attrs:{shape:[1,i.inChannels,i.outChannels]}}),N=batchMatMulImpl({a:k?F:w,b:k?w:F,transposeA:!k,transposeB:!1,backend:c,bias:u,activation:m,preluActivationWeights:d,leakyreluAlpha:f});a=reshape({inputs:{x:N},backend:c,attrs:{shape:i.outShape}}),I.push(F),I.push(w),I.push(N)}try{for(var A=__values(I),O=A.next();!O.done;O=A.next()){var D=O.value;c.disposeIntermediateTensorInfo(D)}}catch(e){n={error:e}}finally{try{O&&!O.done&&(t=A.return)&&t.call(A)}finally{if(n)throw n.error}}return a}function conv2dWithIm2Row(e){var n,t,a=e.x,r=e.filter,o=e.convInfo,i=e.backend,c=e.bias,s=void 0===c?null:c,u=e.preluActivationWeights,l=void 0===u?null:u,d=e.leakyreluAlpha,h=e.activation,f=void 0===h?null:h,x=o.filterWidth,m=o.filterHeight,g=o.inChannels,v=o.outWidth,b=o.outHeight,C="channelsLast"===o.dataFormat,y=x*m*g,k=b*v,I=[o.batchSize,y,k],T=[];if(null!=l){var S=getShapeForBatchMatMul(l.shape,C);null!=S&&(l=reshape({inputs:{x:l},backend:i,attrs:{shape:S}}),T.push(l))}if(null!=s){var S=getShapeForBatchMatMul(s.shape,C);null!=S&&(s=reshape({inputs:{x:s},backend:i,attrs:{shape:S}}),T.push(s))}var R=reshape({inputs:{x:r},backend:i,attrs:{shape:[1,y,p.util.sizeFromShape(r.shape)/y]}});T.push(R);var w=new Im2ColPackedProgram(I,o),P=[a.shape,[o.padInfo.top,o.padInfo.left],[o.strideHeight,o.strideWidth],[o.dilationHeight,o.dilationWidth],[o.inChannels],[o.filterWidth*o.inChannels],[o.outWidth]],_=i.runWebGLProgram(w,[a],"float32",P),E=reshape({inputs:{x:_},backend:i,attrs:{shape:I}});T.push(_),T.push(E);var F=null!=s,N=null!=l,A="leakyrelu"===f,O=f?mapActivationToShaderProgram(f,!0):null,D=new MatMulPackedProgram(C?E.shape:R.shape,C?R.shape:E.shape,C?[o.batchSize,k,o.outChannels]:[o.batchSize,o.outChannels,k],!0,!1,F,O,N,A),L=C?[E,R]:[R,E];if(s&&L.push(s),N&&L.push(l),A){var B=i.makeTensorInfo([],"float32",p.util.createScalarValue(void 0===d?0:d,"float32"));L.push(B),T.push(B)}var U=i.runWebGLProgram(D,L,"float32"),G=reshape({inputs:{x:U},backend:i,attrs:{shape:o.outShape}});T.push(U);try{for(var M=__values(T),W=M.next();!W.done;W=M.next()){var V=W.value;i.disposeIntermediateTensorInfo(V)}}catch(e){n={error:e}}finally{try{W&&!W.done&&(t=M.return)&&t.call(M)}finally{if(n)throw n.error}}return G}var nr={kernelName:p.Conv2D,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var n,t=e.inputs,a=e.backend,r=e.attrs,o=t.x,i=t.filter,c=r.strides,s=r.pad,u=r.dataFormat,l=r.dilations,d=r.dimRoundingMode,h=p.backend_util.convertConv2DDataFormat(u),f=p.backend_util.computeConv2DInfo(o.shape,i.shape,c,l,s,d,!1,h);if(1===f.filterHeight&&1===f.filterWidth&&1===f.dilationHeight&&1===f.dilationWidth&&1===f.strideHeight&&1===f.strideWidth&&("SAME"===f.padInfo.type||"VALID"===f.padInfo.type))n=conv2dByMatMul({x:o,filter:i,convInfo:f,backend:a});else if(f.strideWidth<=2&&"channelsLast"===h&&p.env().getBool("WEBGL_EXP_CONV")){var x=new Conv2DPackedProgram(f),m=[[f.padInfo.top,f.padInfo.left],[f.strideHeight,f.strideWidth],[f.dilationHeight,f.dilationWidth],[f.inHeight,f.inWidth]];n=a.runWebGLProgram(x,[o,i],"float32",m)}else if(p.env().getBool("WEBGL_CONV_IM2COL"))n=conv2dWithIm2Row({x:o,filter:i,convInfo:f,backend:a});else{var x=new Conv2DProgram(f);n=a.runWebGLProgram(x,[o,i],"float32")}var g=reshape({inputs:{x:n},backend:a,attrs:{shape:f.outShape}});return a.disposeIntermediateTensorInfo(n),g}},Conv2DDerFilterProgram=function(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;var n=e.strideHeight,t=e.strideWidth,a=e.padInfo.top,r=e.padInfo.left,o="channelsLast"===e.dataFormat;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ".concat(e.batchSize,"; b++) {\n          for (int yR = 0; yR < ").concat(e.outHeight,"; yR++) {\n            int xR = wR + yR * ").concat(n," - ").concat(a,";\n\n            if (xR < 0 || xR >= ").concat(e.inHeight,") {\n              continue;\n            }\n\n            for (int yC = 0; yC < ").concat(e.outWidth,"; yC++) {\n              int xC = wC + yC * ").concat(t," - ").concat(r,";\n\n              if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                continue;\n              }\n\n              ").concat(o?"float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);":"float dyValue = getDy(b, d2, yR, yC);\n              float xValue = getX(b, d1, xR, xC);\n              dotProd += (xValue * dyValue);","\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")},Conv2DDerInputProgram=function(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;var n=e.filterHeight,t=e.filterWidth,a=e.strideHeight,r=e.strideWidth,o="channelsLast"===e.dataFormat,i=n-1-e.padInfo.top,c=t-1-e.padInfo.left,s=o?1:2,u=o?2:3,l=o?3:1;this.userCode="\n      const ivec2 pads = ivec2(".concat(i,", ").concat(c,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[").concat(l,"];\n\n        ivec2 dyCorner = ivec2(coords[").concat(s,"], coords[").concat(u,"]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(n,"; wR++) {\n          float dyR = float(dyRCorner + wR) / ").concat(a,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ").concat(n," - 1 - wR;\n\n          for (int wC = 0; wC < ").concat(t,"; wC++) {\n            float dyC = float(dyCCorner + wC) / ").concat(r,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ").concat(t," - 1 - wC;\n\n            for (int d2 = 0; d2 < ").concat(e.outChannels,"; d2++) {\n\n              if (").concat(o,") {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")},Conv3DDerFilterProgram=function(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;var n=e.strideDepth,t=e.strideHeight,a=e.strideWidth,r=e.padInfo.front,o=e.padInfo.top,i=e.padInfo.left;this.userCode="\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ".concat(e.batchSize,"; b++) {\n          for (int yF = 0; yF < ").concat(e.outDepth,"; yF++) {\n            int xF = wF + yF * ").concat(n," - ").concat(r,";\n\n            if (xF < 0 || xF >= ").concat(e.inDepth,") {\n              continue;\n            }\n\n            for (int yR = 0; yR < ").concat(e.outHeight,"; yR++) {\n              int xR = wR + yR * ").concat(t," - ").concat(o,";\n\n              if (xR < 0 || xR >= ").concat(e.inHeight,") {\n                continue;\n              }\n\n              for (int yC = 0; yC < ").concat(e.outWidth,"; yC++) {\n                int xC = wC + yC * ").concat(a," - ").concat(i,";\n\n                if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")},Conv3DDerInputProgram=function(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;var n=e.filterDepth,t=e.filterHeight,a=e.filterWidth,r=e.strideDepth,o=e.strideHeight,i=e.strideWidth,c=n-1-e.padInfo.front,s=t-1-e.padInfo.top,u=a-1-e.padInfo.left;this.userCode="\n      const ivec3 pads = ivec3(".concat(c,", ").concat(s,", ").concat(u,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ").concat(n,"; wF++) {\n          float dyF = float(dyFCorner + wF) / ").concat(r,".0;\n\n          if (dyF < 0.0 || dyF >= ").concat(e.outDepth,".0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ").concat(n," - 1 - wF;\n\n          for (int wR = 0; wR < ").concat(t,"; wR++) {\n            float dyR = float(dyRCorner + wR) / ").concat(o,".0;\n\n            if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ").concat(t," - 1 - wR;\n\n            for (int wC = 0; wC < ").concat(a,"; wC++) {\n              float dyC = float(dyCCorner + wC) / ").concat(i,".0;\n\n              if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ").concat(a," - 1 - wC;\n\n              for (int d2 = 0; d2 < ").concat(e.outChannels,"; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")},no={kernelName:p.Conv2DBackpropFilter,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.x,o=n.dy,i=a.strides,c=a.pad,s=a.dataFormat,u=a.dimRoundingMode,l=a.filterShape,d=p.backend_util.convertConv2DDataFormat(s),h=p.backend_util.computeConv2DInfo(r.shape,l,i,1,c,u,!1,d),f=new Conv2DDerFilterProgram(h);return t.runWebGLProgram(f,[r,o],"float32")}},Conv2DDerInputPackedProgram=function(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=useShapeUniforms(this.outputShape.length);var n=e.filterHeight,t=e.filterWidth,a=n-1-e.padInfo.top,r=t-1-e.padInfo.left;this.userCode="\n      const ivec2 pads = ivec2(".concat(a,", ").concat(r,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        vec4 result = vec4(0.);\n        for (int wR = 0; wR < ").concat(n,"; wR++) {\n          float dyR = float(dyRCorner + wR) / strides[0];\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n          int wRPerm = ").concat(n," - 1 - wR;\n\n          for (int wC = 0; wC < ").concat(t,"; wC++) {\n            int wCPerm = ").concat(t," - 1 - wC;\n\n            float dyC = float(dyCCorner + wC) / strides[1];\n            bool idyCVal = (dyC >= 0.0) && (dyC < ").concat(e.outWidth,".0)\n              && (fract(dyC) == 0.0);\n            int idyC = int(dyC);\n\n            float dyC2 = float(dyCCorner + wC + 1) / strides[1];\n            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ").concat(e.outWidth,".0)\n              && (fract(dyC2) == 0.0);\n            int idyC2 = int(dyC2);\n\n            if (idyCVal && idyCVal2) {\n              for (int d2 = 0; d2 < ").concat(e.outChannels,"; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?\n                  dySample : getDy(batch, idyR, idyC2, d2);\n\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n\n                dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample2.xy : dySample2.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal) {\n              for (int d2 = 0; d2 < ").concat(e.outChannels,"; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal2) {\n              for (int d2 = 0; d2 < ").concat(e.outChannels,"; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC2, d2);\n                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            }\n          }\n        }\n        setOutput(result);\n      }\n    ")},ni={kernelName:p.Conv2DBackpropInput,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.dy,o=n.filter,i=a.inputShape,c=a.strides,s=a.pad,u=a.dataFormat,l=a.dimRoundingMode,d=p.backend_util.convertConv2DDataFormat(u),h=p.backend_util.computeConv2DInfo(i,o.shape,c,1,s,l,!1,d);if(p.env().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&"channelsLast"===d){var f=[[h.strideHeight,h.strideWidth]],x=new Conv2DDerInputPackedProgram(h);return t.runWebGLProgram(x,[r,o],"float32",f)}var x=new Conv2DDerInputProgram(h);return t.runWebGLProgram(x,[r,o],"float32")}},nc={kernelName:p.Conv3D,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.x,o=n.filter,i=a.strides,c=a.pad,s=a.dilations,u=p.backend_util.computeConv3DInfo(r.shape,o.shape,i,s,c),l=new Conv3DProgram(u);return t.runWebGLProgram(l,[r,o],"float32")}},ns={kernelName:p.Conv3DBackpropFilterV2,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.x,o=n.dy,i=a.strides,c=a.pad,s=a.filterShape,u=p.backend_util.computeConv3DInfo(r.shape,s,i,1,c),l=new Conv3DDerFilterProgram(u);return t.runWebGLProgram(l,[r,o],"float32")}},nu={kernelName:p.Conv3DBackpropInputV2,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.dy,o=n.filter,i=a.pad,c=a.strides,s=a.inputShape,u=p.backend_util.computeConv3DInfo(s,o.shape,c,1,i),l=new Conv3DDerInputProgram(u);return t.runWebGLProgram(l,[r,o],"float32")}},nl=unaryKernelFunc({opSnippet:eh+"\n  return cos(x);\n",packedOpSnippet:"\n  vec4 result = cos(x);\n  bvec4 isNaN = isnan(x);\n  ".concat(er,"\n  return result;\n")}),nd={kernelName:p.Cos,backendName:"webgl",kernelFunc:nl},np=unaryKernelFunc({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),nh={kernelName:p.Cosh,backendName:"webgl",kernelFunc:np},CropAndResizeProgram=function(e,n,t,a,r){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];var o=__read(e,4),i=o[0],c=o[1],s=o[2],u=o[3],l=__read(n,1)[0],d=__read(t,2),p=d[0],h=d[1];this.outputShape=[l,p,h,u];var f=__read(["".concat(c-1,".0"),"".concat(s-1,".0")],2),x=f[0],m=f[1],g=__read(p>1?["".concat((c-1)/(p-1)),"(y2-y1) * height_ratio","y1*".concat(x," + float(y)*(height_scale)")]:["0.0","0.0","0.5 * (y1+y2) * ".concat(x)],3),v=g[0],b=g[1],C=g[2],y=__read(h>1?["".concat((s-1)/(h-1)),"(x2-x1) * width_ratio","x1*".concat(m," + float(x)*(width_scale)")]:["0.0","0.0","0.5 * (x1+x2) * ".concat(m)],3),k=y[0],I=y[1],T=y[2];this.userCode="\n      const float height_ratio = float(".concat(v,");\n      const float width_ratio = float(").concat(k,");\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ").concat(i,") {\n          return;\n        }\n\n        float height_scale = ").concat(b,";\n        float width_scale = ").concat(I,";\n\n        float in_y = ").concat(C,";\n        if( in_y < 0.0 || in_y > ").concat(x," ) {\n          setOutput(float(").concat(r,"));\n          return;\n        }\n        float in_x = ").concat(T,";\n        if( in_x < 0.0 || in_x > ").concat(m," ) {\n          setOutput(float(").concat(r,"));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(").concat("bilinear"===a?1:0," == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    ")},nf={kernelName:p.CropAndResize,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.image,o=n.boxes,i=n.boxInd,c=a.cropSize,s=a.method,u=a.extrapolationValue,l=new CropAndResizeProgram(r.shape,o.shape,c,s,u);return t.runWebGLProgram(l,[r,o,i],"float32")}};!function(e){e.Prod="*",e.Sum="+"}(s||(s={}));var CumProgram=function(e,n,t,a){this.op=e,this.outputShape=n,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];var r=this.outputShape.length,o=this.op===s.Prod?"1.0":"0.0",i=t?o:"getX(".concat(getCoords(r,"coords",this.op),")"),c=this.outputShape[this.outputShape.length-1],u="",l="";t?(u=a?"end != ".concat(c-1):"end != 0",l=a?"end + 1":"end - 1"):(u=a?"end + pow2 < ".concat(c):"end >= pow2",l=a?"end + pow2":"end - pow2"),this.userCode="\n      void main() {\n        ".concat(getCoordsDataType(r)," coords = getOutputCoords();\n        int end = ").concat(getFinalCoord(r,"coords",this.op),";\n        float val = ").concat(i,";\n        int pow2 = int(pow(2.0, index));\n        if (").concat(u,") {\n          int idx = ").concat(l,";\n          ").concat(getFinalCoord(r,"coords",this.op)," = idx;\n          val ").concat(this.op,"= getX(").concat(getCoords(r,"coords",this.op),");\n        }\n        setOutput(val);\n      }\n    ")};function getCoords(e,n,t){if(1===e)return"".concat(n);if(2===e)return"".concat(n,".x, ").concat(n,".y");if(3===e)return"".concat(n,".x, ").concat(n,".y, ").concat(n,".z");if(4===e)return"".concat(n,".x, ").concat(n,".y, ").concat(n,".z, ").concat(n,".w");throw Error("Cumulative ".concat(t," for rank ").concat(e," is not yet supported"))}function getFinalCoord(e,n,t){if(1===e)return"".concat(n);if(2===e)return"".concat(n,".y");if(3===e)return"".concat(n,".z");if(4===e)return"".concat(n,".w");throw Error("Cumulative ".concat(t," for rank ").concat(e," is not yet supported"))}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cumImpl(e,n,t,a,r,o){var i=n.shape.length,c=p.backend_util.getAxesPermutation([a],i),s=n;null!=c&&(s=transpose({inputs:{x:n},backend:t,attrs:{perm:c}}));var u=p.backend_util.getInnerMostAxes(1,i)[0];if(u!==i-1)throw Error("WebGL cumprod shader expects an inner-most axis=".concat(n.shape.length-1," ")+"but got axis=".concat(a));for(var l=s.shape[u],d=identity({inputs:{x:s},backend:t}),h=0;h<=Math.ceil(Math.log2(l))-1;h++){var f=new CumProgram(e,s.shape,!1,o),x=[[h]],m=d;d=t.runWebGLProgram(f,[d],d.dtype,x),t.disposeIntermediateTensorInfo(m)}if(r){var f=new CumProgram(e,s.shape,r,o),m=d;d=t.runWebGLProgram(f,[d],d.dtype),t.disposeIntermediateTensorInfo(m)}if(null!=c){var g=transpose({inputs:{x:d},backend:t,attrs:{perm:p.backend_util.getUndoAxesPermutation(c)}});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(s),g}return d}var nx={kernelName:p.Cumprod,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.x,o=a.axis,i=a.exclusive,c=a.reverse;return cumImpl(s.Prod,r,t,o,i,c)}},nm={kernelName:p.Cumsum,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.x,o=a.axis,i=a.exclusive,c=a.reverse;return cumImpl(s.Sum,r,t,o,i,c)}},ng={kernelName:p.DenseBincount,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.x,o=n.weights,i=a.size,c=a.binaryOutput;if(1===r.shape.length){var s=bincountImplCPU(t.readSync(r.dataId),t.readSync(o.dataId),o.dtype,o.shape,i);return t.makeTensorInfo([i],o.dtype,s)}if(2===r.shape.length){var u=bincountReduceImplCPU(t.bufferSync(r),t.bufferSync(o),i,c);return t.makeTensorInfo(u.shape,o.dtype,u.values)}throw Error("Error in denseBincount: input must be at most rank 2, but got rank"+"".concat(r.shape.length,"."))}},nv=function(){function DepthToSpaceProgram(e,n,t){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=n,this.dataFormat=t,this.userCode="\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ".concat(this.getHeightCoordString(),";\n      int w = ").concat(this.getWidthCoordString(),";\n      int d = ").concat(this.getDepthCoordString(),";\n\n      int in_h = h / ").concat(n,";\n      int offset_h = imod(h, ").concat(n,");\n      int in_w = w / ").concat(n,";\n      int offset_w = imod(w, ").concat(n,");\n      int offset_d = (offset_h * ").concat(n," + offset_w) *\n        ").concat(this.getOutputDepthSize(),";\n      int in_d = d + offset_d;\n\n      float result = ").concat(this.getInputSamplingString(),";\n      setOutput(result);\n    }\n  ")}return DepthToSpaceProgram.prototype.getHeightCoordString=function(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"},DepthToSpaceProgram.prototype.getWidthCoordString=function(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"},DepthToSpaceProgram.prototype.getDepthCoordString=function(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"},DepthToSpaceProgram.prototype.getOutputDepthSize=function(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]},DepthToSpaceProgram.prototype.getInputSamplingString=function(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"},DepthToSpaceProgram}(),nb={kernelName:p.DepthToSpace,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.x,o=a.blockSize,i=a.dataFormat,c=r.shape[0],s="NHWC"===i?r.shape[1]:r.shape[2],u="NHWC"===i?r.shape[2]:r.shape[3],l="NHWC"===i?r.shape[3]:r.shape[1],d=s*o,p=u*o,h=l/(o*o),f="NHWC"===i?[c,d,p,h]:[c,h,d,p],x=new nv(f,o,i);return t.runWebGLProgram(x,[r],r.dtype)}},DepthwiseConv2DProgram=function(e,n,t,a,r){void 0===n&&(n=!1),void 0===t&&(t=null),void 0===a&&(a=!1),void 0===r&&(r=!1),this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=useShapeUniforms(this.outputShape.length);var o=e.filterHeight,i=e.filterWidth,c=e.outChannels/e.inChannels,s="",u="";t&&(s=a?"float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ".concat(t,"\n        }"):r?"float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ".concat(t,"\n        }"):"\n          float activation(float x) {\n            ".concat(t,"\n          }\n        "),u="result = activation(result);");var l=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n      ".concat(s,"\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ").concat(c,";\n        int q = d2 - d1 * ").concat(c,";\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ").concat(o,"; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ").concat(i,"; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ").concat(l,"\n        ").concat(u,"\n        setOutput(result);\n      }\n    ")},DepthwiseConvPacked2DProgram=function(e,n,t,a,r){void 0===n&&(n=!1),void 0===t&&(t=null),void 0===a&&(a=!1),void 0===r&&(r=!1),this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=useShapeUniforms(this.outputShape.length);for(var o=e.outChannels/e.inChannels,i=e.padInfo.left,c=e.strideWidth,s=e.dilationWidth,u=e.filterHeight,l=e.filterWidth,d="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;",h=0;h<l;h++)d+="\n          vec4 xTexelC".concat(2*h,";\n          int xTexelC").concat(2*h,"Ready;\n          vec4 xTexelC").concat(2*h+1,";\n          int xTexelC").concat(2*h+1,"Ready;\n          vec4 xC").concat(h,";");d+="\n    for (int r = 0; r < ".concat(u,"; r++) {\n      ");for(var h=0;h<l;h++)d+="\n          xTexelC".concat(2*h," = vec4(0.0);\n          xTexelC").concat(2*h,"Ready = 0;\n          xTexelC").concat(2*h+1," = vec4(0.0);\n          xTexelC").concat(2*h+1,"Ready = 0;\n          xC").concat(h," = vec4(0.0);");d+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(var f=0;f<(l+1)/2;f++){var x=2*f;if(d+="\n          xC = xCCorner + ".concat(x*s,";\n          "),1===c){if(x<l&&(i%2==1?(d+="\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(x,"Ready == 0) {\n                  xTexelC").concat(x," = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC").concat(x,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(x,"Ready = 1;\n                }\n              "),1===s&&x>0?d+="\n                xC".concat(x," = vec4(xTexelC").concat(x-2,".zw, xTexelC").concat(x,".xy);\n                "):d+="\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC".concat(x," = vec4(previous.zw, xTexelC").concat(x,".xy);\n                  } else {\n                    xC").concat(x," = vec4(0.0, 0.0, xTexelC").concat(x,".xy);\n                  }\n                  ")):d+="\n                if (xC >= 0 && xC < inDims[1] && xTexelC".concat(x,"Ready == 0) {\n                  xTexelC").concat(x," = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC").concat(x,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(x,"Ready = 1;\n                }\n\n                xC").concat(x," = xTexelC").concat(x,";\n                "),x+1<l)){var m=i%2==0?p.util.nearestLargerEven(s):s;s%2==0&&i%2==1||s%2!=0&&i%2!=1?(d+="\n                  xCOffset = xC + imod(pads[1], 2) + ".concat(m,";\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(x+1,"Ready == 0) {\n                    xTexelC").concat(x+1," = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC").concat(x+1,".zw = vec2(0.0);\n                    }\n                    xTexelC").concat(x+1,"Ready = 1;\n                  }\n                  "),s>1?d+="\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC".concat(x+1," = vec4(previous.zw, xTexelC").concat(x+1,".xy);\n                    } else {\n                     xC").concat(x+1," = vec4(0.0, 0.0, xTexelC").concat(x+1,".xy);\n                    }\n                    "):d+="\n                    xC".concat(x+1," = vec4(xTexelC").concat(x,".zw, xTexelC").concat(x+1,".xy);\n                    ")):1===m?d+="\n                    xC".concat(x+1," = xTexelC").concat(x,";\n                    "):d+="\n                    xCOffset = xC + ".concat(m,";\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(x+1,"Ready == 0) {\n                      xTexelC").concat(x+1," = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC").concat(x+1,".zw = vec2(0.0);\n                      }\n                      xTexelC").concat(x+1,"Ready = 1;\n                    }\n\n                    xC").concat(x+1," = xTexelC").concat(x+1,";\n                    ")}}else x<l&&(i%2==1?(d+="\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(x,"Ready == 0) {\n                  xTexelC").concat(x," = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC").concat(x,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(x,"Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC").concat(x+1,"Ready == 0) {\n                  xTexelC").concat(x+1," = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC").concat(x+1,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(x+1,"Ready = 1;\n                }\n\n                xC").concat(x," = vec4(xTexelC").concat(x,".zw, xTexelC").concat(x+1,".zw);\n              "),x+1<l&&(d+="\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC".concat(x+1," = vec4(xTexelC").concat(x+1,".xy, final.xy);\n                "))):(d+="\n                if(xC >= 0 && xC < inDims[1] && xTexelC".concat(x,"Ready == 0) {\n                  xTexelC").concat(x," = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC").concat(x,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(x,"Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(x+1,"Ready == 0) {\n                  xTexelC").concat(x+1," = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC").concat(x+1,".zw = vec2(0.);\n                  }\n                  xTexelC").concat(x+1,"Ready = 1;\n                }\n\n                xC").concat(x," = vec4(\n                  xTexelC").concat(x,".xy, xTexelC").concat(x+1,".xy);\n              "),x+1<l&&(d+="\n                  xC".concat(x+1," = vec4(xTexelC").concat(x,".zw, xTexelC").concat(x+1,".zw);\n                "))));x<l&&(d+="\n            wTexel = getW(r, ".concat(x,", d1, q);\n            dotProd += xC").concat(x," * vec4(wTexel.xz, wTexel.xz);\n          "),x+1<l&&(d+="\n              wTexel = getW(r, ".concat(x+1,", d1, q);\n              dotProd += xC").concat(x+1," * vec4(wTexel.xz, wTexel.xz);\n            ")))}d+="\n    }\n  \n      }\n    ";var g="",v="";t&&(g=a?"vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ".concat(t,"\n        }"):r?"vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ".concat(t,"\n        }"):"vec4 activation(vec4 x) {\n          ".concat(t,"\n        }"),v="result = activation(result);");var b=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n      ".concat(g,"\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ").concat(o,";\n        int q = d2 - d1 * ").concat(o,";\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ").concat(d,"\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ").concat(b,"\n        ").concat(v,"\n        setOutput(result);\n      }\n    ")},nC={kernelName:p.DepthwiseConv2dNative,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var n,t=e.inputs,a=e.backend,r=e.attrs,o=t.x,i=t.filter,c=r.strides,s=r.pad,u=r.dilations,l=r.dimRoundingMode,d=u;null==d&&(d=[1,1]),p.util.assert(p.backend_util.eitherStridesOrDilationsAreOne(c,d),function(){return"Error in depthwiseConv2d: Either strides or dilations must be "+"1. Got strides ".concat(c," and dilations '").concat(d,"'")});var h=p.backend_util.computeConv2DInfo(o.shape,i.shape,c,d,s,l,!0);n=p.env().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels==1?new DepthwiseConvPacked2DProgram(h):new DepthwiseConv2DProgram(h);var f=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];return a.runWebGLProgram(n,[o,i],"float32",f)}},DepthwiseConv2DDerFilterProgram=function(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;var n=e.strideHeight,t=e.strideWidth,a=e.padInfo.top,r=e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ".concat(o," + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ").concat(e.batchSize,"; b++) {\n          for (int yR = 0; yR < ").concat(e.outHeight,"; yR++) {\n            int xR = wR + yR * ").concat(n," - ").concat(a,";\n\n            if (xR < 0 || xR >= ").concat(e.inHeight,") {\n              continue;\n            }\n\n            for (int yC = 0; yC < ").concat(e.outWidth,"; yC++) {\n              int xC = wC + yC * ").concat(t," - ").concat(r,";\n\n              if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")},DepthwiseConv2DDerInputProgram=function(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;var n=e.filterHeight,t=e.filterWidth,a=e.strideHeight,r=e.strideWidth,o=n-1-e.padInfo.top,i=t-1-e.padInfo.left,c=e.outChannels/e.inChannels;this.userCode="\n      const ivec2 pads = ivec2(".concat(o,", ").concat(i,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ").concat(n,"; wR++) {\n          float dyR = float(dyRCorner + wR) / ").concat(a,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ").concat(n," - 1 - wR;\n\n          for (int wC = 0; wC < ").concat(t,"; wC++) {\n            float dyC = float(dyCCorner + wC) / ").concat(r,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ").concat(t," - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ").concat(c,"; dm++) {\n              int d2 = d1 * ").concat(c," + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")},ny={kernelName:p.DepthwiseConv2dNativeBackpropFilter,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.x,o=n.dy,i=a.strides,c=a.dilations,s=a.pad,u=a.dimRoundingMode,l=a.filterShape,d=p.backend_util.computeConv2DInfo(r.shape,l,i,c,s,u,!0),h=new DepthwiseConv2DDerFilterProgram(d);return t.runWebGLProgram(h,[r,o],"float32")}},nk={kernelName:p.DepthwiseConv2dNativeBackpropInput,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.dy,o=n.filter,i=a.strides,c=a.dilations,s=a.pad,u=a.dimRoundingMode,l=a.inputShape,d=p.backend_util.computeConv2DInfo(l,o.shape,i,c,s,u,!0),h=new DepthwiseConv2DDerInputProgram(d);return t.runWebGLProgram(h,[r,o],"float32")}},DiagProgram=function(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "},nI={kernelName:p.Diag,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=n.x,r=__spreadArray(__spreadArray([],__read(a.shape),!1),__read(a.shape),!1),o=p.util.sizeFromShape(a.shape),i=reshape({inputs:{x:a},backend:t,attrs:{shape:[o]}}),c=new DiagProgram(o),s=t.runWebGLProgram(c,[i],i.dtype),u=reshape({inputs:{x:s},backend:t,attrs:{shape:r}});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(s),u}},Dilation2DProgram=function(e){this.variableNames=["x","W"],this.outputShape=e.outShape;var n=e.inHeight,t=e.inWidth,a=e.padInfo,r=e.strideHeight,o=e.strideWidth,i=e.filterHeight,c=e.filterWidth,s=e.dilationHeight,u=e.dilationWidth,l=a.top,d=a.left;this.userCode="\n      const ivec2 strides = ivec2(".concat(r,", ").concat(o,");\n      const ivec2 pads = ivec2(").concat(l,", ").concat(d,");\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ").concat(i,"; h++) {\n          int hIn = hBeg + h * ").concat(s,";\n\n          if (hIn >= 0 && hIn < ").concat(n,") {\n            for (int w = 0; w < ").concat(c,"; w++) {\n              int wIn = wBeg + w * ").concat(u,";\n\n              if (wIn >= 0 && wIn < ").concat(t,") {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    ")},nT={kernelName:p.Dilation2D,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var n,t=e.inputs,a=e.backend,r=e.attrs,o=t.x,i=t.filter,c=r.strides,s=r.pad,u=r.dilations,l=p.backend_util.computeDilation2DInfo(o.shape,i.shape,c,s,"NHWC",u),d=new Dilation2DProgram(l),h=reshape({inputs:{x:n=a.runWebGLProgram(d,[o,i],"float32")},backend:a,attrs:{shape:l.outShape}});return a.disposeIntermediateTensorInfo(n),h}},nS={kernelName:p.Einsum,backendName:"webgl",kernelFunc:function(e){var n,t,a,r,o=e.inputs,i=e.backend,c=e.attrs.equation,s=p.backend_util.decodeEinsumEquation(c,o.length),u=s.allDims,l=s.summedDims,d=s.idDims;p.backend_util.checkEinsumDimSizes(u.length,d,o);for(var h=p.backend_util.getEinsumComputePath(l,d),f=h.path,x=h.steps,m=x.length,g=null,v=u.length,b=[],C=0;C<m;++C){try{for(var y=(n=void 0,__values(x[C])),k=y.next();!k.done;k=y.next()){var I=k.value,T=p.backend_util.getEinsumPermutation(v,d[I]),S=T.permutationIndices,R=T.expandDims,w=void 0;p.backend_util.isIdentityPermutation(S)?w=o[I]:(w=transpose({inputs:{x:o[I]},backend:i,attrs:{perm:S}}),b.push(w));for(var P=w.shape.slice(),_=0;_<R.length;++_)P.splice(R[_],0,1);p.util.arraysEqual(w.shape,P)||(w=reshape({inputs:{x:w},backend:i,attrs:{shape:P}}),b.push(w)),null===g?g=w:(g=multiply({inputs:{a:w,b:g},backend:i}),b.push(g))}}catch(e){n={error:e}}finally{try{k&&!k.done&&(t=y.return)&&t.call(y)}finally{if(n)throw n.error}}C<m-1&&(f[C]>=0&&(g=sum({inputs:{x:g},backend:i,attrs:{axis:f[C]-(u.length-v),keepDims:!1}}),b.push(g)),v--)}try{for(var E=__values(b),F=E.next();!F.done;F=E.next()){var N=F.value;N!==g&&i.disposeIntermediateTensorInfo(N)}}catch(e){a={error:e}}finally{try{F&&!F.done&&(r=E.return)&&r.call(E)}finally{if(a)throw a.error}}return g}},nR=unaryKernelFunc({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),nw={kernelName:p.Elu,backendName:"webgl",kernelFunc:nR},nP={kernelName:p.EluGrad,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=n.dy,r=n.y,o=p.env().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new BinaryOpPackedProgram("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",a.shape,r.shape):new BinaryOpProgram("return (b >= 0.0) ? a : a * (b + 1.0);",a.shape,r.shape);return t.runWebGLProgram(o,[a,r],a.dtype)}},n_=binaryKernelFunc({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:S}),nE={kernelName:p.Equal,backendName:"webgl",kernelFunc:n_},nF=unaryKernelFunc({opSnippet:'\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = '.concat(p.backend_util.ERF_P,";\n  float a1 = ").concat(p.backend_util.ERF_A1,";\n  float a2 = ").concat(p.backend_util.ERF_A2,";\n  float a3 = ").concat(p.backend_util.ERF_A3,";\n  float a4 = ").concat(p.backend_util.ERF_A4,";\n  float a5 = ").concat(p.backend_util.ERF_A5,";\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n")}),nN={kernelName:p.Erf,backendName:"webgl",kernelFunc:nF},nA=unaryKernelFunc({opSnippet:eh+"\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:R,dtype:"float32"}),nO={kernelName:p.Exp,backendName:"webgl",kernelFunc:nA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function expandDims(e){var n=e.inputs,t=e.attrs,a=e.backend,r=t.dim,o=n.input,i=o.shape.length,c=o.shape.slice(),s=r;return r<0&&(p.util.assert(-(i+1)<=r,function(){return"Axis must be in the interval [".concat(-(i+1),", ").concat(i,"]")}),s=i+r+1),c.splice(s,0,1),reshape({inputs:{x:o},backend:a,attrs:{shape:c}})}var nD={kernelName:p.ExpandDims,backendName:"webgl",kernelFunc:expandDims},nL="return exp(x) - 1.0;",nB=unaryKernelFunc({opSnippet:nL,packedOpSnippet:nL,cpuKernelImpl:w}),nU={kernelName:p.Expm1,backendName:"webgl",kernelFunc:nB},FFTProgram=function(e,n,t){this.variableNames=["real","imag"];var a,r=n[1];this.outputShape=n;var o=t?"2.0 * ".concat(Math.PI):"-2.0 * ".concat(Math.PI),i=t?"".concat(r,".0"):"1.0";if("real"===e)a="return real * expR - imag * expI;";else if("imag"===e)a="return real * expI + imag * expR;";else throw Error('FFT component must be either "real" or "imag", got '.concat(e,"."));this.userCode="\n      const float exponentMultiplier = ".concat(o,";\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ").concat(a,"\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(").concat(r,");\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ").concat(r,"; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ").concat(i,";\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    ")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fftImpl(e,n,t){var a=t.texData.get(e.dataId),r=p.util.sizeFromShape(e.shape),o=e.shape[e.shape.length-1],i=reshape({inputs:{x:e},backend:t,attrs:{shape:[r/o,o]}}),c=i.shape,s=new FFTProgram("real",c,n),u=new FFTProgram("imag",c,n),l=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:c},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:c}],d=t.runWebGLProgram(s,l,"float32"),h=t.runWebGLProgram(u,l,"float32"),f=complex({inputs:{real:d,imag:h},backend:t});t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(h);var x=reshape({inputs:{x:f},backend:t,attrs:{shape:e.shape}});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(f),x}var nG={kernelName:p.FFT,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var n=e.inputs,t=e.backend;return fftImpl(n.input,!1,t)}},FillProgram=function(e,n){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fill(e){var n=e.backend,t=e.attrs,a=t.shape,r=t.value,o=t.dtype;if("string"===(o=o||p.util.inferDtype(r))){var i=p.util.getArrayFromDType(o,p.util.sizeFromShape(a));return i.fill(r),n.makeTensorInfo(a,o,i)}var c=new FillProgram(a,r),s=[[r]];return n.runWebGLProgram(c,[],o,s)}var nM={kernelName:p.Fill,backendName:"webgl",kernelFunc:fill},FlipLeftRightProgram=function(e){this.variableNames=["Image"],this.outputShape=[];var n=e[2];this.outputShape=e,this.userCode="\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ".concat(n," - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ").concat(n,") {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    ")},nW={kernelName:p.FlipLeftRight,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=n.image,r=new FlipLeftRightProgram(a.shape);return t.runWebGLProgram(r,[a],a.dtype)}},nV="return floor(x);",nz=unaryKernelFunc({opSnippet:nV,packedOpSnippet:nV,cpuKernelImpl:P}),nX={kernelName:p.Floor,backendName:"webgl",kernelFunc:nz},nH=binaryKernelFunc({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),nK={kernelName:p.FloorDiv,backendName:"webgl",kernelFunc:nH},FromPixelsProgram=function(e){this.variableNames=["A"];var n=getGlslDifferences(),t=__read(e,2),a=t[0],r=t[1];this.outputShape=e,this.userCode="\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(".concat(r,".0, ").concat(a,".0);\n\n        vec4 values = ").concat(n.texture2D,"(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    ")},FromPixelsPackedProgram=function(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;var n=getGlslDifferences(),t=__read(e,2),a=t[0],r=t[1];this.outputShape=e,this.userCode="\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(".concat(r,".0, ").concat(a,".0);\n            vec4 values = ").concat(n.texture2D,"(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ").concat(n.output," = result;\n      }\n    ")},nj={kernelName:p.FromPixels,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,o=n.pixels,i=a.numChannels,c="undefined"!=typeof HTMLVideoElement&&o instanceof HTMLVideoElement,s="undefined"!=typeof HTMLImageElement&&o instanceof HTMLImageElement,l=__read(c?[o.videoWidth,o.videoHeight]:[o.width,o.height],2),d=l[0],h=l[1],f=[h,d],x=[h,d,i];if(s||c){var m=p.env().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(null==u||m!==nq)&&(nq=m,u=document.createElement("canvas").getContext("2d",{willReadFrequently:nq})),u.canvas.width=d,u.canvas.height=h,u.drawImage(o,0,0,d,h),o=u.canvas}var g=t.makeTensorInfo(f,"int32");t.texData.get(g.dataId).usage=r.PIXELS,t.gpgpu.uploadPixelDataToTexture(t.getTexture(g.dataId),o);var v=p.env().getBool("WEBGL_PACK")?new FromPixelsPackedProgram(x):new FromPixelsProgram(x),b=t.runWebGLProgram(v,[g],"int32");return t.disposeData(g.dataId),b}},nq=p.env().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU"),nY={kernelName:p.FusedConv2D,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var n,t=e.inputs,a=e.backend,r=e.attrs,o=t.x,i=t.filter,c=t.bias,s=t.preluActivationWeights,u=r.strides,l=r.pad,d=r.dataFormat,h=r.dilations,f=r.dimRoundingMode,x=r.activation,m=r.leakyreluAlpha,g=p.backend_util.convertConv2DDataFormat(d),v=p.backend_util.computeConv2DInfo(o.shape,i.shape,u,h,l,f,!1,g),b=[],C=null!=c,y=null!=s,k="leakyrelu"===x,prepareInputs=function(){var e=[o,i],alignInputWithDataFormat=function(e,n){if("NCHW"===n&&1===e.shape.length&&1!==e.shape[0]){var t=reshape({inputs:{x:e},backend:a,attrs:{shape:[e.shape[0],1,1]}});return b.push(t),t}return e};if(C&&e.push(alignInputWithDataFormat(c,d)),y&&e.push(alignInputWithDataFormat(s,d)),k){var n=a.makeTensorInfo([],"float32",p.util.createScalarValue(m,"float32"));e.push(n),b.push(n)}return e};if(1===v.filterHeight&&1===v.filterWidth&&1===v.dilationHeight&&1===v.dilationWidth&&1===v.strideHeight&&1===v.strideWidth&&("SAME"===v.padInfo.type||"VALID"===v.padInfo.type))n=conv2dByMatMul({x:o,filter:i,convInfo:v,backend:a,bias:c,activation:x,preluActivationWeights:s,leakyreluAlpha:m});else if(v.strideWidth<=2&&"channelsLast"===g&&p.env().getBool("WEBGL_EXP_CONV")){var I=x?mapActivationToShaderProgram(x,!0):null,T=new Conv2DPackedProgram(v,C,I,y,k),S=[[v.padInfo.top,v.padInfo.left],[v.strideHeight,v.strideWidth],[v.dilationHeight,v.dilationWidth],[v.inHeight,v.inWidth]],R=prepareInputs();n=a.runWebGLProgram(T,R,"float32",S)}else if(p.env().getBool("WEBGL_CONV_IM2COL"))n=conv2dWithIm2Row({x:o,filter:i,convInfo:v,backend:a,bias:c,activation:x,preluActivationWeights:s,leakyreluAlpha:m});else{var I=x?mapActivationToShaderProgram(x,!1):null,T=new Conv2DProgram(v,C,I,y,k),w=prepareInputs();n=a.runWebGLProgram(T,w,"float32")}var P=reshape({inputs:{x:n},backend:a,attrs:{shape:v.outShape}});return b.push(n),b.forEach(function(e){return a.disposeIntermediateTensorInfo(e)}),P}},nQ={kernelName:p.FusedDepthwiseConv2D,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var n,t=e.inputs,a=e.backend,r=e.attrs,o=t.x,i=t.filter,c=t.bias,s=t.preluActivationWeights,u=r.strides,l=r.pad,d=r.dilations,h=r.dimRoundingMode,f=r.activation,x=r.leakyreluAlpha,m=[],g=d;null==g&&(g=[1,1]),p.util.assert(p.backend_util.eitherStridesOrDilationsAreOne(u,g),function(){return"Error in depthwiseConv2d: Either strides or dilations must be "+"1. Got strides ".concat(u," and dilations '").concat(g,"'")});var v=p.backend_util.computeConv2DInfo(o.shape,i.shape,u,g,l,h,!0),b=p.env().getBool("WEBGL_PACK_DEPTHWISECONV")&&v.strideWidth<=2&&v.outChannels/v.inChannels==1,C=f?mapActivationToShaderProgram(f,b):null,y=[o,i],k=null!=c,I=null!=s,T="leakyrelu"===f;if(k&&y.push(c),I&&y.push(s),T){var S=a.makeTensorInfo([],"float32",p.util.createScalarValue(x,"float32"));y.push(S),m.push(S)}n=b?new DepthwiseConvPacked2DProgram(v,k,C,I,T):new DepthwiseConv2DProgram(v,k,C,I,T);var R=[[v.padInfo.top,v.padInfo.left],[v.strideHeight,v.strideWidth],[v.dilationHeight,v.dilationWidth],[v.inHeight,v.inWidth]],w=a.runWebGLProgram(n,y,"float32",R);return m.forEach(function(e){return a.disposeIntermediateTensorInfo(e)}),w}},GatherNDProgram=function(e,n,t,a){this.sliceDim=e,this.strides=n,this.paramsShape=a,this.variableNames=["x","indices"],this.outputShape=t;for(var r=getCoordsDataType(t.length),o="\n    int index;",i=0;i<this.sliceDim;i++)o+="\n          index = round(getIndices(coords[0], ".concat(i,"));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ").concat(this.paramsShape[i],";\n          flattenIndex += index * ").concat(this.strides[i],";");this.userCode="\n         void main() {\n          ".concat(r," coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ").concat(o,"\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      ")},nZ={kernelName:p.GatherNd,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=n.params,r=n.indices,o=r.shape,i=o[o.length-1],c=p.util.sizeFromShape(a.shape),s=__read(p.backend_util.prepareAndValidate(a,r),4),u=s[0],l=s[1],d=s[2],h=s[3],f=reshape({inputs:{x:r},backend:t,attrs:{shape:[l,i]}}),x=reshape({inputs:{x:a},backend:t,attrs:{shape:[p.util.sizeFromShape(a.shape)/d,d]}});if(t.shouldExecuteOnCPU([a,r])||"string"===a.dtype){var m=gatherNdImplCPU(t.readSync(r.dataId),t.bufferSync(a),a.dtype,l,i,d,h,a.shape,c);return t.makeTensorInfo(u,a.dtype,m.values)}var g=new GatherNDProgram(i,h,[l,d],a.shape),v=t.runWebGLProgram(g,[x,f],x.dtype),b=reshape({inputs:{x:v},backend:t,attrs:{shape:u}});return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(v),b}},GatherProgram=function(e,n){this.variableNames=["A","indices"],this.outputShape=n,this.rank=n.length;var t=getCoordsDataType(this.rank),a=function(e,n){for(var t=["resRC.x","resRC.y","resRC.z","resRC.w"],a=[],r=0;r<e.length;r++)2===r?a.push("index"):a.push("".concat(t[r]));return a.join()}(e);this.userCode="\n      void main() {\n        ".concat(t," resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ").concat(e[2],") ? 1.0 : 0.0;\n        setOutput(inBounds * getA(").concat(a,"));\n      }\n    ")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gatherV2(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.x,o=n.indices,i=a.axis,c=a.batchDims,s=p.util.parseAxisParam(i,r.shape)[0];if(p.env().get("DEBUG"))for(var u=t.readSync(o.dataId),l=r.shape[s],d=0;d<u.length;++d)!function(e){var n=u[e];p.util.assert(n<=l-1&&n>=0,function(){return"GatherV2: the index value ".concat(n," is not in [0, ").concat(l-1,"]")})}(d);var h=p.backend_util.segment_util.collectGatherOpShapeInfo(r,o,s,c),f=p.util.sizeFromShape(o.shape),x=[],m=reshape({inputs:{x:r},backend:t,attrs:{shape:[h.batchSize,h.outerSize,h.dimSize,h.sliceSize]}}),g=reshape({inputs:{x:o},backend:t,attrs:{shape:[h.batchSize,f/h.batchSize]}});x.push(m),x.push(g);var v=[h.batchSize,h.outerSize,f/h.batchSize,h.sliceSize];if(t.shouldExecuteOnCPU([r,o])||"string"===r.dtype){var b=t.bufferSync(g),C=gatherV2ImplCPU(t.bufferSync(m),b,v);return x.forEach(function(e){return t.disposeIntermediateTensorInfo(e)}),t.makeTensorInfo(h.outputShape,C.dtype,C.values)}var y=new GatherProgram(m.shape,v),k=t.runWebGLProgram(y,[m,g],m.dtype);x.push(k);var I=reshape({inputs:{x:k},backend:t,attrs:{shape:h.outputShape}});return x.forEach(function(e){return t.disposeIntermediateTensorInfo(e)}),I}var nJ={kernelName:p.GatherV2,backendName:"webgl",kernelFunc:gatherV2},n$=binaryKernelFunc({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:_,dtype:"bool"}),n0={kernelName:p.Greater,backendName:"webgl",kernelFunc:n$},n1=binaryKernelFunc({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:E}),n2={kernelName:p.GreaterEqual,backendName:"webgl",kernelFunc:n1},n4={kernelName:p.IFFT,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var n=e.inputs,t=e.backend;return fftImpl(n.input,!0,t)}},n3=unaryKernelFunc({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),n5={kernelName:p.IsFinite,backendName:"webgl",kernelFunc:n3},n6=unaryKernelFunc({opSnippet:"return float(isinf(x));",dtype:"bool"}),n8={kernelName:p.IsInf,backendName:"webgl",kernelFunc:n6},n7=unaryKernelFunc({opSnippet:"return float(isnan(x));",dtype:"bool"}),n9={kernelName:p.IsNan,backendName:"webgl",kernelFunc:n7},te=binaryKernelFunc({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:F,dtype:"bool"}),tn={kernelName:p.Less,backendName:"webgl",kernelFunc:te},tt=binaryKernelFunc({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:N,dtype:"bool"}),ta={kernelName:p.LessEqual,backendName:"webgl",kernelFunc:tt},tr={kernelName:p.LinSpace,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var n=e.backend,t=e.attrs,a=linSpaceImplCPU(t.start,t.stop,t.num);return n.makeTensorInfo([a.length],"float32",a)}},to=unaryKernelFunc({opSnippet:eh+"\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:A}),ti={kernelName:p.Log,backendName:"webgl",kernelFunc:to},tc=unaryKernelFunc({opSnippet:eh+"\n  return log(1.0 + x);\n"}),ts={kernelName:p.Log1p,backendName:"webgl",kernelFunc:tc},tu=binaryKernelFunc({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),tl={kernelName:p.LogicalAnd,backendName:"webgl",kernelFunc:tu},td=unaryKernelFunc({opSnippet:"return float(!(x >= 1.0));"}),tp={kernelName:p.LogicalNot,backendName:"webgl",kernelFunc:td},th=binaryKernelFunc({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),tf={kernelName:p.LogicalOr,backendName:"webgl",kernelFunc:th},LRNProgram=function(e,n,t,a,r){this.variableNames=["x"],this.outputShape=[];var o,i=e[3]-1;this.outputShape=e;var c="float(".concat(t,") + float(").concat(a,") * sum");o=.5===r?"inversesqrt(".concat(c,")"):1===r?"1.0/(".concat(c,")"):"exp(log(".concat(c,") * float(-").concat(r,"));"),this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -".concat(n,"; j <= ").concat(n,"; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ").concat(i,") {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ").concat(o,";\n        setOutput(val);\n      }\n    ")},LRNPackedProgram=function(e,n,t,a,r){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;var o,i=e[3]-1;this.outputShape=e;var c="float(".concat(t,") + float(").concat(a,") * sum");o=.5===r?"inversesqrt(".concat(c,")"):1===r?"1.0/(".concat(c,")"):"exp(log(".concat(c,") * float(-").concat(r,"));"),this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ".concat(this.outputShape[3],";\n        bool hasNextRow = c < ").concat(this.outputShape[2],";\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ").concat(n,";\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ").concat(n,"; j <= ").concat(n,"; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(").concat(i,"));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ").concat(o,";\n        setOutput(result);\n      }\n    ")},tx={kernelName:p.LRN,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.x,o=a.depthRadius,i=a.bias,c=a.alpha,s=a.beta,u=p.env().getBool("WEBGL_PACK_NORMALIZATION")?new LRNPackedProgram(r.shape,o,i,c,s):new LRNProgram(r.shape,o,i,c,s);return t.runWebGLProgram(u,[r],r.dtype)}},LRNGradProgram=function(e,n,t,a,r){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=n,this.bias=t,this.alpha=a,this.beta=r,this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ".concat(this.depth,"; ++d) {\n          int depthBegin = int(max(0.0, float(d - ").concat(n,")));\n          int depthEnd = int(min(float(").concat(this.depth,"),\n              float(d + ").concat(n," + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ").concat(this.depth,";\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(").concat(a,") * norm + float(").concat(t,");\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(").concat(a,")\n                * float(").concat(r,")\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ").concat(r,");\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    ")},tm={kernelName:p.LRNGrad,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.x,o=n.y,i=n.dy,c=a.depthRadius,s=a.bias,u=a.alpha,l=a.beta,d=new LRNGradProgram(r.shape,c,s,u,l);return t.runWebGLProgram(d,[r,o,i],r.dtype)}};function max(e){var n,t,a,r,o,i,c,s,u=e.inputs,l=e.backend,d=e.attrs,h=u.x,f=d.reductionIndices,x=d.keepDims,m=h.shape.length,g=p.util.parseAxisParam(f,h.shape),v=g,b=p.backend_util.getAxesPermutation(v,m),C=null!=b,y=l.shouldExecuteOnCPU([h]),k=h;if(C){if(y){for(var I=l.texData.get(k.dataId),T=I.values,S=Array(m),R=0;R<S.length;R++)S[R]=h.shape[b[R]];var w=transposeImplCPU(T,h.shape,h.dtype,b,S);k=l.makeTensorInfo(S,h.dtype),l.texData.get(k.dataId).values=w}else k=transposeImpl(h,b,l);v=p.backend_util.getInnerMostAxes(v.length,m)}p.backend_util.assertAxesAreInnerMostDims("max",v,m);var P=__read(p.backend_util.computeOutAndReduceShapes(k.shape,v),2),_=P[0],E=P[1],F=_;if(x&&(F=p.backend_util.expandShapeToKeepDim(_,g)),y){var I=l.texData.get(k.dataId),T=I.values,N=maxImplCPU(T,p.util.sizeFromShape(E),F,h.dtype);s=l.makeTensorInfo(F,h.dtype),l.texData.get(s.dataId).values=N}else n=k,t=F,a=p.util.sizeFromShape(E),r=p.util.sizeFromShape(n.shape)/a,i=reduce(o=reshape({inputs:{x:n},attrs:{shape:[r,a]},backend:l}),n.dtype,"max",l),c=reshape({inputs:{x:i},attrs:{shape:t},backend:l}),l.disposeIntermediateTensorInfo(o),l.disposeIntermediateTensorInfo(i),s=c;return C&&l.disposeIntermediateTensorInfo(k),s}var tg={kernelName:p.Max,backendName:"webgl",kernelFunc:max},tv=binaryKernelFunc({opSnippet:ea+"\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+er+"\n  return result;\n",cpuKernelImpl:O}),tb={kernelName:p.Maximum,backendName:"webgl",kernelFunc:tv},tC={kernelName:p.MaxPool,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.x;assertNotComplex(r,"maxPool");var o=a.filterSize,i=a.strides,c=a.pad,s=a.dimRoundingMode;p.util.assert(p.backend_util.eitherStridesOrDilationsAreOne(i,1),function(){return"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(i," and dilations '").concat(1,"'")});var u=p.backend_util.computePool2DInfo(r.shape,o,i,1,c,s);if(1===u.filterWidth&&1===u.filterHeight&&p.util.arraysEqual(u.inShape,u.outShape))return identity({inputs:{x:r},backend:t});var l=new Pool2DProgram(u,"max",!1);return t.runWebGLProgram(l,[r],r.dtype)}},ty={kernelName:p.MaxPool3D,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.x,o=a.filterSize,i=a.strides,c=a.pad,s=a.dataFormat,u=a.dimRoundingMode,l=p.backend_util.computePool3DInfo(r.shape,o,i,[1,1,1],c,u,s),d=new Pool3DProgram(l,"max",!1);return t.runWebGLProgram(d,[r],r.dtype)}},MaxPool2DBackpropProgram=function(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;var n=e.strideHeight,t=e.strideWidth,a=e.dilationHeight,r=e.effectiveFilterHeight,o=e.effectiveFilterWidth,i=r-1-e.padInfo.top,c=o-1-e.padInfo.left,s=r*o-1;this.userCode="\n      const ivec2 pads = ivec2(".concat(i,", ").concat(c,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(r,";\n          wR += ").concat(a,") {\n          float dyR = float(dyRCorner + wR) / ").concat(n,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ").concat(o,"; wC++) {\n            float dyC = float(dyCCorner + wC) / ").concat(t,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ").concat(s," - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ").concat(o," + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")},MaxPool3DBackpropProgram=function(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;var n=e.strideDepth,t=e.strideHeight,a=e.strideWidth,r=e.dilationDepth,o=e.dilationHeight,i=e.dilationWidth,c=e.effectiveFilterDepth,s=e.effectiveFilterHeight,u=e.effectiveFilterWidth,l=c-1-e.padInfo.front,d=s-1-e.padInfo.top,p=u-1-e.padInfo.left,h=c*s*u-1;this.userCode="\n      const ivec3 pads = ivec3(".concat(l,", ").concat(d,", ").concat(p,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ").concat(c,";\n           wD += ").concat(r,") {\n          float dyD = float(dyDCorner + wD) / ").concat(n,".0;\n\n          if (dyD < 0.0 || dyD >= ").concat(e.outDepth,".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ").concat(s,";\n              wR += ").concat(o,") {\n            float dyR = float(dyRCorner + wR) / ").concat(t,".0;\n\n            if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ").concat(u,";\n                wC += ").concat(i,") {\n              float dyC = float(dyCCorner + wC) / ").concat(a,".0;\n\n              if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ").concat(h," -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ").concat(s," * ").concat(u," +\n                  wR * ").concat(u," + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")},tk={kernelName:p.MaxPool3DGrad,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.dy,o=n.input,i=a.filterSize,c=a.strides,s=a.pad,u=a.dimRoundingMode,l=p.backend_util.computePool3DInfo(o.shape,i,c,[1,1,1],s,u),d=new Pool3DProgram(l,"max",!0),h=t.runWebGLProgram(d,[o],o.dtype),f=new MaxPool3DBackpropProgram(l),x=t.runWebGLProgram(f,[r,h],o.dtype);return t.disposeIntermediateTensorInfo(h),x}},tI={kernelName:p.MaxPoolGrad,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.dy,o=n.input;assertNotComplex([o,n.output],"maxPoolGrad");var i=a.filterSize,c=a.strides,s=a.pad,u=a.dimRoundingMode,l=p.backend_util.computePool2DInfo(o.shape,i,c,1,s,u),d=new Pool2DProgram(l,"max",!0),h=t.runWebGLProgram(d,[o],o.dtype),f=new MaxPool2DBackpropProgram(l),x=t.runWebGLProgram(f,[r,h],o.dtype);return t.disposeIntermediateTensorInfo(h),x}},tT={kernelName:p.MaxPoolWithArgmax,backendName:"webgl",kernelFunc:function(e){var n,t,a=e.inputs,r=e.attrs,o=e.backend,i=a.x,c=r.filterSize,s=r.strides,u=r.pad,l=r.includeBatchInIndex;p.util.assert(4===i.shape.length,function(){return"Error in maxPool: input must be rank 4 but got rank ".concat(i.shape.length,".")});var d=[1,1];p.util.assert(p.backend_util.eitherStridesOrDilationsAreOne(s,d),function(){return"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(s," and dilations '").concat(d,"'")});var h=p.backend_util.computePool2DInfo(i.shape,c,s,d,u),f=__read((n=new Pool2DProgram(h,"max",!1),t=o.runWebGLProgram(n,[i],"float32"),n=new Pool2DProgram(h,"max",!0,!0,l),[t,o.runWebGLProgram(n,[i],"float32")]),2);return[f[0],f[1]]}},tS={kernelName:p.Mean,backendName:"webgl",kernelFunc:function(e){var n,t,a,r,o,i,c,s,u,l=e.inputs,d=e.attrs,h=e.backend,f=l.x,x=d.keepDims,m=d.axis,g=f.shape.length,v=p.util.parseAxisParam(m,f.shape),b=v,C=p.backend_util.getAxesPermutation(b,g),y=null!=C,k=h.shouldExecuteOnCPU([f]),I=[],T=f;if(y){if(k){for(var S=h.texData.get(T.dataId).values,R=Array(g),w=0;w<R.length;w++)R[w]=f.shape[C[w]];var P=transposeImplCPU(S,f.shape,f.dtype,C,R);T=h.makeTensorInfo(R,f.dtype),h.texData.get(T.dataId).values=P}else T=transposeImpl(f,C,h);I.push(T),b=p.backend_util.getInnerMostAxes(b.length,g)}p.backend_util.assertAxesAreInnerMostDims("sum",b,g);var _=__read(p.backend_util.computeOutAndReduceShapes(T.shape,b),2),E=_[0],F=_[1],N=E;x&&(N=p.backend_util.expandShapeToKeepDim(E,v));var A=(n=T,t=N,a=p.util.sizeFromShape(F),r=p.util.sizeFromShape(n.shape)/a,i=reduce(o=reshape({inputs:{x:n},attrs:{shape:[r,a]},backend:h}),"float32","mean",h),c=reshape({inputs:{x:i},attrs:{shape:t},backend:h}),h.disposeIntermediateTensorInfo(o),h.disposeIntermediateTensorInfo(i),c);try{for(var O=__values(I),D=O.next();!D.done;D=O.next()){var w=D.value;h.disposeIntermediateTensorInfo(w)}}catch(e){s={error:e}}finally{try{D&&!D.done&&(u=O.return)&&u.call(O)}finally{if(s)throw s.error}}return A}},tR={kernelName:p.Min,backendName:"webgl",kernelFunc:function(e){var n,t=e.inputs,a=e.backend,r=e.attrs,o=t.x,i=r.axis,c=r.keepDims,s=o.shape.length,u=p.util.parseAxisParam(i,o.shape),l=u,d=p.backend_util.getAxesPermutation(l,s),h=o;null!=d&&(h=transpose({inputs:{x:o},backend:a,attrs:{perm:d}}),l=p.backend_util.getInnerMostAxes(l.length,o.shape.length)),p.backend_util.assertAxesAreInnerMostDims("min",l,s);var f=__read(p.backend_util.computeOutAndReduceShapes(h.shape,l),2),x=f[0],m=f[1],g=reshape({inputs:{x:h},backend:a,attrs:{shape:[-1,p.util.sizeFromShape(m)]}}),v=reduce(g,g.dtype,"min",a);return n=c?reshape({inputs:{x:v},backend:a,attrs:{shape:p.backend_util.expandShapeToKeepDim(x,u)}}):reshape({inputs:{x:v},backend:a,attrs:{shape:x}}),a.disposeIntermediateTensorInfo(g),a.disposeIntermediateTensorInfo(v),null!=d&&a.disposeIntermediateTensorInfo(h),n}},tw=binaryKernelFunc({opSnippet:ea+"\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+er+"\n  return result;\n",cpuKernelImpl:D}),tP={kernelName:p.Minimum,backendName:"webgl",kernelFunc:tw},MirrorPadProgram=function(e,n,t){this.variableNames=["x"],this.outputShape=n.map(function(n,t){return n[0]+e[t]+n[1]});var a=e.length,r=getCoordsDataType(a),o=n.map(function(e){return e[0]}).join(","),i=n.map(function(n,t){return n[0]+e[t]}).join(","),c=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,a),s="reflect"===t?0:1;if(1===a){this.userCode="\n        int start = ".concat(o,";\n        int end = ").concat(i,";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ").concat(s,";\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ").concat(s,";\n          }\n          setOutput(getX(outC - start));\n        }\n      ");return}this.userCode="\n      ".concat(r," start = ").concat(r,"(").concat(o,");\n      ").concat(r," end = ").concat(r,"(").concat(i,");\n\n      void main() {\n        ").concat(r," outC = getOutputCoords();\n        for (int i = 0; i < ").concat(a,"; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ").concat(s,";\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ").concat(s,";\n          }\n        }\n        ").concat(r," coords = outC - start;\n        setOutput(getX(").concat(c,"));\n      }\n    ")},MirrorPadPackedProgram=function(e,n,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n.map(function(n,t){return n[0]+e[t]+n[1]});var a=e.length,r=getCoordsDataType(a),o=n.map(function(e){return e[0]}).join(","),i=n.map(function(n,t){return n[0]+e[t]}).join(","),c=getChannels("rc",a),s=getChannels("source",a),u="".concat(c[a-1]," < ").concat(this.outputShape[a-1]),l=1===a?"source":"vec2(".concat(s.slice(-2).join(),")"),d="reflect"===t?0:1,p="";if(1===a){var h="\n        ".concat(r," source = rc;\n        if (source < start) {\n          source = start * 2 - source - ").concat(d,";\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ").concat(d,";\n        }\n        source -= start;\n      ");p="\n        ".concat(r," rc = outputLoc;\n        ").concat(h,"\n        result[0] = getChannel(getX(").concat(s.join(),"), ").concat(l,");\n        ").concat(c[a-1]," += 1;\n        if(").concat(u,") {\n          ").concat(h,"\n          result[1] = getChannel(getX(").concat(s.join(),"), ").concat(l,");\n        }\n      ")}else{var h="\n        ".concat(r," source = rc;\n        ").concat(r," lt = ").concat(r,"(lessThan(source, start));\n        ").concat(r," gte = ").concat(r,"(greaterThanEqual(source, end));\n        ").concat(r," orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ").concat(d,") +\n                gte * ((end - 1) * 2 - source + ").concat(d,");\n        source -= start;\n      ");p="\n        ".concat(r," rc = outputLoc;\n        ").concat(h,"\n        result[0] = getChannel(getX(").concat(s.join(),"), ").concat(l,");\n        ").concat(c[a-1]," += 1;\n        if(").concat(u,") {\n          ").concat(h,"\n          result[1] = getChannel(getX(").concat(s.join(),"), ").concat(l,");\n        }\n        rc = outputLoc;\n        ").concat(c[a-2]," += 1;\n        if(").concat(c[a-2]," < ").concat(this.outputShape[a-2],") {\n          ").concat(h,"\n          result[2] = getChannel(getX(").concat(s.join(),"), ").concat(l,");\n          ").concat(c[a-1]," += 1;\n          if(").concat(u,") {\n            ").concat(h,"\n            result[3] = getChannel(getX(").concat(s.join(),"), ").concat(l,");\n          }\n        }\n      ")}this.userCode="\n      const ".concat(r," start = ").concat(r,"(").concat(o,");\n      const ").concat(r," end = ").concat(r,"(").concat(i,");\n\n      void main() {\n        ").concat(r," outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ").concat(p,"\n        setOutput(result);\n      }\n    ")},t_={kernelName:p.MirrorPad,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.x,o=a.paddings,i=a.mode,c=p.env().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new MirrorPadPackedProgram(r.shape,o,i):new MirrorPadProgram(r.shape,o,i);return t.runWebGLProgram(c,[r],r.dtype)}},tE=binaryKernelFunc({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  "+er+"\n  return result;\n"}),tF={kernelName:p.Mod,backendName:"webgl",kernelFunc:tE},MultinomialProgram=function(e,n,t){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,t],this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ".concat(n-1,"; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(").concat(n-1,"));\n      }\n    ")},tN=binaryKernelFunc({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),tA={kernelName:p.RealDiv,backendName:"webgl",kernelFunc:tN},tO="return a - b;",tD=binaryKernelFunc({opSnippet:tO,packedOpSnippet:tO,supportsComplex:!0,cpuKernelImpl:H}),tL={kernelName:p.Sub,backendName:"webgl",kernelFunc:tD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function softmax(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.logits,o=a.dim,i=p.util.parseAxisParam([o],r.shape),c=max({inputs:{x:r},backend:t,attrs:{reductionIndices:i,keepDims:!1}}),s=p.backend_util.expandShapeToKeepDim(c.shape,i),u=reshape({inputs:{x:c},backend:t,attrs:{shape:s}}),l=tD({inputs:{a:r,b:u},backend:t}),d=nA({inputs:{x:l},backend:t}),h=sum({inputs:{x:d},backend:t,attrs:{axis:i,keepDims:!1}}),f=reshape({inputs:{x:h},backend:t,attrs:{shape:s}}),x=tN({inputs:{a:d,b:f},backend:t});return t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(f),x}var tB={kernelName:p.Softmax,backendName:"webgl",kernelFunc:softmax},tU={kernelName:p.Multinomial,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.logits,o=a.numSamples,i=a.seed,c=a.normalized,s=c?r:softmax({inputs:{logits:r},backend:t,attrs:{dim:r.shape.length-1}}),u=s.shape[0],l=s.shape[1],d=new MultinomialProgram(u,l,o),p=t.runWebGLProgram(d,[s],"int32",[[i]]);return c||t.disposeIntermediateTensorInfo(s),p}},tG=q+"\n  return -x;\n",tM={kernelName:p.Neg,backendName:"webgl",kernelFunc:function(e){var n,t=e.inputs,a=e.backend,r=t.x;if(a.shouldExecuteOnCPU([r])){var o,i,c,s=__read((o=a.texData.get(r.dataId).values,i=r.shape,c=r.dtype,L([],i,p.util.createScalarValue(-1,c),o,c)),2),u=s[0],l=s[1];return a.makeTensorInfo(l,r.dtype,u)}return n=p.env().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new UnaryOpPackedProgram(r.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new UnaryOpProgram(r.shape,tG),a.runWebGLProgram(n,[r],r.dtype)}},tW=p.kernel_impls.nonMaxSuppressionV3Impl,tV={kernelName:p.NonMaxSuppressionV3,backendName:"webgl",kernelFunc:function(e){p.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");var n=e.inputs,t=e.backend,a=e.attrs,r=n.boxes,o=n.scores,i=a.maxOutputSize,c=a.iouThreshold,s=a.scoreThreshold,u=tW(t.readSync(r.dataId),t.readSync(o.dataId),i,c,s).selectedIndices;return t.makeTensorInfo([u.length],"int32",new Int32Array(u))}},tz=p.kernel_impls.nonMaxSuppressionV4Impl,tX={kernelName:p.NonMaxSuppressionV4,backendName:"webgl",kernelFunc:function(e){p.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");var n=e.inputs,t=e.backend,a=e.attrs,r=n.boxes,o=n.scores,i=a.maxOutputSize,c=a.iouThreshold,s=a.scoreThreshold,u=a.padToMaxOutputSize,l=tz(t.readSync(r.dataId),t.readSync(o.dataId),i,c,s,u),d=l.selectedIndices,h=l.validOutputs;return[t.makeTensorInfo([d.length],"int32",new Int32Array(d)),t.makeTensorInfo([],"int32",new Int32Array([h]))]}},tH=p.kernel_impls.nonMaxSuppressionV5Impl,tK={kernelName:p.NonMaxSuppressionV5,backendName:"webgl",kernelFunc:function(e){p.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");var n=e.inputs,t=e.backend,a=e.attrs,r=n.boxes,o=n.scores,i=a.maxOutputSize,c=a.iouThreshold,s=a.scoreThreshold,u=a.softNmsSigma,l=tH(t.readSync(r.dataId),t.readSync(o.dataId),i,c,s,u),d=l.selectedIndices,h=l.selectedScores;return[t.makeTensorInfo([d.length],"int32",new Int32Array(d)),t.makeTensorInfo([h.length],"float32",new Float32Array(h))]}},OneHotProgram=function(e,n,t,a){this.variableNames=["indices"],this.outputShape=[e,n],this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(".concat(a,"), float(").concat(t,"),\n                      float(index == coords.y)));\n      }\n    ")},tj={kernelName:p.OneHot,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.indices,o=a.dtype,i=a.depth,c=a.onValue,s=a.offValue,u=p.util.sizeFromShape(r.shape),l=new OneHotProgram(u,i,c,s),d=reshape({inputs:{x:r},backend:t,attrs:{shape:[u]}}),h=t.runWebGLProgram(l,[d],o);t.disposeIntermediateTensorInfo(d);var f=reshape({inputs:{x:h},backend:t,attrs:{shape:__spreadArray(__spreadArray([],__read(r.shape),!1),[i],!1)}});return t.disposeIntermediateTensorInfo(h),f}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zerosLike(e){var n=e.inputs,t=e.backend,a=n.x;if("complex64"!==a.dtype)return fill({attrs:{shape:a.shape,dtype:a.dtype,value:"string"===a.dtype?"":0},backend:t});var r=real({inputs:{input:a},backend:t}),o=zerosLike({inputs:{x:r},backend:t}),i=imag({inputs:{input:a},backend:t}),c=zerosLike({inputs:{x:i},backend:t}),s=complex({inputs:{real:o,imag:c},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(c),s}var tq={kernelName:p.ZerosLike,backendName:"webgl",kernelFunc:zerosLike},tY={kernelName:p.OnesLike,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function onesLike(e){var n=e.inputs,t=e.backend,a=n.x;if("string"===a.dtype)throw Error("onesLike is not supported under string dtype");if("complex64"!==a.dtype)return fill({attrs:{shape:a.shape,dtype:a.dtype,value:1},backend:t});var r=real({inputs:{input:a},backend:t}),o=onesLike({inputs:{x:r},backend:t}),i=imag({inputs:{input:a},backend:t}),c=zerosLike({inputs:{x:i},backend:t}),s=complex({inputs:{real:o,imag:c},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(c),s}},tQ={kernelName:p.Pack,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var n=e.inputs,t=e.backend,a=e.attrs.axis;if(1===n.length)return expandDims({inputs:{input:n[0]},backend:t,attrs:{dim:a}});var r=n[0].shape,o=n[0].dtype;n.forEach(function(e){p.util.assertShapesMatch(r,e.shape,"All tensors passed to stack must have matching shapes"),p.util.assert(o===e.dtype,function(){return"All tensors passed to stack must have matching dtypes"})});var i=[],c=concat({inputs:n.map(function(e){var n=expandDims({inputs:{input:e},backend:t,attrs:{dim:a}});return i.push(n),n}),backend:t,attrs:{axis:a}});return i.forEach(function(e){return t.disposeIntermediateTensorInfo(e)}),c}},PadProgram=function(e,n,t){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=n.map(function(n,t){return n[0]+e[t]+n[1]});var a=e.length,r=getCoordsDataType(a),o=n.map(function(e){return e[0]}).join(","),i=n.map(function(n,t){return n[0]+e[t]}).join(","),c=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,a);if(1===a){this.userCode="\n        int start = ".concat(o,";\n        int end = ").concat(i,";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      ");return}this.userCode="\n      ".concat(r," start = ").concat(r,"(").concat(o,");\n      ").concat(r," end = ").concat(r,"(").concat(i,");\n\n      void main() {\n        ").concat(r," outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ").concat(r," coords = outC - start;\n          setOutput(getX(").concat(c,"));\n        }\n      }\n    ")},PadPackedProgram=function(e,n,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=n.map(function(n,t){return n[0]+e[t]+n[1]});for(var a=e.length,r=getCoordsDataType(a),o=n.map(function(e){return e[0]}).join(","),i=n.map(function(n,t){return n[0]+e[t]}).join(","),c=getChannels("rc",a),s=getChannels("source",a),u="".concat(c[a-1]," < ").concat(this.outputShape[a-1]),l=1===a?"source":"vec2(".concat(s.slice(-2).join(),")"),d=["".concat(r," rc = outputLoc;"),"".concat(c[a-1]," += 1;\n       if(").concat(u,") {\n      "),1===a?"":"}\n       rc = outputLoc;\n       ".concat(c[a-2]," += 1;\n       if(").concat(c[a-2]," < ").concat(this.outputShape[a-2],") {"),1===a?"":"  ".concat(c[a-1]," += 1;\n         if(").concat(u,") {")],p=1===a?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",h="",f=0,x=1===a?2:4;f<x;f++)h+="\n        ".concat(d[f],"\n        if (").concat(p,") {\n          result[").concat(f,"] = float(value);\n        } else {\n          ").concat(r," source = rc - start;\n          result[").concat(f,"] = getChannel(getX(").concat(s.join(),"), ").concat(l,");\n        }\n      ");h+=1===a?"} ":"}}",this.userCode="\n      const ".concat(r," start = ").concat(r,"(").concat(o,");\n      const ").concat(r," end = ").concat(r,"(").concat(i,");\n\n      void main() {\n        ").concat(r," outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ").concat(h,"\n        setOutput(result);\n      }\n    ")},padV2=function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.x,o=a.paddings,i=a.constantValue;if(0===p.util.sizeFromShape(r.shape))return fill({backend:t,attrs:{shape:o.map(function(e,n){return e[0]+r.shape[n]+e[1]}),value:i,dtype:r.dtype}});var c=p.env().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new PadPackedProgram(r.shape,o,i):new PadProgram(r.shape,o,i),s=[[i]];return t.runWebGLProgram(c,[r],r.dtype,s)},tZ={kernelName:p.PadV2,backendName:"webgl",kernelFunc:padV2},tJ=binaryKernelFunc({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  "+er+"\n  return result;\n"}),t$={kernelName:p.Pow,backendName:"webgl",kernelFunc:tJ},t0={kernelName:p.Prod,backendName:"webgl",kernelFunc:function(e){var n,t=e.inputs,a=e.backend,r=e.attrs,o=t.x,i=r.axis,c=r.keepDims,s=o.shape.length,u=[],l=p.util.parseAxisParam(i,o.shape),d=l,h=p.backend_util.getAxesPermutation(d,s),f=o;if(null!=h&&(f=transpose({inputs:{x:o},backend:a,attrs:{perm:h}}),d=p.backend_util.getInnerMostAxes(d.length,s),u.push(f)),p.backend_util.assertAxesAreInnerMostDims("prod",d,s),a.shouldExecuteOnCPU([f])){var x=a.texData.get(f.dataId).values,m=prodImplCPU(f.shape,f.dtype,x,d),g=m.outVals,v=m.outShape,b=m.outDtype;n=a.makeTensorInfo(v,b,g)}else{var C=__read(p.backend_util.computeOutAndReduceShapes(f.shape,d),2),v=C[0],y=C[1],k=reshape({inputs:{x:f},backend:a,attrs:{shape:[-1,p.util.sizeFromShape(y)]}}),I=reduce(k,p.sumOutType(o.dtype),"prod",a);n=reshape({inputs:{x:I},backend:a,attrs:{shape:v}}),u.push(k),u.push(I)}if(c){u.push(n);var T=p.backend_util.expandShapeToKeepDim(n.shape,l);n=reshape({inputs:{x:n},backend:a,attrs:{shape:T}})}return u.forEach(function(e){return a.disposeIntermediateTensorInfo(e)}),n}},t1={kernelName:p.RaggedGather,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.paramsNestedSplits,o=n.paramsDenseValues,i=n.indices;a.outputRaggedRank;var c=r.map(function(e){return t.readSync(e.dataId)}),s=r.map(function(e){return e.shape}),u=t.readSync(o.dataId),l=t.readSync(i.dataId),d=__read(raggedGatherImplCPU(c,s,u,o.shape,o.dtype,l,i.shape),3),p=d[0],h=d[1],f=d[2],x=p.map(function(e){return t.makeTensorInfo([e.length],"int32",e)}),m=t.makeTensorInfo(f,o.dtype,h);return x.concat([m])}},t2={kernelName:p.RaggedRange,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=n.starts,r=n.limits,o=n.deltas,i=t.readSync(a.dataId),c=t.readSync(r.dataId),s=t.readSync(o.dataId),u=__read(raggedRangeImplCPU(i,a.shape,a.dtype,c,r.shape,s,o.shape),2),l=u[0],d=u[1];return[t.makeTensorInfo([l.length],"int32",l),t.makeTensorInfo([d.length],a.dtype,d)]}},t4={kernelName:p.RaggedTensorToTensor,backendName:"webgl",kernelFunc:function(e){var n,t,a,r,o=e.inputs,i=e.backend,c=e.attrs,s=o.shape,u=o.values,l=o.defaultValue,d=o.rowPartitionTensors,p=c.rowPartitionTypes,h=i.readSync(s.dataId),f=i.readSync(u.dataId),x=i.readSync(l.dataId),m=d.map(function(e){return i.readSync(e.dataId)}),g=d.map(function(e){return e.shape}),v=__read((n=s.shape,t=u.shape,a=u.dtype,r=l.shape,new G(h,n,f,t,a,x,r,m,g,p).compute()),2),b=v[0],C=v[1];return i.makeTensorInfo(b,u.dtype,C)}},range=function(e){var n=e.backend,t=e.attrs,a=t.start,r=t.stop,o=t.step,i=t.dtype,c=rangeImplCPU(a,r,o,i);return n.makeTensorInfo([c.length],i,c)},t3={kernelName:p.Range,backendName:"webgl",kernelFunc:range},t5=unaryKernelFunc({opSnippet:"return 1.0 / x;"}),t6={kernelName:p.Reciprocal,backendName:"webgl",kernelFunc:t5},t8=unaryKernelFunc({opSnippet:q+"\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),t7={kernelName:p.Relu,backendName:"webgl",kernelFunc:t8},t9=unaryKernelFunc({opSnippet:q+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),ae={kernelName:p.Relu6,backendName:"webgl",kernelFunc:t9},ResizeBilinearProgram=function(e,n,t,a,r){this.variableNames=["A"],this.outputShape=[];var o=__read(e,4),i=o[0],c=o[1],s=o[2],u=o[3];this.outputShape=[i,n,t,u];var l=[a&&n>1?c-1:c,a&&t>1?s-1:s],d=[a&&n>1?n-1:n,a&&t>1?t-1:t];this.userCode="\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ".concat(l[0]/d[0],",\n          ").concat(l[1]/d[1],");\n      const vec2 inputShapeRC = vec2(").concat(c,".0, ").concat(s,".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ").concat(r?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",";\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    ")},ResizeBilinearPackedProgram=function(e,n,t,a,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];var o=__read(e,4),i=o[0],c=o[1],s=o[2],u=o[3];this.outputShape=[i,n,t,u];var l=[a&&n>1?c-1:c,a&&t>1?s-1:s],d=[a&&n>1?n-1:n,a&&t>1?t-1:t];this.userCode="\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ".concat(l[0]/d[0],",\n          ").concat(l[1]/d[1],",\n          ").concat(l[1]/d[1],");\n      const vec3 inputShapeRC = vec3(").concat(c,".0, ").concat(s,".0,\n                                     ").concat(s,".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ").concat(r?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",";\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ").concat(u-1,";\n        bool hasNextRow = coords.z < ").concat(t-1,";\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    ")},an={kernelName:p.ResizeBilinear,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.images,o=a.alignCorners,i=a.halfPixelCenters,c=__read(a.size,2),s=c[0],u=c[1],l=p.env().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new ResizeBilinearPackedProgram(r.shape,s,u,o,i):new ResizeBilinearProgram(r.shape,s,u,o,i);return t.runWebGLProgram(l,[r],"float32")}},ResizeBilinearBackpropProgram=function(e,n,t){this.variableNames=["dy"],this.outputShape=[],this.outputShape=n;var a=__read(n,3),r=a[1],o=a[2],i=__read(e,3),c=i[1],s=i[2],u=[t&&c>1?r-1:r,t&&s>1?o-1:o],l=[t&&c>1?c-1:c,t&&s>1?s-1:s],d=u[0]/l[0],p=u[1]/l[1],h=1/d,f=1/p,x=2*Math.ceil(h)+2,m=2*Math.ceil(f)+2;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(".concat(d,");\n        const float widthScale = float(").concat(p,");\n\n        const float invHeightScale = float(").concat(h,");\n        const float invWidthScale = float(").concat(f,");\n\n        const int winHeight = int(").concat(x,");\n        const int winWidth = int(").concat(m,");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ").concat(c,") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ").concat(s,") {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ").concat(r-1,".0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ").concat(o-1,".0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ")},at={kernelName:p.ResizeBilinearGrad,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.images,o=n.dy,i=a.alignCorners,c=new ResizeBilinearBackpropProgram(o.shape,r.shape,i);return t.runWebGLProgram(c,[o],o.dtype)}},ResizeNearestNeighborProgram=function(e,n,t,a,r){this.variableNames=["A"],this.outputShape=[];var o=__read(e,4),i=o[0],c=o[1],s=o[2],u=o[3];this.outputShape=[i,n,t,u];var l=[a&&n>1?c-1:c,a&&t>1?s-1:s],d=[a&&n>1?n-1:n,a&&t>1?t-1:t];this.userCode="\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ".concat(l[0]/d[0],",\n          ").concat(l[1]/d[1],");\n      const vec2 inputShapeRC = vec2(").concat(c,".0, ").concat(s,".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ").concat(r?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",";\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ").concat(a?"0.5":"0.0",")));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    ")},ResizeNearestNeighborPackedProgram=function(e,n,t,a,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];var o=__read(e,4),i=o[0],c=o[1],s=o[2],u=o[3];this.outputShape=[i,n,t,u];var l=[a&&n>1?c-1:c,a&&t>1?s-1:s],d=[a&&n>1?n-1:n,a&&t>1?t-1:t];this.userCode="\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ".concat(l[0]/d[0],",\n          ").concat(l[1]/d[1],",\n          ").concat(l[1]/d[1],");\n      const vec3 inputShapeRC = vec3(").concat(c,".0, ").concat(s,".0,\n                                     ").concat(s,".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ").concat(r?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",";\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ").concat(a?"0.5":"0.0",")));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ").concat(u-1,";\n        bool hasNextRow = coords.z < ").concat(t-1,";\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    ")},aa={kernelName:p.ResizeNearestNeighbor,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.images,o=a.alignCorners,i=a.halfPixelCenters,c=__read(a.size,2),s=c[0],u=c[1],l=p.env().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new ResizeNearestNeighborPackedProgram(r.shape,s,u,o,i):new ResizeNearestNeighborProgram(r.shape,s,u,o,i);return t.runWebGLProgram(l,[r],r.dtype)}},ResizeNearestNeigborBackpropProgram=function(e,n,t){this.variableNames=["dy"],this.outputShape=[],this.outputShape=n;var a=__read(n,3),r=a[1],o=a[2],i=__read(e,3),c=i[1],s=i[2],u=[t&&c>1?r-1:r,t&&s>1?o-1:o],l=[t&&c>1?c-1:c,t&&s>1?s-1:s],d=u[0]/l[0],p=u[1]/l[1],h=1/d,f=1/p,x=2*Math.ceil(h)+2,m=2*Math.ceil(f)+2;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(".concat(d,");\n        const float widthScale = float(").concat(p,");\n\n        const float invHeightScale = float(").concat(h,");\n        const float invWidthScale = float(").concat(f,");\n\n        const int winHeight = int(").concat(x,");\n        const int winWidth = int(").concat(m,");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ").concat(c,") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ").concat(s,") {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(").concat(u[0],") *\n                (float(dyR) / float(").concat(l[0],"));\n\n            float sourceFracCol =\n                float(").concat(u[1],") *\n                  (float(dyC) / float(").concat(l[1],"));\n\n            int sourceNearestRow = int(min(\n                float(int(").concat(r,") - 1),\n                ").concat(t," ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(").concat(o,") - 1),\n                ").concat(t," ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ")},ar={kernelName:p.ResizeNearestNeighborGrad,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.images,o=n.dy,i=a.alignCorners,c=new ResizeNearestNeigborBackpropProgram(o.shape,r.shape,i);return t.runWebGLProgram(c,[o],o.dtype)}},ReverseProgram=function(e,n){this.variableNames=["x"];var t=e.length;if(t>4)throw Error("WebGL backend: Reverse of rank-".concat(t," tensor is not yet supported"));if(this.outputShape=e,1===t){this.userCode="\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(".concat(e[0]," - coord - 1));\n        }\n      ");return}var a=e.map(function(t,a){return -1!==n.indexOf(a)&&1!==e[a]?"".concat(e[a]," - coords[").concat(a,"] - 1"):"coords[".concat(a,"]")}).join(","),r=getCoordsDataType(t);this.userCode="\n      void main() {\n        ".concat(r," coords = getOutputCoords();\n        setOutput(getX(").concat(a,"));\n      }\n    ")},ReversePackedProgram=function(e,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;var t,a,r,o=e.length;if(o>4)throw Error("WebGL backend: Reverse of rank-".concat(o," tensor is not yet supported"));this.outputShape=e;var i=getChannels("rc",o),c="".concat(i[o-1]," + 1 < ").concat(this.outputShape[o-1]),s="".concat(i[o-2]," + 1 < ").concat(this.outputShape[o-2]),u=getCoordsDataType(o);function getChannel(t){var a=e.map(function(a,r){return -1!==n.indexOf(r)&&1!==e[r]?"".concat(e[r]," - ").concat(t[r]," - 1"):"".concat(t[r])}),r=a.join(","),o=a.slice(-2).join(",");return"getChannel(getX(".concat(r,"), vec2(").concat(o,"))")}1===o?this.userCode="\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(".concat(e[0]," - rc - 1),\n            ").concat(e[0]," - rc - 1);\n          if(").concat(c,"){\n              result.g = getChannel(getX(").concat(e[0]," - (rc  + 1) - 1),\n                ").concat(e[0]," - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      "):this.userCode="\n        void main() {\n          ".concat(u," rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ").concat(getChannel(i.slice()),";\n          if(").concat(c,"){\n            result.g = ").concat(((t=i.slice())[o-1]="("+t[o-1]+" + 1)",getChannel(t)),";\n          }\n          if(").concat(s,") {\n            result.b = ").concat(((a=i.slice())[o-2]="("+a[o-2]+" + 1)",getChannel(a)),";\n            if(").concat(c,") {\n              result.a = ").concat(((r=i.slice())[o-1]="("+r[o-1]+" + 1)",r[o-2]="("+r[o-2]+" + 1)",getChannel(r)),";\n            }\n          }\n          setOutput(result);\n        }\n    ")},ao={kernelName:p.Reverse,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.x,o=a.dims,i=r.shape.length,c=p.util.parseAxisParam(o,r.shape);if(0===i)return identity({inputs:{x:r},backend:t});var s=p.env().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new ReversePackedProgram(r.shape,c):new ReverseProgram(r.shape,c);return t.runWebGLProgram(s,[r],r.dtype)}},RotateProgram=function(e,n){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];var t=e[1],a=e[2];this.outputShape=e;var r="";r="number"==typeof n?"float outputValue = ".concat(n.toFixed(2),";"):"\n        vec3 fill = vec3(".concat(n.join(","),");\n        float outputValue = fill[coords[3]];"),this.userCode="\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ".concat(r,"\n          if(coordX >= 0 && coordX < ").concat(a," && coordY >= 0 && coordY < ").concat(t,") {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    ")},ai={kernelName:p.RotateWithOffset,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.attrs,a=e.backend,r=n.image,o=t.radians,i=t.fillValue,c=t.center,s=new RotateProgram(r.shape,i),u=__read(p.backend_util.getImageCenter(c,r.shape[1],r.shape[2]),2),l=[[u[0],u[1],Math.sin(o),Math.cos(o)]];return a.runWebGLProgram(s,[r],r.dtype,l)}},ac=unaryKernelFunc({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),as={kernelName:p.Round,backendName:"webgl",kernelFunc:ac},au=unaryKernelFunc({opSnippet:"return inversesqrt(x);",cpuKernelImpl:M}),al={kernelName:p.Rsqrt,backendName:"webgl",kernelFunc:au},ScatterProgram=function(e,n,t,a,r,o,i,c){void 0===c&&(c=!1),this.variableNames=["updates","indices","defaultValue"],this.outputShape=o;var s=getCoordsDataType(r.length),u=getCoordsDataType(o.length),l="";1===t?l="i":2===t&&(l="i, j");var d="getIndices(".concat(l,")"),p="";1===a?p="i":2===a&&(p="i, coords[1]");var h="getUpdates(".concat(p,")"),f="";c&&(f="coords[0], coords[1]");var x="getDefaultValue(".concat(f,")"),m=n>1?"strides[j]":"strides";this.userCode="\n        ".concat(s," strides = ").concat(s,"(").concat(r,");\n\n        void main() {\n          ").concat(u," coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ").concat(e,"; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ").concat(n,"; j++) {\n              int index = round(").concat(d,");\n              flattenedIndex += index * ").concat(m,";\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ").concat(h,";\n              found = true;\n            }\n          }\n          setOutput(mix(").concat(x,", sum, float(found)));\n        }\n      ")},ScatterPackedProgram=function(e,n,t,a,r,o,i,c){void 0===c&&(c=!1),this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=o;var s=getCoordsDataType(r.length),u=getCoordsDataType(o.length),l="";1===t?l="i":2===t&&(l="i, j");var d="getIndices(".concat(l,")"),p="";1===a?p="i":2===a&&(p="i, coords[1]");var h="getUpdates(".concat(p,")"),f="";c&&(f="coords[0], coords[1]");var x="getDefaultValue(".concat(f,")"),m=n>1?"strides[j]":"strides",g=n>1?"strides[j + 1]":"strides";this.userCode="\n        ".concat(s," strides = ").concat(s,"(").concat(r,");\n\n        void main() {\n          ").concat(u," coords = getOutputCoords();\n          vec4 sum = vec4(0.);\n          vec4 found = vec4(0.);\n          for (int i = 0; i < ").concat(e,"; i+=2) {\n            ivec2 flattenedIndex = ivec2(0);\n            for (int j = 0; j < ").concat(n,"; j+=2) {\n              ivec4 index = round(").concat(d,");\n              flattenedIndex += index.xz * ").concat(m,";\n              if (j + 1 < ").concat(n,") {\n                flattenedIndex += index.yw * ").concat(g,";\n              }\n            }\n            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||\n                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {\n              vec4 updVals = ").concat(h,";\n              if (flattenedIndex[0] == coords[0]) {\n                sum.xy += updVals.xy;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[0] == coords[0] + 1) {\n                sum.zw += updVals.xy;\n                found.zw = vec2(1.);\n              }\n              if (flattenedIndex[1] == coords[0]) {\n                sum.xy += updVals.zw;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[1] == coords[0] + 1) {\n                sum.zw += updVals.zw;\n                found.zw = vec2(1.);\n              }\n            }\n          }\n          setOutput(mix(").concat(x,", sum, found));\n        }\n      ")},ad={kernelName:p.ScatterNd,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var n,t=e.inputs,a=e.backend,r=e.attrs,o=t.indices,i=t.updates,c=r.shape,s=p.backend_util.calculateShapes(i,o,c),u=s.sliceRank,l=s.numUpdates,d=s.sliceSize,h=s.strides,f=s.outputSize,x=[f/d,d];if(0===f)return a.makeTensorInfo(c,o.dtype);var m=reshape({inputs:{x:o},backend:a,attrs:{shape:[l,u]}}),g=reshape({inputs:{x:i},backend:a,attrs:{shape:[l,d]}}),v=a.makeTensorInfo([],"float32",new Float32Array([0]));n=p.env().getBool("WEBGL_PACK")?new ScatterPackedProgram(l,u,m.shape.length,g.shape.length,h,x):new ScatterProgram(l,u,m.shape.length,g.shape.length,h,x);var b=a.runWebGLProgram(n,[g,m,v],g.dtype),C=reshape({inputs:{x:b},backend:a,attrs:{shape:c}});return a.disposeIntermediateTensorInfo(m),a.disposeIntermediateTensorInfo(g),a.disposeIntermediateTensorInfo(b),a.disposeIntermediateTensorInfo(v),C}},SearchSortedProgram=function(e,n,t,a){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,t];var r="for (int i = 0; i < ".concat(Math.ceil(Math.log2(n+1)),"; ++i) { if (left >= right) break;"),o=2===p.env().getNumber("WEBGL_VERSION")?"while (left < right) {":r;this.userCode="\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ".concat(o,"\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ").concat("left"===a?"<":"<="," value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     ")},ap={kernelName:p.SearchSorted,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.sortedSequence,o=n.values,i=a.side,c=new SearchSortedProgram(r.shape[0],r.shape[1],o.shape[1],i),s=[[r.shape[1]]];return t.runWebGLProgram(c,[r,o],"int32",s)}},SelectProgram=function(e,n,t){if(this.variableNames=["c","a","b"],this.outputShape=n,t>4)throw Error("Where for rank ".concat(t," is not yet supported"));if(1===t)r="resRC",a="resRC";else{for(var a,r,o=["resRC.x","resRC.y","resRC.z","resRC.w"],i=[],c=[],s=0;s<n.length;s++)c.push("".concat(o[s])),s<e&&i.push("".concat(o[s]));a=i.join(),r=c.join()}var u=getCoordsDataType(t);this.userCode="\n      void main() {\n        ".concat(u," resRC = getOutputCoords();\n        float cVal = getC(").concat(a,");\n        if (cVal >= 1.0) {\n          setOutput(getA(").concat(r,"));\n        } else {\n          setOutput(getB(").concat(r,"));\n        }\n      }\n    ")},ah={kernelName:p.Select,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var n=e.inputs,t=e.backend,a=n.condition,r=n.t,o=n.e,i=new SelectProgram(a.shape.length,r.shape,r.shape.length);return t.runWebGLProgram(i,[a,r,o],p.upcastType(r.dtype,o.dtype))}},af=unaryKernelFunc({opSnippet:"\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ".concat(p.backend_util.SELU_SCALEALPHA,";\n  float scale = ").concat(p.backend_util.SELU_SCALE,";\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n")}),ax={kernelName:p.Selu,backendName:"webgl",kernelFunc:af},am=unaryKernelFunc({opSnippet:eh+"\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:W}),ag={kernelName:p.Sigmoid,backendName:"webgl",kernelFunc:am},av=unaryKernelFunc({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),ab={kernelName:p.Sign,backendName:"webgl",kernelFunc:av},aC=unaryKernelFunc({opSnippet:eh+"\n  return sin(x);\n",packedOpSnippet:"\n  vec4 result = sin(x);\n  bvec4 isNaN = isnan(x);\n  ".concat(er,"\n  return result;\n")}),ay={kernelName:p.Sin,backendName:"webgl",kernelFunc:aC},ak=unaryKernelFunc({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),aI={kernelName:p.Sinh,backendName:"webgl",kernelFunc:ak},aT=unaryKernelFunc({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),aS={kernelName:p.Softplus,backendName:"webgl",kernelFunc:aT},aR={kernelName:p.SpaceToBatchND,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.x,o=a.blockShape,i=a.paddings;p.util.assert(r.shape.length<=4,function(){return"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"});var c=o.reduce(function(e,n){return e*n}),s=[[0,0]];s.push.apply(s,__spreadArray([],__read(i),!1));for(var u=1+o.length;u<r.shape.length;++u)s.push([0,0]);var l=[],d=padV2({inputs:{x:r},backend:t,attrs:{paddings:s,constantValue:0}}),h=p.backend_util.getReshaped(d.shape,o,c,!1),f=p.backend_util.getPermuted(h.length,o.length,!1),x=p.backend_util.getReshapedPermuted(d.shape,o,c,!1),m=reshape({inputs:{x:d},backend:t,attrs:{shape:h}}),g=transpose({inputs:{x:m},backend:t,attrs:{perm:f}}),v=reshape({inputs:{x:g},backend:t,attrs:{shape:x}});return l.push(d),l.push(m),l.push(g),l.forEach(function(e){return t.disposeIntermediateTensorInfo(e)}),v}},aw={kernelName:p.SparseFillEmptyRows,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=n.indices,r=n.values,o=n.denseShape,i=n.defaultValue;if(1!==o.shape.length)throw Error("Dense shape must be a vector, saw:\n         ".concat(o.shape));if(2!==a.shape.length)throw Error("Indices must be a matrix, saw:\n         ".concat(a.shape));if(1!==r.shape.length)throw Error("Values must be a vector, saw:\n         ".concat(r.shape));if(0!==i.shape.length)throw Error("Default value must be a scalar, saw:\n        ".concat(i.shape));var c=t.readSync(a.dataId),s=t.readSync(r.dataId),u=t.readSync(o.dataId),l=t.readSync(i.dataId)[0],d=__read(sparseFillEmptyRowsImplCPU(c,a.shape,a.dtype,s,r.dtype,u,l),5),p=d[0],h=d[1],f=d[2],x=d[3],m=d[4];return[t.makeTensorInfo(h,a.dtype,p),t.makeTensorInfo([h[0]],r.dtype,f),t.makeTensorInfo([x.length],"bool",new Uint8Array(x.map(function(e){return Number(e)}))),t.makeTensorInfo([m.length],a.dtype,new Int32Array(m))]}},aP={kernelName:p.SparseReshape,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=n.inputIndices,r=n.inputShape,o=n.newShape;if(2!==a.shape.length)throw Error("Input indices should be a matrix but received shape ".concat(a.shape));if(1!==r.shape.length)throw Error("Input shape should be a vector but received shape ".concat(r.shape));if(1!==o.shape.length)throw Error("Target shape should be a vector but received shape ".concat(o.shape));var i=Array.from(t.readSync(r.dataId)),c=t.readSync(a.dataId),s=Array.from(t.readSync(o.dataId)),u=__read(sparseReshapeImplCPU(c,a.shape,a.dtype,i,s),3),l=u[0],d=u[1],p=u[2];return[t.makeTensorInfo(d,a.dtype,l),t.makeTensorInfo([p.length],o.dtype,new Int32Array(p))]}},a_={kernelName:p.SparseSegmentMean,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=n.data,r=n.indices,o=n.segmentIds;if(a.shape.length<1)throw Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw Error("Indices should be a vector but received shape\n              ".concat(r.shape));if(1!==o.shape.length)throw Error("Segment ids should be a vector but received shape\n              ".concat(o.shape));var i=t.readSync(a.dataId),c=t.readSync(r.dataId),s=t.readSync(o.dataId),u=__read(sparseSegmentReductionImplCPU(i,a.shape,a.dtype,c,s,!0),2),l=u[0],d=u[1];return t.makeTensorInfo(d,a.dtype,l)}},aE={kernelName:p.SparseSegmentSum,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=n.data,r=n.indices,o=n.segmentIds;if(a.shape.length<1)throw Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw Error("Indices should be a vector but received shape\n             ".concat(r.shape));if(1!==o.shape.length)throw Error("Segment ids should be a vector but received shape\n             ".concat(o.shape));var i=t.readSync(a.dataId),c=t.readSync(r.dataId),s=t.readSync(o.dataId),u=__read(sparseSegmentReductionImplCPU(i,a.shape,a.dtype,c,s),2),l=u[0],d=u[1];return t.makeTensorInfo(d,a.dtype,l)}},aF={kernelName:p.SparseToDense,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.sparseIndices,o=n.sparseValues,i=n.defaultValue,c=a.outputShape,s=p.backend_util.calculateShapes(o,r,c),u=s.sliceRank,l=s.numUpdates,d=s.sliceSize,h=s.strides,f=s.outputSize;if("string"===o.dtype){var x=scatterImplCPU(t.bufferSync(r),t.bufferSync(o),c,f,d,l,u,h,p.util.decodeString(t.readSync(i.dataId)[0]),!1);return t.makeTensorInfo(c,x.dtype,x.values)}var m=new ScatterProgram(l,u,r.shape.length,o.shape.length,h,[f,1],!1),g=t.runWebGLProgram(m,[o,r,i],o.dtype),v=reshape({inputs:{x:g},backend:t,attrs:{shape:c}});return t.disposeIntermediateTensorInfo(g),v}},aN={kernelName:p.SplitV,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.x,o=a.numOrSizeSplits,i=a.axis,c=p.util.parseAxisParam(i,r.shape)[0],s=p.backend_util.prepareSplitSize(r,o,c),u=Array(r.shape.length).fill(0),l=r.shape.slice();return s.map(function(e){var n=__spreadArray([],__read(l),!1);n[c]=e;var a=slice({inputs:{x:r},backend:t,attrs:{begin:u,size:n}});return u[c]+=e,a})}},aA="return sqrt(x);",aO=unaryKernelFunc({opSnippet:aA,packedOpSnippet:aA,cpuKernelImpl:V}),aD={kernelName:p.Sqrt,backendName:"webgl",kernelFunc:aO},aL=unaryKernelFunc({opSnippet:"return x * x;"}),aB={kernelName:p.Square,backendName:"webgl",kernelFunc:aL},aU="return (a - b) * (a - b);",aG=binaryKernelFunc({opSnippet:aU,packedOpSnippet:aU}),aM={kernelName:p.SquaredDifference,backendName:"webgl",kernelFunc:aG},aW={kernelName:p.StaticRegexReplace,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.x;if("string"!==r.dtype)throw Error("Input must be of datatype string");var o=t.readSync(r.dataId),i=z(p.backend_util.fromUint8ToStringArray(o),"string",a);return t.makeTensorInfo(r.shape,"string",i)}},aV={kernelName:p.Step,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var n=e.inputs,t=e.attrs,a=e.backend,r=n.x,o=q+"\n    return x > 0.0 ? 1.0 : float(".concat(t.alpha,");\n  "),i=new UnaryOpProgram(r.shape,o);return a.runWebGLProgram(i,[r],r.dtype)}},StridedSliceProgram=function(e,n,t){this.variableNames=["x"],this.outputShape=t;var a=t.length,r=getCoordsDataType(t.length),o=getCoordsDataType(t.length),i="";if(1===a)i="coords * strides + begin";else{var c=0;i=t.map(function(e,n){return c++,1===t.length?"coords * strides[".concat(n,"] + begin[").concat(n,"]"):"coords[".concat(c-1,"] * strides[").concat(n,"] + begin[").concat(n,"]")}).join(",")}this.userCode="\n      ".concat(r," begin = ").concat(r,"(").concat(e,");\n      ").concat(r," strides = ").concat(r,"(").concat(n,");\n\n      void main() {\n        ").concat(o," coords = getOutputCoords();\n        setOutput(getX(").concat(i,"));\n      }\n    ")},az={kernelName:p.StridedSlice,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var n,t=e.inputs,a=e.backend,r=e.attrs,o=t.x,i=r.begin,c=r.end,s=r.strides,u=r.beginMask,l=r.endMask,d=r.ellipsisMask,h=r.newAxisMask,f=r.shrinkAxisMask,x=p.slice_util.sliceInfo(o.shape,i,c,s,u,l,d,h,f),m=x.finalShapeSparse,g=x.finalShape,v=x.isIdentity,b=x.sliceDim0,C=x.isSimpleSlice,y=x.begin,k=x.end,I=x.strides;if(v)n=reshape({inputs:{x:o},backend:a,attrs:{shape:g}});else if(b||C){p.util.assert(o.shape.length>=1,function(){return"Input must have rank at least 1, got: ".concat(o.shape.length)});var T=p.slice_util.computeOutShape(y,k,I),S=slice({inputs:{x:o},backend:a,attrs:{begin:y,size:T}});n=reshape({inputs:{x:S},backend:a,attrs:{shape:g}}),a.disposeIntermediateTensorInfo(S)}else if(a.shouldExecuteOnCPU([o])){var R=a.readSync(o.dataId),w=stridedSliceImplCPU(m,p.buffer(o.shape,o.dtype,R),I,y);n=a.makeTensorInfo(g,o.dtype,w.values)}else{var P=new StridedSliceProgram(y,I,m);n=a.runWebGLProgram(P,[o],o.dtype)}var _=reshape({inputs:{x:n},backend:a,attrs:{shape:g}});return a.disposeIntermediateTensorInfo(n),_}},aX={kernelName:p.StringNGrams,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=a.separator,o=a.nGramWidths,i=a.leftPad,c=a.rightPad,s=a.padWidth,u=a.preserveShortSequences,l=n.data,d=n.dataSplits,p=t.readSync(l.dataId),h=t.readSync(d.dataId),f=__read(new X(r,o,i,c,s,u).compute(p,h),2),x=f[0],m=f[1];return[t.makeTensorInfo([x.length],"string",x),t.makeTensorInfo(d.shape,"int32",m)]}},aH={kernelName:p.StringSplit,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs.skipEmpty,r=n.input,o=n.delimiter;if("string"!==r.dtype)throw Error("Input must be of datatype string");if(1!==r.shape.length)throw Error("Input must be a vector, got shape: ".concat(r.shape));if(0!==o.shape.length)throw Error("Delimiter must be a scalar, got shape: ".concat(o.shape));var i=__read(stringSplitImplCPU(t.readSync(r.dataId),t.readSync(o.dataId)[0],a),3),c=i[0],s=i[1],u=i[2],l=s.length;return[t.makeTensorInfo([l,2],"int32",c),t.makeTensorInfo([l],"string",s),t.makeTensorInfo([2],"int32",new Int32Array(u))]}},aK={kernelName:p.StringToHashBucketFast,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var n=e.inputs,t=e.backend,a=e.attrs.numBuckets,r=n.input;if("string"!==r.dtype)throw Error("Input must be of datatype string");if(a<=0)throw Error("Number of buckets must be at least 1");var o=stringToHashBucketFastImplCPU(t.readSync(r.dataId),a);return t.makeTensorInfo(r.shape,"int32",o)}},aj=unaryKernelFunc({opSnippet:"return tan(x);"}),aq={kernelName:p.Tan,backendName:"webgl",kernelFunc:aj},aY=unaryKernelFunc({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),aQ={kernelName:p.Tanh,backendName:"webgl",kernelFunc:aY},aZ={kernelName:p.TensorScatterUpdate,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var n=e.inputs,t=e.backend;e.attrs;var a=n.tensor,r=n.indices,o=n.updates,i=p.backend_util.calculateShapes(o,r,a.shape),c=i.sliceRank,s=i.numUpdates,u=i.sliceSize,l=i.strides,d=i.outputSize,h=[d/u,u];if(0===d)return t.makeTensorInfo(a.shape,r.dtype);var f=reshape({inputs:{x:r},backend:t,attrs:{shape:[s,c]}}),x=reshape({inputs:{x:o},backend:t,attrs:{shape:[s,u]}}),m=reshape({inputs:{x:a},backend:t,attrs:{shape:h}}),g=new ScatterProgram(s,c,f.shape.length,x.shape.length,l,h,!1,!0),v=t.runWebGLProgram(g,[x,f,m],m.dtype),b=reshape({inputs:{x:v},backend:t,attrs:{shape:a.shape}});return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(v),b}},TileProgram=function(e,n){this.variableNames=["A"];for(var t=Array(e.length),a=0;a<t.length;a++)t[a]=e[a]*n[a];this.outputShape=t,this.rank=t.length;var r=getCoordsDataType(this.rank),o=function(e){var n=e.length;if(n>5)throw Error("Tile for rank ".concat(n," is not yet supported"));if(1===n)return"imod(resRC, ".concat(e[0],")");for(var t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],a=[],r=0;r<e.length;r++)a.push("imod(".concat(t[r],", ").concat(e[r],")"));return a.join()}(e);this.userCode="\n      void main() {\n        ".concat(r," resRC = getOutputCoords();\n        setOutput(getA(").concat(o,"));\n      }\n    ")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tile(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.x,o=a.reps;if("string"===r.dtype||r.shape.length>5){var i=t.readSync(r.dataId),c="string"===r.dtype?i.map(function(e){return p.util.decodeString(e)}):i,s=tileImplCPU(p.buffer(r.shape,r.dtype,c),o);return t.makeTensorInfo(s.shape,s.dtype,s.values)}var u=new TileProgram(r.shape,o);return t.runWebGLProgram(u,[r],r.dtype)}var aJ={kernelName:p.Tile,backendName:"webgl",kernelFunc:tile},SwapProgram=function(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "},MergeProgram=function(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "};function disposeIntermediateTensorInfoOrNull(e,n){null!==n&&e.disposeIntermediateTensorInfo(n)}function roundUpToPow2(e){for(var n=1;n<e;)n*=2;return n}var a$={kernelName:p.TopK,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.x,o=a.k,i=a.sorted,c=p.env().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),s=p.env().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),u=r.shape,l=u[u.length-1];if(t.shouldExecuteOnCPU([r])||l<c||o>s){var d=__read(topKImplCPU(t.readSync(r.dataId),u,r.dtype,o,i),2),h=d[0],f=d[1];return[t.makeTensorInfo(h.shape,h.dtype,h.values),t.makeTensorInfo(f.shape,f.dtype,f.values)]}if(0===o)return u[u.length-1]=0,[t.makeTensorInfo(u,r.dtype,[]),t.makeTensorInfo(u,"int32",[])];if(1===l)return[r,fill({attrs:{shape:u,dtype:"int32",value:0},backend:t})];var x=t.texData.get(r.dataId),m=null!==x&&x.isPacked,g=m?t.unpackTensor(r):r,v=p.util.sizeFromShape(u)/l,b=reshape({inputs:{x:g},attrs:{shape:[v,l]},backend:t});m&&disposeIntermediateTensorInfoOrNull(t,g);for(var C=roundUpToPow2(o),y=roundUpToPow2(l),k=null,getInputs=function(){return null===k?[b,b]:[b,k]},runSwap=function(e,n,a){var r=getInputs(),o=new SwapProgram(a),i=[[l],[null===k?1:0],[Number.NEGATIVE_INFINITY],[e],[n]],c=k;k=t.runWebGLProgram(o,r,"int32",i),disposeIntermediateTensorInfoOrNull(t,c)},I=1;I<C;I*=2)for(var T=2*I,S=I;S>=1;S/=2)runSwap(T,S,[v,y]);for(var R=y;R>C;R/=2){var w=getInputs(),P=new MergeProgram([v,R/2]),_=[[l],[null===k?1:0],[C]],E=k;k=t.runWebGLProgram(P,w,"int32",_),disposeIntermediateTensorInfoOrNull(t,E);for(var I=C/2,T=2*I,S=I;S>=1;S/=2)runSwap(T,S,k.shape)}var F=k;k=slice({inputs:{x:k},backend:t,attrs:{begin:0,size:[v,o]}}),disposeIntermediateTensorInfoOrNull(t,F);var N=gatherV2({inputs:{x:b,indices:k},backend:t,attrs:{axis:1,batchDims:1}});disposeIntermediateTensorInfoOrNull(t,b);var A=u.slice(0,-1);A.push(o),F=k,k=reshape({inputs:{x:k},attrs:{shape:A},backend:t}),disposeIntermediateTensorInfoOrNull(t,F);var O=N;return N=reshape({inputs:{x:N},attrs:{shape:A},backend:t}),disposeIntermediateTensorInfoOrNull(t,O),[N,k]}},TransformProgram=function(e,n,t,a,r,o){var i;switch(this.variableNames=["Image","Transforms"],this.outputShape=o,a){case"constant":default:i=1;break;case"reflect":i=2;break;case"wrap":i=3;break;case"nearest":i=4}this.userCode="\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(".concat(i," == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (").concat(i," == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (").concat(i," == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ").concat(e," && 0 <= coordX && coordX < ").concat(n,") {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(").concat(r,");\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(").concat(r,");\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(").concat(n,"));\n                float mapY = mapCoord(inY, float(").concat(e,"));\n\n                if (").concat("nearest"===t?1:2," == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        ")},a0={kernelName:p.Transform,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.image,o=n.transforms,i=a.interpolation,c=a.fillMode,s=a.fillValue,u=a.outputShape,l=__read(r.shape,4),d=l[0],p=l[1],h=l[2],f=l[3],x=__read(null!=u?u:[p,h],2),m=[d,x[0],x[1],f],g=new TransformProgram(p,h,i,c,s,m);return t.runWebGLProgram(g,[r,o],"float32")}},a1={kernelName:p.Unique,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var n=e.inputs,t=e.attrs,a=e.backend,r=t.axis,o=n.x;assertNotComplex(o,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");var i=uniqueImplCPU(a.readSync(o.dataId),r,o.shape,o.dtype),c=i.outputValues,s=i.outputShape,u=i.indices;return[a.makeTensorInfo(s,o.dtype,c),a.makeTensorInfo([u.length],"int32",u)]}},a2={kernelName:p.Unpack,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.value,o=a.axis;o<0&&(o+=r.shape.length);for(var i=r.shape.length,c=r.shape[o],s=Array(i-1),u=0,l=0;l<i;l++)l!==o&&(s[u++]=r.shape[l]);var d=[],p=Array(i).fill(0),h=r.shape.slice();h[o]=1;for(var f=Array(c),l=0;l<f.length;l++){p[o]=l;var x=slice({inputs:{x:r},backend:t,attrs:{begin:p,size:h}}),m=reshape({inputs:{x:x},backend:t,attrs:{shape:s}});f[l]=m,d.push(x)}return d.forEach(function(e){return t.disposeIntermediateTensorInfo(e)}),f}},SegmentOpProgram=function(e,n){this.variableNames=["x","segmentIds"];var t=e.windowSize,a=e.batchSize,r=e.inSize,o=e.numSegments,i=o*Math.ceil(r/t);this.outputShape=[a,i];var c=4*Math.floor(t/4),s=t%4,u="\n        sumValue += dot(values, segFilter);\n    ",l="";r%t>0&&(l="\n        if (inIdx < 0 || inIdx >= ".concat(r,") {\n          return initializationValue;\n        }\n      "));var d="";r%t>0&&(d="\n        if (inIdx < 0 || inIdx >= ".concat(r,") {\n          return -1.0;\n        }\n      ")),this.userCode="\n      const float initializationValue = ".concat("0.0",";\n\n      float getValue(int batch, int inIdx) {\n        ").concat(l,"\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ").concat(d,"\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ").concat(o,")) * float(").concat(t,"));\n        int currentSeg = int(mod(float(outIdx), float(").concat(o,")));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ").concat(c,"; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ").concat(u,"\n        }\n\n        int inIdx = inOffset + ").concat(c,";\n        if (").concat(1===s,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ").concat(u,"\n        } else if (").concat(2===s,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ").concat(u,"\n        } else if (").concat(3===s,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ").concat(u,"\n        }\n        setOutput(").concat("sumValue",");\n      }\n    ")},a4={kernelName:p.UnsortedSegmentSum,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.x,o=n.segmentIds,i=a.numSegments,c=r.shape.length,s=[],u=0,l=p.backend_util.getAxesPermutation([u],c),d=r;null!=l&&(d=transpose({inputs:{x:r},backend:t,attrs:{perm:l}}),s.push(d),u=p.backend_util.getInnerMostAxes(1,c)[0]);var h=p.backend_util.segment_util.computeOutShape(d.shape,u,i),f=p.util.sizeFromShape([d.shape[u]]),x=reshape({inputs:{x:d},backend:t,attrs:{shape:[-1,f]}});s.push(x);var m=p.sumOutType(r.dtype),segOpCompute=function(e,n,a,r,o){var i=e.shape[0],c=e.shape[1],u=p.backend_util.segment_util.segOpComputeOptimalWindowSize(c,o),l=new SegmentOpProgram({windowSize:u,inSize:c,batchSize:i,numSegments:o},n),d=t.compileAndRun(l,[e,a],r);if(s.push(d),d.shape[1]===o)return d;var h=range({backend:t,attrs:{start:0,stop:o,step:1,dtype:"float32"}}),f=tile({inputs:{x:h},backend:t,attrs:{reps:[c/u]}});return s.push(h),s.push(f),segOpCompute(d,n,f,r,o)},g=reshape({inputs:{x:segOpCompute(x,"unsortedSegmentSum",o,m,i)},backend:t,attrs:{shape:h}}),v=g;return null!=l&&(s.push(g),v=transpose({inputs:{x:v},backend:t,attrs:{perm:p.backend_util.getUndoAxesPermutation(l)}})),s.forEach(function(e){return t.disposeIntermediateTensorInfo(e)}),v}};try{for(var a3=__values([eC,ek,eT,eR,e_,eE,eF,eN,eA,eO,eL,eU,eM,eV,eX,eH,eK,ej,eq,eY,eQ,e$,e0,e1,e2,e6,e9,ne,ei,nn,na,nr,no,ni,nc,ns,nu,nd,nh,nf,nx,nm,ng,nb,nC,ny,nk,nI,nT,nS,nw,nP,nE,nN,nO,nD,nU,nG,nM,nW,nX,nK,nj,nY,nQ,nZ,nJ,n0,n2,eo,n4,nt,n5,n8,n9,eu,tn,ta,tr,ti,ts,tl,tp,tf,tx,tm,tg,tb,tC,ty,tk,tI,tT,tS,tR,tP,t_,tF,tU,em,tM,tV,tX,tK,e3,tj,tY,tQ,tZ,t$,ep,t0,t1,t2,t4,t3,e5,tA,t6,t7,ae,eg,an,at,aa,ar,ao,ai,as,al,ad,ap,ah,ax,ag,ab,ay,aI,eJ,tB,aS,aR,aw,aP,a_,aE,aF,aN,aD,aB,aM,aW,aV,az,aX,aH,aK,tL,ev,aq,aQ,aZ,aJ,a$,a0,eb,a1,a2,a4,tq]),a5=a3.next();!a5.done;a5=a3.next()){var a6=a5.value;p.registerKernel(a6)}}catch(e){l={error:e}}finally{try{a5&&!a5.done&&(d=a3.return)&&d.call(a3)}finally{if(l)throw l.error}}n.GPGPUContext=y,n.MathBackendWebGL=et,n.forceHalfFloat=forceHalfFloat,n.gpgpu_util={__proto__:null,bindVertexProgramAttributeStreams:bindVertexProgramAttributeStreams,createBufferFromOutputTexture:createBufferFromOutputTexture,createFloat16MatrixTexture:createFloat16MatrixTexture,createFloat16PackedMatrixTexture:createFloat16PackedMatrixTexture,createFloat32MatrixTexture:createFloat32MatrixTexture,createIndexBuffer:createIndexBuffer,createPackedMatrixTexture:createPackedMatrixTexture,createUnsignedBytesMatrixTexture:createUnsignedBytesMatrixTexture,createVertexBuffer:createVertexBuffer,createVertexShader:createVertexShader,downloadByteEncodedFloatMatrixFromOutputTexture:downloadByteEncodedFloatMatrixFromOutputTexture,downloadFloat32MatrixFromBuffer:downloadFloat32MatrixFromBuffer,downloadMatrixFromPackedOutputTexture:downloadMatrixFromPackedOutputTexture,downloadPackedMatrixFromBuffer:downloadPackedMatrixFromBuffer,getInternalFormatForFloat16MatrixTexture:getInternalFormatForFloat16MatrixTexture,getInternalFormatForFloat16PackedMatrixTexture:getInternalFormatForFloat16PackedMatrixTexture,getInternalFormatForFloat32MatrixTexture:getInternalFormatForFloat32MatrixTexture,getInternalFormatForPackedMatrixTexture:getInternalFormatForPackedMatrixTexture,getInternalFormatForUnsignedBytesMatrixTexture:getInternalFormatForUnsignedBytesMatrixTexture,uploadDenseMatrixToTexture:uploadDenseMatrixToTexture,uploadPixelDataToTexture:uploadPixelDataToTexture},n.setWebGLContext=function(e,n){f[e]=n},n.version_webgl="4.20.0",n.webgl={forceHalfFloat:forceHalfFloat},n.webgl_util={__proto__:null,assertNotComplex:assertNotComplex,bindCanvasToFramebuffer:function(e){callAndCheck(e,function(){return e.bindFramebuffer(e.FRAMEBUFFER,null)}),callAndCheck(e,function(){return e.viewport(0,0,e.canvas.width,e.canvas.height)}),callAndCheck(e,function(){return e.scissor(0,0,e.canvas.width,e.canvas.height)})},bindColorTextureToFramebuffer:bindColorTextureToFramebuffer,bindTextureToProgramUniformSampler:bindTextureToProgramUniformSampler,bindTextureUnit:bindTextureUnit,bindVertexBufferToProgramAttribute:bindVertexBufferToProgramAttribute,callAndCheck:callAndCheck,canBeRepresented:canBeRepresented,createFragmentShader:createFragmentShader,createFramebuffer:createFramebuffer,createProgram:createProgram,createStaticIndexBuffer:createStaticIndexBuffer,createStaticVertexBuffer:createStaticVertexBuffer,createTexture:createTexture,createVertexShader:createVertexShader$1,getBatchDim:getBatchDim,getExtensionOrThrow:getExtensionOrThrow,getFramebufferErrorMessage:getFramebufferErrorMessage,getMaxTexturesInShader:getMaxTexturesInShader,getNumChannels:function(){return 2===p.env().getNumber("WEBGL_VERSION")?1:4},getProgramUniformLocation:getProgramUniformLocation,getProgramUniformLocationOrThrow:getProgramUniformLocationOrThrow,getRowsCols:getRowsCols,getShapeAs3D:getShapeAs3D,getTextureShapeFromLogicalShape:getTextureShapeFromLogicalShape,getWebGLDisjointQueryTimerVersion:getWebGLDisjointQueryTimerVersion,getWebGLErrorMessage:getWebGLErrorMessage,getWebGLMaxTextureSize:getWebGLMaxTextureSize,hasExtension:hasExtension,isCapableOfRenderingToFloatTexture:isCapableOfRenderingToFloatTexture,isDownloadFloatTextureEnabled:isDownloadFloatTextureEnabled,isReshapeFree:isReshapeFree,isWebGLFenceEnabled:isWebGLFenceEnabled,isWebGLVersionEnabled:isWebGLVersionEnabled,linkProgram:linkProgram,logShaderSourceAndInfoLog:logShaderSourceAndInfoLog,resetMaxTextureSize:function(){i=null},resetMaxTexturesInShader:function(){c=null},unbindColorTextureFromFramebuffer:unbindColorTextureFromFramebuffer,unbindTextureUnit:function(e,n){validateTextureUnit(e,n),callAndCheck(e,function(){return e.activeTexture(e.TEXTURE0+n)}),callAndCheck(e,function(){return e.bindTexture(e.TEXTURE_2D,null)})},validateFramebuffer:validateFramebuffer,validateProgram:validateProgram,validateTextureSize:validateTextureSize}}};