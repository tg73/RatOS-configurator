"use strict";exports.id=9541,exports.ids=[9541],exports.modules={19541:(e,t,n)=>{/**
 * @license
 * Copyright 2024 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var a,r,i,o,s,u,c,d,p=n(52013),l=function(e){var t=Object.create(null);return e&&Object.keys(e).forEach(function(n){if("default"!==n){var a=Object.getOwnPropertyDescriptor(e,n);Object.defineProperty(t,n,a.get?a:{enumerable:!0,get:function(){return e[n]}})}}),t.default=e,t}(p),extendStatics=function(e,t){return(extendStatics=Object.setPrototypeOf||({__proto__:[]})instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])})(e,t)};function __awaiter(e,t,n,a){return new(n||(n=Promise))(function(r,i){function fulfilled(e){try{step(a.next(e))}catch(e){i(e)}}function rejected(e){try{step(a.throw(e))}catch(e){i(e)}}function step(e){var t;e.done?r(e.value):((t=e.value)instanceof n?t:new n(function(e){e(t)})).then(fulfilled,rejected)}step((a=a.apply(e,t||[])).next())})}function __generator(e,t){var n,a,r,i,o={label:0,sent:function(){if(1&r[0])throw r[1];return r[1]},trys:[],ops:[]};return i={next:verb(0),throw:verb(1),return:verb(2)},"function"==typeof Symbol&&(i[Symbol.iterator]=function(){return this}),i;function verb(i){return function(s){return function(i){if(n)throw TypeError("Generator is already executing.");for(;o;)try{if(n=1,a&&(r=2&i[0]?a.return:i[0]?a.throw||((r=a.return)&&r.call(a),0):a.next)&&!(r=r.call(a,i[1])).done)return r;switch(a=0,r&&(i=[2&i[0],r.value]),i[0]){case 0:case 1:r=i;break;case 4:return o.label++,{value:i[1],done:!1};case 5:o.label++,a=i[1],i=[0];continue;case 7:i=o.ops.pop(),o.trys.pop();continue;default:if(!(r=(r=o.trys).length>0&&r[r.length-1])&&(6===i[0]||2===i[0])){o=0;continue}if(3===i[0]&&(!r||i[1]>r[0]&&i[1]<r[3])){o.label=i[1];break}if(6===i[0]&&o.label<r[1]){o.label=r[1],r=i;break}if(r&&o.label<r[2]){o.label=r[2],o.ops.push(i);break}r[2]&&o.ops.pop(),o.trys.pop();continue}i=t.call(e,o)}catch(e){i=[6,e],a=0}finally{n=r=0}if(5&i[0])throw i[1];return{value:i[0]?i[1]:void 0,done:!0}}([i,s])}}}function __values(e){var t="function"==typeof Symbol&&Symbol.iterator,n=t&&e[t],a=0;if(n)return n.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&a>=e.length&&(e=void 0),{value:e&&e[a++],done:!e}}};throw TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")}function __read(e,t){var n="function"==typeof Symbol&&e[Symbol.iterator];if(!n)return e;var a,r,i=n.call(e),o=[];try{for(;(void 0===t||t-- >0)&&!(a=i.next()).done;)o.push(a.value)}catch(e){r={error:e}}finally{try{a&&!a.done&&(n=i.return)&&n.call(i)}finally{if(r)throw r.error}}return o}function __spreadArray(e,t,n){if(n||2==arguments.length)for(var a,r=0,i=t.length;r<i;r++)!a&&r in t||(a||(a=Array.prototype.slice.call(t,0,r)),a[r]=t[r]);return e.concat(a||Array.prototype.slice.call(t))}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var h=p.env();h.registerFlag("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE",function(){return 15}),h.registerFlag("WEBGPU_CPU_FORWARD",function(){return!0}),h.registerFlag("WEBGPU_MATMUL_PROGRAM_TYPE",function(){return -1}),h.registerFlag("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE",function(){return!0}),h.registerFlag("WEBGPU_USE_LOW_POWER_GPU",function(){return!1}),h.registerFlag("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD",function(){return 1e3}),h.registerFlag("WEBGPU_USE_PROFILE_TOOL",function(){return!1}),h.registerFlag("WEBGPU_IMPORT_EXTERNAL_TEXTURE",function(){return!0}),h.registerFlag("WEBGPU_USE_NAIVE_CONV2D_DEBUG",function(){return!1}),h.registerFlag("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL",function(){return -1}),h.registerFlag("WEBGPU_CONV_SEPARATE_IM2COL_SHADER",function(){return!1}),h.registerFlag("WEBGPU_PRINT_SHADER",function(){return""}),h.registerFlag("WEBGPU_ENGINE_COMPILE_ONLY",function(){return!1});/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var f=function(){function AdapterInfo(e){e&&(this.vendor=e.vendor,this.architecture=e.architecture,this.intelGPUGeneration=this.getIntelGPUGeneration())}return AdapterInfo.prototype.getIntelGPUGeneration=function(){if(this.isIntel()){if(this.architecture.startsWith("gen"))return Number(this.architecture.match(/\d+/));if(this.architecture.startsWith("xe"))return 12}return 0},AdapterInfo.prototype.isIntel=function(){return"intel"===this.vendor},AdapterInfo}(),m=function(){function BufferManager(e){this.device=e,this.numUsedBuffers=0,this.numFreeBuffers=0,this.freeBuffers=new Map,this.usedBuffers=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}return BufferManager.prototype.acquireBuffer=function(e,t,n,a){void 0===n&&(n=!1),void 0===a&&(a=!0);var r,i=getBufferKey(e,t);return a?(this.freeBuffers.has(i)||this.freeBuffers.set(i,[]),this.freeBuffers.get(i).length>0?(r=this.freeBuffers.get(i).pop(),this.numFreeBuffers--):(r=this.device.createBuffer({size:e,usage:t,mappedAtCreation:n}),this.numBytesAllocated+=e)):(r=this.device.createBuffer({size:e,usage:t,mappedAtCreation:n}),this.numBytesAllocated+=e),this.usedBuffers.has(i)||this.usedBuffers.set(i,[]),this.usedBuffers.get(i).push(r),this.numUsedBuffers++,this.numBytesUsed+=e,r},BufferManager.prototype.releaseBuffer=function(e,t){if(void 0===t&&(t=!0),0!==this.freeBuffers.size){var n=e.size,a=getBufferKey(n,e.usage),r=this.usedBuffers.get(a),i=r.indexOf(e);if(i<0)throw Error("Cannot find the buffer in buffer manager");r[i]=r[r.length-1],r.pop(),this.numUsedBuffers--,this.numBytesUsed-=n,t?(this.freeBuffers.get(a).push(e),this.numFreeBuffers++):(e.destroy(),this.numBytesAllocated-=n)}},BufferManager.prototype.getNumUsedBuffers=function(){return this.numUsedBuffers},BufferManager.prototype.getNumFreeBuffers=function(){return this.numFreeBuffers},BufferManager.prototype.dispose=function(){this.freeBuffers.forEach(function(e,t){e.forEach(function(e){e.destroy()})}),this.usedBuffers.forEach(function(e,t){e.forEach(function(e){e.destroy()})}),this.freeBuffers=new Map,this.usedBuffers=new Map,this.numUsedBuffers=0,this.numFreeBuffers=0,this.numBytesUsed=0,this.numBytesAllocated=0},BufferManager}();function getBufferKey(e,t){return"".concat(e,"_").concat(t)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var g=function(){function TextureManager(e){this.device=e,this.numUsedTextures=0,this.numFreeTextures=0,this.freeTextures=new Map,this.usedTextures=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}return TextureManager.prototype.acquireTexture=function(e,t,n,a){var r=e*t*getBytesPerElement(n),i=getTextureKey(e,t,n,a);if(this.freeTextures.has(i)||this.freeTextures.set(i,[]),this.usedTextures.has(i)||this.usedTextures.set(i,[]),this.numBytesUsed+=r,this.numUsedTextures++,this.freeTextures.get(i).length>0){this.numFreeTextures--;var o=this.freeTextures.get(i).shift();return this.usedTextures.get(i).push(o),o}this.numBytesAllocated+=r;var s=this.device.createTexture({size:[e,t],format:n,usage:a});return this.usedTextures.get(i).push(s),s},TextureManager.prototype.releaseTexture=function(e){if(0!==this.freeTextures.size){var t=e.width,n=e.height,a=e.format,r=getTextureKey(t,n,a,e.usage);this.freeTextures.has(r)||this.freeTextures.set(r,[]),this.freeTextures.get(r).push(e),this.numFreeTextures++,this.numUsedTextures--;var i=this.usedTextures.get(r),o=i.indexOf(e);if(o<0)throw Error("Cannot release a texture that was never provided by this texture manager");i.splice(o,1);var s=t*n*getBytesPerElement(a);this.numBytesUsed-=s}},TextureManager.prototype.getNumUsedTextures=function(){return this.numUsedTextures},TextureManager.prototype.getNumFreeTextures=function(){return this.numFreeTextures},TextureManager.prototype.dispose=function(){this.freeTextures.forEach(function(e,t){e.forEach(function(e){e.destroy()})}),this.usedTextures.forEach(function(e,t){e.forEach(function(e){e.destroy()})}),this.freeTextures=new Map,this.usedTextures=new Map,this.numUsedTextures=0,this.numFreeTextures=0,this.numBytesUsed=0,this.numBytesAllocated=0},TextureManager}();function getTextureKey(e,t,n,a){return"".concat(e,"_").concat(t,"_").concat(n,"_").concat(a)}function getBytesPerElement(e){if("rgba8unorm"===e)return 16;throw Error("".concat(e," is not supported!"))}var atomicAddSnippet=function(e,t,n){return"int32"===n?"atomicAdd(".concat(e,", bitcast<i32>(").concat(t,"));"):"\n          {\n            var oldValue = 0;\n            loop {\n              let newValueF32 = bitcast<f32>(oldValue) + (".concat(t,");\n              let newValue = bitcast<i32>(newValueF32);\n              let res = atomicCompareExchangeWeak(").concat(e,", oldValue, newValue);\n              if res.exchanged {\n                break;\n              }\n              oldValue = res.old_value;\n            }\n          }")};!function(e){e[e.FROM_PIXELS=0]="FROM_PIXELS",e[e.DRAW=1]="DRAW"}(a||(a={}));var compileProgram=function(e,t,n,r,i){var o=function(e,t,n){var r,i,o=[],s=n.workgroupSize[0]*n.workgroupSize[1]*n.workgroupSize[2];if(n.outputComponent=n.outputComponent?n.outputComponent:1,o.push("\n\n      var<private> localId: vec3<u32>;\n      var<private> localIndex: u32;\n      var<private> globalId: vec3<u32>;\n      var<private> numWorkgroups: vec3<u32>;\n      var<private> workgroupId: vec3<u32>;\n\n      // Only used when the y/z dimension of workgroup size is 1.\n      fn getGlobalIndex() -> i32 {\n        ".concat(isFlatDispatch(n)?"  return i32(globalId.x);":"  return i32((workgroupId.z * numWorkgroups.x * numWorkgroups.y +\n                workgroupId.y * numWorkgroups.x + workgroupId.x) * ".concat(s,"u +\n                localIndex);\n        "),"\n      }\n    ")),null!=n.pixelsOpType){var u=n.pixelsOpType===a.FROM_PIXELS?"@group(0) @binding(0) var<storage, read_write> result: array<".concat(dataTypeToGPUType(t.dtype,n.outputComponent),">;"):"@group(0) @binding(1) var<storage, read> inBuf : array<".concat(dataTypeToGPUType(e[0].dtype,n.outputComponent),">;"),c=3===t.shape.length?"vec2<i32>":"i32";o.push("\n        struct Uniform {\n          outShapeStrides : ".concat(c,",\n          size            : i32,\n          numChannels     : i32,\n          alpha           : f32,\n        };\n\n        ").concat(u,"\n        @group(0) @binding(2) var<uniform> uniforms: Uniform;\n      "));var d=isFlatDispatchLayout(n);return[y,o.join("\n"),getCoordsFromIndexSnippet(t.shape),n.getUserCode(),getStartHeaderString(d,n)].join("\n")}var l="struct Uniforms { NAN : f32, INFINITY : f32, ";n.variableNames.forEach(function(t,n){var a=getCoordsDataType(e[n].shape.length);l+="".concat(t.charAt(0).toLowerCase()+t.slice(1),"Shape : ").concat(a,", "),i=getCoordsDataType(e[n].shape.length-1),l+="".concat(t.charAt(0).toLowerCase()+t.slice(1),"ShapeStrides: ").concat(i,", ")});var h=getCoordsDataType(t.shape.length);l+="outShape : ".concat(h,", "),i=getCoordsDataType(t.shape.length-1),l+="\n         outShapeStrides: ".concat(i,", "),n.size&&(l+="size : i32, "),n.uniforms&&(l+=n.uniforms),l+="};",l=l.replace(/(\w+)\s*:\s*vec(5|6)/g,function(e){return"@align(16) "+e}).replace(/vec(5|6)\s*,\s*(\w+)/g,function(e,t,n){return"vec".concat(t,", @align(16) ").concat(n)}),o.push(l),n.atomic?o.push("\n      @group(0) @binding(0) var<storage, read_write> result: array<atomic<i32>>;\n    "):o.push("\n      @group(0) @binding(0) var<storage, read_write> result: array<".concat(dataTypeToGPUType(t.dtype,n.outputComponent),">;\n    ")),n.variableNames.forEach(function(t,a){o.push("\n      @group(0) @binding(".concat(1+a,") var<storage, read> ").concat(t,": array<").concat(n.variableComponents?dataTypeToGPUType(e[a].dtype,n.variableComponents[a]):dataTypeToGPUType(e[a].dtype,n.outputComponent),">;\n        "))}),""!==l&&o.push("\n      @group(0) @binding(".concat(1+n.variableNames.length,") var<uniform> uniforms: Uniforms;\n      "));var f=function(e,t){var n=t.x,a=t.y,r=void 0===a?[]:a,i=t.z,o=void 0===i?[]:i,s=e.length,u=n.length+r.length+o.length;if(u!==s)return"";if(n.length===s){var c=getCoordsDataType(s);return"fn getOutputCoords() -> ".concat(c,"{\n    let globalIndex = getGlobalIndex();\n    return getCoordsFromIndex(globalIndex);\n  }\n  ")}for(var d="",p=[n,r,o],l=0;l<p.length;l++){var h=p[l];if(0!==h.length){if(1===h.length)d+="let d".concat(h[0]," = i32(globalId[").concat(l,"]);");else{var f=/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e,t){if(Math.max.apply(Math,__spreadArray([],__read(e),!1))>5)throw Error("Cannot symbolically compute strides for rank > 6 tensor.");var n=e.length,a=e.map(function(e){return"".concat(t,".").concat("xyzwuv"[e])}),r=Array(n-1);r[n-2]=a[n-1];for(var i=n-3;i>=0;--i)r[i]="(".concat(r[i+1]," * ").concat(a[i+1],")");return r}(h,"uniforms.outShape");d+="var index".concat(l," = i32(globalId[").concat(l,"]);");for(var m=0;m<f.length;m++)d+="let d".concat(h[m]," = index").concat(l," / ").concat(f[m],";"),m===f.length-1?d+="let d".concat(h[m+1]," = ")+"index".concat(l," - d").concat(h[m]," * ").concat(f[m],";"):d+="index".concat(l," = index").concat(l," - d").concat(h[m]," * ").concat(f[m],";")}}}for(var g=[],l=0;l<u;l++)g.push("d".concat(l));var y=getCoordsDataType(u),v="fn getOutputCoords() -> ".concat(y," {\n  ").concat(d,"\n");return 0===g.length?v+="return ".concat(y,"(0); }"):v+="return ".concat(y,"(").concat(g.join(","),"); }"),v}(t.shape,n.dispatchLayout),m=[y,o.join("\n")+v,getCoordsFromIndexSnippet(t.shape),f,function(e){var t="";switch(e){case 0:case 1:t+="\n        fn getOutputIndexFromCoords(coords : i32) -> i32 {\n          return coords;\n        }\n        ";break;case 2:t+="\n        fn getOutputIndexFromCoords(coords : vec2<i32>) -> i32 {\n          return dot(coords, vec2<i32>(uniforms.outShapeStrides, 1));\n        }\n        ";break;case 3:t+="\n        fn getOutputIndexFromCoords(coords : vec3<i32>) -> i32 {\n          return dot(coords, vec3<i32>(uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, 1));\n        }\n        ";break;case 4:t+="\n        fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\n          return dot(coords, vec4<i32>(\n            uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, uniforms.outShapeStrides.z, 1));\n        }\n        ";break;case 5:t+="\n        fn getOutputIndexFromCoords(coords : vec5) -> i32 {\n          return coords.x * uniforms.outShapeStrides.x +\n              coords.y * uniforms.outShapeStrides.y +\n              coords.z * uniforms.outShapeStrides.z +\n              coords.w * uniforms.outShapeStrides.w +\n              coords.u;\n        }\n        ";break;case 6:t+="\n        fn getOutputIndexFromCoords(coords : vec6) -> i32 {\n          return coords.x * uniforms.outShapeStrides.x +\n              coords.y * uniforms.outShapeStrides.y +\n              coords.z * uniforms.outShapeStrides.z +\n              coords.w * uniforms.outShapeStrides.w +\n              coords.u * uniforms.outShapeStrides.u +\n              coords.v;\n        }\n        ";break;default:p.util.assert(!1,function(){return"Unsupported ".concat(e,"D shape")})}return t}(t.shape.length)];n.atomic||m.push(function(e,t,n){var a=e.length,r=dataTypeToGPUType(t,n),i="fn setOutputAtIndex(flatIndex : i32, value : ".concat(typeSnippet(n),") {\n      result[flatIndex] = ").concat(r,"(value);\n    }\n\n    fn setOutputAtIndexI32(flatIndex : i32, value : ").concat(typeSnippet(n,"i32"),") {\n      result[flatIndex] = ").concat(r,"(value);\n    }\n    ");if(a>=2){var o=["d0","d1","d2","d3","d4","d5"].slice(0,a),s=getCoordsDataType(a);i+="\n      fn setOutputAtCoords(".concat(o.map(function(e){return"".concat(e," : i32")}).join(", "),", value : ").concat(typeSnippet(n),") {\n        let flatIndex = getOutputIndexFromCoords(").concat(s,"(").concat(o.join(", "),"));\n        setOutputAtIndex(flatIndex").concat(1===n?"":" / ".concat(n),", value);\n      }\n      fn setOutputAtCoordsI32(").concat(o.map(function(e){return"".concat(e," : i32")}).join(", "),", value : ").concat(typeSnippet(n,"i32"),") {\n        let flatIndex = getOutputIndexFromCoords(").concat(s,"(").concat(o.join(", "),"));\n        setOutputAtIndexI32(flatIndex").concat(1===n?"":" / ".concat(n),", value);\n      }\n    ")}return i}(t.shape,t.dtype,n.outputComponent)),n.variableNames.forEach(function(t,n){m.push("".concat(getCoordsFromIndexSnippet(e[n].shape,t)))});var g=e.map(function(e,a){var r,i,o,s;return r=t.shape,i=n.variableComponents?n.variableComponents[a]:n.outputComponent,o=n.dispatchLayout.x.length===t.shape.length,s=function(e,t){var n=e.name,a=e.shape.length,r=getCoordsDataType(a),i="get"+n.charAt(0).toUpperCase()+n.slice(1),o=["d0","d1","d2","d3","d4","d5"].slice(0,a),s=o.map(function(e){return"".concat(e," : i32")}).join(", ");if(a<1)return"\n      fn ".concat(i,"() -> ").concat(typeSnippet(t)," {\n        return ").concat(typeSnippet(t),"(").concat(n,"[0]);\n      }\n    ");var u="uniforms.".concat(n.charAt(0).toLowerCase()+n.slice(1),"Shape"),c="".concat(a,"D");return 0===a&&(c="1D"),"\n    fn ".concat(i,"(").concat(s,") -> ").concat(typeSnippet(t)," {\n      return ").concat(typeSnippet(t),"(").concat(n,"[getIndexFromCoords").concat(c,"(").concat(r,"(").concat(o.join(","),"),\n        ").concat(u,")").concat(1===t?"":" / ".concat(t),"]);\n    }\n   ")}(e,i),e.shape.length<=r.length&&(s+=function(e,t,n,a){var r=e.name,i=r.charAt(0).toUpperCase()+r.slice(1),o="get"+i+"ByOutput",s=e.shape.length,u=t.length,c=getCoordsDataType(u);if(p.util.arraysEqual(e.shape,t)&&a)return"\n    fn ".concat(o,"Index(globalIndex : i32) -> ").concat(typeSnippet(n)," {\n      return ").concat(typeSnippet(n),"(").concat(r,"[globalIndex]);\n    }\n\n    fn ").concat(o,"Coords(coords : ").concat(c,") -> ").concat(typeSnippet(n)," {\n      return ").concat(typeSnippet(n),"(").concat(r,"[").concat(u>1?"getOutputIndexFromCoords(coords)":"coords").concat(1===n?"":" / ".concat(n),"]);\n    }\n    ");var d=p.backend_util.getBroadcastDims(e.shape,t),l=u-s,h="";if(0===s)return"\n    fn ".concat(o,"Index(globalIndex : i32) -> ").concat(typeSnippet(n),"{\n      return get").concat(i,"();\n    }\n\n    fn ").concat(o,"Coords(coords : ").concat(c,") -> ").concat(typeSnippet(n),"{\n      return get").concat(i,"();\n    }\n  ");h=u<2&&d.length>=1?"coords = 0;":d.map(function(e){return"coords.".concat(getCoordsXYZ(e+l)," = 0;")}).join("\n");var f="";if(u<2&&s>0)f="coords";else if(u>1){var m=getCoordsDataType(s),g=e.shape.map(function(e,t){return"coords.".concat(getCoordsXYZ(t+l))}).join(", ");f="".concat(m,"(").concat(g,")")}else f="coords";var y="uniforms.".concat(r.charAt(0).toLowerCase()+r.slice(1),"Shape"),v="".concat(s,"D");return"\n  fn ".concat(o,"Index(globalIndex : i32) -> ").concat(typeSnippet(n)," {\n    var coords = getCoordsFromIndex(globalIndex);\n    ").concat(h,"\n    return ").concat(typeSnippet(n),"(").concat(r,"[getIndexFromCoords").concat(v,"(").concat(f,", ").concat(y,")").concat(1===n?"":" / ".concat(n),"]);\n  }\n\n  fn ").concat(o,"Coords(coordsIn : ").concat(c,") -> ").concat(typeSnippet(n)," {\n    var coords = coordsIn;\n    ").concat(h,"\n    return ").concat(typeSnippet(n),"(").concat(r,"[getIndexFromCoords").concat(v,"(").concat(f,", ").concat(y,")").concat(1===n?"":" / ".concat(n),"]);\n  }\n")}(e,r,i,o)),s}).join("\n");m.push(g),m.push(n.getUserCode());var x=isFlatDispatchLayout(n);return m.push(getStartHeaderString(x,n)),m.join("\n")}(n,{dtype:r.dtype,shape:r.shape},t),s=e.createShaderModule({code:o,label:t.constructor.name}),u=p.env().get("WEBGPU_PRINT_SHADER");if(""!==u){var c=(u=u.toLowerCase()).split(",");("all"===u||c.some(function(e){return t.shaderKey.toLowerCase().includes(e)}))&&(console.group(t.shaderKey),console.debug(o),console.groupEnd())}return i?e.createComputePipelineAsync({compute:{module:s,entryPoint:"_start"},label:t.constructor.name,layout:"auto"}):e.createComputePipeline({compute:{module:s,entryPoint:"_start"},label:t.constructor.name,layout:"auto"})},typeSnippet=function(e,t){switch(void 0===t&&(t="f32"),e){case 1:return"".concat(t);case 2:return"vec2<".concat(t,">");case 3:return"vec3<".concat(t,">");case 4:return"vec4<".concat(t,">");default:throw Error("".concat(e,"-component ").concat(t," is not supported."))}};function getCoordsDataType(e){if(e<=1)return"i32";if(2===e)return"vec2<i32>";if(3===e)return"vec3<i32>";if(4===e)return"vec4<i32>";if(5===e)return"vec5";if(6===e)return"vec6";throw Error("GPU for rank ".concat(e," is not yet supported"))}function getCoordsXYZ(e){if(0===e)return"x";if(1===e)return"y";if(2===e)return"z";if(3===e)return"w";if(4===e)return"u";if(5===e)return"v";throw Error("Index ".concat(e," is not yet supported"))}function getMainHeaderString(){for(var e,t=[],n=0;n<arguments.length;n++)t[n]=arguments[n];switch(t.length){case 0:e="\n        fn main()\n      ";break;case 1:e="\n        fn main(".concat(t[0]," : i32)\n      ");break;default:throw Error("Unreachable")}return e}function getStartHeaderString(e,t){return"\n     ".concat("\n  @compute @workgroup_size(".concat(t.workgroupSize[0],", ").concat(t.workgroupSize[1],", ").concat(t.workgroupSize[2],")\n"),"\n      fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,\n                @builtin(global_invocation_id) GlobalId : vec3<u32>,\n                @builtin(local_invocation_index) LocalIndex: u32,\n                @builtin(workgroup_id) WorkgroupId : vec3<u32>,\n                @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {\n        localId = LocalId;\n        localIndex = LocalIndex;\n        globalId = GlobalId;\n        numWorkgroups = NumWorkgroups;\n        workgroupId = WorkgroupId;\n        ").concat(e?"main(getGlobalIndex());":"main();",";\n      }\n    ")}var y="\n  struct vec5 {x: i32, y: i32, z: i32, w: i32, u: i32};\n  struct vec6 {x: i32, y: i32, z: i32, w: i32, u: i32, v: i32};\n\n  // Checks whether coordinates lie within the bounds of the shape.\n  fn coordsInBounds2D(coord : vec2<i32>, shape : vec2<i32>) -> bool {\n    return all(coord >= vec2<i32>(0)) && all(coord < shape);\n  }\n  fn coordsInBounds3D(coord : vec3<i32>, shape : vec3<i32>) -> bool {\n    return all(coord >= vec3<i32>(0)) && all(coord < shape);\n  }\n  fn coordsInBounds4D(coord : vec4<i32>, shape : vec4<i32>) -> bool {\n    return all(coord >= vec4<i32>(0)) && all(coord < shape);\n  }\n\n  fn getIndexFromCoords1D(coord : i32, shape : i32) -> i32 {\n    return coord;\n  }\n  fn getIndexFromCoords2D(coords : vec2<i32>, shape : vec2<i32>) -> i32 {\n    return dot(coords, vec2<i32>(shape.y, 1));\n  }\n  fn getIndexFromCoords3D(coords : vec3<i32>, shape : vec3<i32>) -> i32 {\n    return dot(coords, vec3<i32>(shape.y * shape.z, shape.z, 1));\n  }\n  fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\n    return dot(coords, vec4<i32>(\n        shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\n  }\n  fn getIndexFromCoords5D(coords : vec5, shape : vec5) -> i32 {\n    let shapeStrides: vec5 = vec5(shape.y * shape.z * shape.w * shape.u, shape.z * shape.w * shape.u, shape.w * shape.u, shape.u, 1);\n    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u;\n  }\n  fn getIndexFromCoords6D(coords : vec6, shape : vec6) -> i32 {\n    let shapeStrides: vec6 = vec6(shape.y * shape.z * shape.w * shape.u * shape.v, shape.z * shape.w * shape.u * shape.v, shape.w * shape.u * shape.v, shape.u * shape.v, shape.v, 1);\n    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u + coords.v*shapeStrides.v;\n  }\n\n  // NaN defination in IEEE 754-1985 is :\n  //   - sign = either 0 or 1.\n  //   - biased exponent = all 1 bits.\n  //   - fraction = anything except all 0 bits (since all 0 bits represents infinity).\n  // https://en.wikipedia.org/wiki/IEEE_754-1985#Representation_of_non-numbers\n  fn isnan(val: f32) -> bool {\n    let floatToUint: u32 = bitcast<u32>(val);\n    return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n  }\n  fn isnanVec4(val : vec4<f32>) -> vec4<bool> {\n    let floatToUint: vec4<u32> = bitcast<vec4<u32>>(val);\n    return (floatToUint & vec4<u32>(0x7fffffffu)) > vec4<u32>(0x7f800000u);\n  }\n",v="\n  fn isinf(val: f32) -> bool {\n    return abs(val) == uniforms.INFINITY;\n  }\n";function getCoordsFromIndexSnippet(e,t){void 0===t&&(t="");var n,a=e.length,r=""!==t?"get".concat(t.charAt(0).toUpperCase()+t.slice(1),"CoordsFromIndex"):"getCoordsFromIndex",i=""!==t?"".concat(t.charAt(0).toLowerCase()+t.slice(1),"ShapeStrides"):"outShapeStrides";if(a<=1)return"fn ".concat(r,"(index : i32) -> i32 { return index; }");for(var o=p.util.computeStrides(e),s=getCoordsDataType(a),u=[],c=0;c<a;c++)u.push("d".concat(c));return 1===o.length?"    fn ".concat(r,"(index : i32) -> vec2<i32> {\n      let d0 = index / uniforms.").concat(i,"; let d1 = index - d0 * uniforms.").concat(i,";\n      return vec2<i32>(d0, d1);\n    }"):(n="var index2 = index;"+o.map(function(e,t){var n="let ".concat(u[t]," = index2 / uniforms.").concat(i,".").concat(getCoordsXYZ(t)),a=t===o.length-1?"let ".concat(u[t+1]," = index2 - ").concat(u[t]," * uniforms.").concat(i,".").concat(getCoordsXYZ(t)):"index2 = index2 - ".concat(u[t]," * uniforms.").concat(i,".").concat(getCoordsXYZ(t));return"".concat(n,"; ").concat(a,";")}).join(""),"\n    fn ".concat(r,"(index : i32) -> ").concat(s," {\n      ").concat(n,"\n      return ").concat(s,"(").concat(u.join(","),");\n    }\n  "))}function isFlatDispatch(e){return 1===e.dispatch[1]&&1===e.dispatch[2]}function dataTypeToGPUType(e,t){if(void 0===t&&(t=1),"float32"===e)return typeSnippet(t,"f32");if("int32"===e||"bool"===e)return typeSnippet(t,"i32");throw Error("type ".concat(e," is not supported."))}function isFlatDispatchLayout(e){return!(e.dispatchLayout.hasOwnProperty("y")&&0!==e.dispatchLayout.y.length||e.dispatchLayout.hasOwnProperty("z")&&0!==e.dispatchLayout.z.length)}var arrayProduct=function(e){for(var t=1,n=0;n<e.length;n++)t*=e[n];return t};function computeDispatch(e,t,n,a){void 0===n&&(n=[1,1,1]),void 0===a&&(a=[1,1,1]);var r=__read([Math.ceil(arrayProduct(e.x.map(function(e){return t[e]}))/(n[0]*a[0])),e.y?Math.ceil(arrayProduct(e.y.map(function(e){return t[e]}))/(n[1]*a[1])):1,e.z?Math.ceil(arrayProduct(e.z.map(function(e){return t[e]}))/(n[2]*a[2])):1],3);return[r[0],r[1],r[2]]}function computeWorkgroupInfoForMatMul(e,t,n,a){void 0===a&&(a=!1);var r=[8,8,1],i=[4,4,1];return!a&&(e<=8&&(i[1]=1),t<=16&&n<=16&&(r[0]=4)),{workgroupSize:r,elementsPerThread:i}}function computeWorkgroupSizeForConv2d(e,t,n){if(void 0===n&&(n=!1),n)return[8,8,1];var a=arrayProduct(e.x.map(function(e){return t[e]})),r=arrayProduct(e.y.map(function(e){return t[e]}));return a<=4?[4,16,1]:r<=4?[16,4,1]:[16,16,1]}function computeWorkPerThreadForConv2d(e,t,n){if(void 0===n&&(n=!1),n)return[4,4,1];var a=arrayProduct(e.x.map(function(e){return t[e]})),r=arrayProduct(e.y.map(function(e){return t[e]}));return a<=4?[1,2,1]:r<=4?[2,1,1]:[2,2,1]}function flatDispatchLayout(e){return{x:e.map(function(e,t){return t})}}function GPUBytesPerElement(e){if("float32"===e||"int32"===e||"bool"===e||"string"===e)return 4;if("complex64"===e)return 8;throw Error("Unknown dtype ".concat(e))}function isWebGPUSupported(){return!!("undefined"!=typeof globalThis&&globalThis.navigator&&globalThis.navigator.gpu)}function assertNotComplex(e,t){Array.isArray(e)||(e=[e]),e.forEach(function(e){null!=e&&p.util.assert("complex64"!==e.dtype,function(){return"".concat(t," does not support complex64 tensors ")+"in the WebGPU backend."})})}!function(e){e[e.MatMulReduceProgram=0]="MatMulReduceProgram",e[e.MatMulSplitKProgram=1]="MatMulSplitKProgram",e[e.MatMulSmallOutputSizeProgram=2]="MatMulSmallOutputSizeProgram",e[e.MatMulPackedProgram=3]="MatMulPackedProgram",e[e.MatMulMax=4]="MatMulMax"}(r||(r={}));var x=p.env().getNumber("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD"),reshapeDispatch=function(e,t){var n=e.limits.maxComputeWorkgroupsPerDimension,a=t.dispatchLayout,r=t.dispatch;if(r.every(function(e){return e<=n}))return r;p.util.assert(r[0]>n&&void 0===a.y&&void 0===a.z,function(){return"Dispatch size exceeds WebGPU limits in Y or Z dimension."});var i=Math.ceil(Math.sqrt(r[0]));return i>n?(i=Math.ceil(Math.cbrt(r[0])),p.util.assert(i<=n,function(){return"Total dispatch size exceeds WebGPU maximum."}),[i,i,i]):[i,i,1]},b=function(e){function WebGPUBackend(t,n){var a=e.call(this)||this;if(a.commandQueueOwnedIds=new WeakSet,a.dispatchCountInPass=0,a.disposed=!1,a.downloadWaitMs=0,a.tensorDataPendingDisposal=[],a.queryResolveBuffer=null,a.querySet=null,a.querySetCount=2,a.stagingPendingDisposal=[],a.uniformPendingDisposal=[],a.uploadWaitMs=0,a.hasReadSyncWarned=!1,a.hasTimestampQueryWarned=!1,!isWebGPUSupported())throw Error("WebGPU is not supported on this device");return a.pipelineCache={},a.device=t,a.queue=t.queue,a.commandEncoder=null,a.computePassEncoder=null,a.adapterInfo=new f(n),a.supportTimestampQuery=a.device.features.has("timestamp-query"),a.thresholdToIncreaseWorkgroups=a.adapterInfo.intelGPUGeneration>=12?16:8,a.bufferManager=new m(a.device),a.textureManager=new g(a.device),a.tensorMap=new p.DataStorage(a,p.engine()),p.env().getBool("WEBGPU_USE_PROFILE_TOOL")&&(a.dummyCanvas=document.createElement("canvas"),a.dummyCanvas.width=1,a.dummyCanvas.height=1,a.dummyContext=a.dummyCanvas.getContext("webgpu"),a.dummyContext.configure({device:t,format:"bgra8unorm"}),document.body.appendChild(a.dummyCanvas)),a}return function(e,t){if("function"!=typeof t&&null!==t)throw TypeError("Class extends value "+String(t)+" is not a constructor or null");function __(){this.constructor=e}extendStatics(e,t),e.prototype=null===t?Object.create(t):(__.prototype=t.prototype,new __)}(WebGPUBackend,e),WebGPUBackend.prototype.nextDataId=function(){return WebGPUBackend.nextDataId++},WebGPUBackend.prototype.floatPrecision=function(){return 32},WebGPUBackend.prototype.disposeData=function(e,t){if(void 0===t&&(t=!1),!this.tensorMap.has(e))return!0;var n=this.tensorMap.get(e);return t?n.refCount=0:n.refCount--,!(n.refCount>0)&&((null!=n.complexTensorInfos&&(this.disposeData(n.complexTensorInfos.real.dataId),this.disposeData(n.complexTensorInfos.imag.dataId)),this.commandQueueOwnedIds.has(e))?this.tensorDataPendingDisposal.push(e):(this.releaseResource(e),this.tensorMap.delete(e)),!0)},WebGPUBackend.prototype.memory=function(){return{numBytesInGPU:this.bufferManager.numBytesUsed,numBytesAllocatedInGPU:this.bufferManager.numBytesAllocated,unreliable:!1}},WebGPUBackend.prototype.releaseResource=function(e){var t=this.tensorMap.get(e);if(t&&t.resource){if(t.external){t.resource=null;return}t.resource instanceof GPUBuffer?this.bufferManager.releaseBuffer(t.resource):t.resource instanceof GPUTexture&&this.textureManager.releaseTexture(t.resource),t.resource=null}},WebGPUBackend.prototype.refCount=function(e){return this.tensorMap.has(e)?this.tensorMap.get(e).refCount:0},WebGPUBackend.prototype.incRef=function(e){var t=this.tensorMap.get(e);t.refCount++},WebGPUBackend.prototype.decRef=function(e){if(this.tensorMap.has(e)){var t=this.tensorMap.get(e);t.refCount--}},WebGPUBackend.prototype.write=function(e,t,n){if("complex64"===n&&null!=e)throw Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");var a={id:this.nextDataId()};return this.tensorMap.set(a,{dtype:n,shape:t,values:e,refCount:1}),a},WebGPUBackend.prototype.move=function(e,t,n,a,r){if("complex64"===a)throw Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.tensorMap.set(e,{dtype:a,shape:n,values:t,refCount:r})},WebGPUBackend.prototype.submitQueue=function(){var e=this;this.queue.submit([this.commandEncoder.finish()]),this.commandEncoder=null,this.dispatchCountInPass=0,this.commandQueueOwnedIds=new WeakSet,this.tensorDataPendingDisposal.forEach(function(t){e.releaseResource(t),e.tensorMap.delete(t)}),this.uniformPendingDisposal.forEach(function(t){return e.bufferManager.releaseBuffer(t)}),this.stagingPendingDisposal.forEach(function(t){return e.bufferManager.releaseBuffer(t,!1)}),this.tensorDataPendingDisposal=[],this.uniformPendingDisposal=[],this.stagingPendingDisposal=[]},WebGPUBackend.prototype.ensureCommandEncoderReady=function(){this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder())},WebGPUBackend.prototype.endComputePassEncoder=function(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)},WebGPUBackend.prototype.checkCompileCompletionAsync=function(){return __awaiter(this,void 0,void 0,function(){var e,t=this;return __generator(this,function(n){switch(n.label){case 0:return n.trys.push([0,2,,3]),[4,Promise.all(Object.values(this.pipelineCache))];case 1:return e=n.sent(),[3,3];case 2:throw Error(n.sent().message);case 3:return Object.keys(this.pipelineCache).map(function(n,a){t.pipelineCache[n]=e[a]}),[2]}})})},WebGPUBackend.prototype.getBufferData=function(e){return __awaiter(this,void 0,void 0,function(){var t,n,a;return __generator(this,function(r){switch(r.label){case 0:if(p.env().getBool("WEBGPU_ENGINE_COMPILE_ONLY"))return console.warn("The data may be invalid since WEBGPU_ENGINE_COMPILE_ONLY is true, this can only be called when WEBGPU_ENGINE_COMPILE_ONLY is false"),[2,null];return t=e.size,n=this.bufferManager.acquireBuffer(t,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ),this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(e,0,n,0,t),this.submitQueue(),[4,n.mapAsync(GPUMapMode.READ)];case 1:return r.sent(),a=n.getMappedRange().slice(0),n.unmap(),null!=n&&this.bufferManager.releaseBuffer(n),p.env().getBool("WEBGPU_USE_PROFILE_TOOL")&&(p.util.assert(void 0!==this.dummyContext,function(){return"Fail to get context for profiling tool"}),this.dummyContext.getCurrentTexture()),[2,a]}})})},WebGPUBackend.prototype.convertAndCacheOnCPU=function(e,t){var n=this.tensorMap.get(e);return n.values=t,n.values},WebGPUBackend.prototype.readSync=function(e){var t=this,n=this.tensorMap.get(e),a=n.values,r=n.complexTensorInfos;if(null!=a||"string"===n.dtype)return a;if("complex64"===n.dtype){var i=this.readSync(r.real.dataId),o=this.readSync(r.imag.dataId),s=p.util.convertBackendValuesAndArrayBuffer(p.backend_util.mergeRealAndImagArrays(i,o).buffer,"float32");return this.convertAndCacheOnCPU(e,s),s}this.hasReadSyncWarned||(this.hasReadSyncWarned=!0,console.warn("The performance of synchronously reading data from GPU to CPU is poor on the webgpu backend, please use asynchronous APIs instead."));var u=["opaque","premultiplied"],c=n.resource,d=c.size;p.util.assert(d%4==0,function(){return"Because there is 4 bytes for one pixel, buffer size must be multiple of 4."});var l=d/4,h=new ArrayBuffer(d),f=u.map(function(e){return new OffscreenCanvas(256,256)}),m=new OffscreenCanvas(256,256);this.endComputePassEncoder(),f.map(function(e,n){var a=e.getContext("webgpu");return a.configure({device:t.device,format:"bgra8unorm",usage:GPUTextureUsage.COPY_DST,alphaMode:u[n]}),a.getCurrentTexture()}).map(function(e,n){for(var readDataGPUToCPU=function(a,r,i){t.ensureCommandEncoderReady(),t.commandEncoder.copyBufferToTexture({buffer:c,bytesPerRow:1024,offset:i},{texture:e},{width:a,height:r}),t.submitQueue();var o=m.getContext("2d",{willReadFrequently:!0});o.clearRect(0,0,a,r),o.drawImage(f[n],0,0);for(var s=o.getImageData(0,0,a,r).data,d=u[n],p=new Uint8ClampedArray(h,i,a*r*4),l=0;l<p.length;l+=4)if("premultiplied"===d)p[l+3]=s[l+3];else{var g=s[l];p[l]=s[l+2],p[l+1]=s[l+1],p[l+2]=g}},a=Math.floor(l/65536),r=256,i=256,o=0,s=0;s<a;s++)readDataGPUToCPU(r,i,o),o+=262144;var d=l%65536;(i=Math.floor(d/256))>0&&(readDataGPUToCPU(r,i,o),o+=1024*i),(r=d%256)>0&&readDataGPUToCPU(r,1,o)});var g=p.util.convertBackendValuesAndArrayBuffer(h,n.dtype);return this.convertAndCacheOnCPU(e,g),g},WebGPUBackend.prototype.read=function(e){return __awaiter(this,void 0,void 0,function(){var t,n,a,r,i,o,s;return __generator(this,function(u){switch(u.label){case 0:if(!this.tensorMap.has(e))throw Error("Tensor ".concat(e," was not registered!"));if(null!=(n=(t=this.tensorMap.get(e)).values))return[2,n];if("complex64"!==t.dtype)return[3,2];return[4,Promise.all([this.read(t.complexTensorInfos.real.dataId),this.read(t.complexTensorInfos.imag.dataId)])];case 1:return i=(r=u.sent())[0],o=r[1],a=p.backend_util.mergeRealAndImagArrays(i,o),[3,4];case 2:return[4,this.getBufferData(t.resource)];case 3:s=u.sent(),a=p.util.convertBackendValuesAndArrayBuffer(s,t.dtype),u.label=4;case 4:return this.convertAndCacheOnCPU(e,a),[2,a]}})})},WebGPUBackend.prototype.copyBuffer=function(e){var t=e.size,n=e.usage,a=this.bufferManager.acquireBuffer(t,n);return this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(e,0,a,0,t),this.submitQueue(),a},WebGPUBackend.prototype.createTensorFromGPUData=function(e,t,n){var a=e.buffer;if("complex64"===n)throw Error("Cannot write to a complex64 dtype. ");var r={id:this.nextDataId()};this.tensorMap.set(r,{dtype:n,shape:t,values:null,refCount:1,external:e.zeroCopy});var i=this.tensorMap.get(r),o=GPUBytesPerElement(i.dtype)*p.util.sizeFromShape(i.shape);if(e.buffer.size<o)throw Error("GPUBuffer size(".concat(e.buffer.size,") is smaller than tensor size(").concat(o,")!"));if((e.buffer.usage&(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))!=(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))throw Error("GPUBuffer.usage should include GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC!");return!0!==e.zeroCopy&&(a=this.copyBuffer(a)),i.resource=a,p.engine().makeTensorFromDataId(r,t,n,this)},WebGPUBackend.prototype.readToGPU=function(e){var t=this.tensorMap.get(e),n=t.values,a=t.dtype,r=t.shape,i=t.resource;if("complex64"===a)throw Error("Does not support reading buffer for complex64 dtype.");if(null==i){if(null!=n)throw Error("Data is not on GPU but on CPU.");throw Error("There is no data on GPU or CPU.")}var o=i.size,s=i.usage,u=this.bufferManager.acquireBuffer(o,s);this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(i,0,u,0,o),this.submitQueue();var c=this.makeTensorInfo(r,a),d=p.engine().makeTensorFromTensorInfo(c);return this.tensorMap.get(c.dataId).resource=u,{tensorRef:d,buffer:u}},WebGPUBackend.prototype.bufferSync=function(e){var t=this.readSync(e.dataId);if("string"===e.dtype)try{var n=t.map(function(e){return p.util.decodeString(e)});return p.buffer(e.shape,e.dtype,n)}catch(e){throw Error("Failed to decode encoded string bytes into utf-8")}return p.buffer(e.shape,e.dtype,t)},WebGPUBackend.prototype.time=function(e){return __awaiter(this,void 0,void 0,function(){var t,n,a,r,i,o,s;return __generator(this,function(u){switch(u.label){case 0:return this.supportTimestampQuery||this.hasTimestampQueryWarned||(console.warn("This device doesn't support timestamp-query extension. Start Chrome browser with flag --enable-dawn-features=allow_unsafe_apis to try it again. Otherwise, zero will be shown for the kernel time when profiling mode is enabled."),this.hasTimestampQueryWarned=!0),t=this.activeTimers,n=[],a=!1,null==this.programTimersStack?(this.programTimersStack=n,a=!0):this.activeTimers.push(n),this.activeTimers=n,e(),r=p.util.flatten(this.activeTimers.map(function(e){return e.query})).filter(function(e){return null!=e}),i=p.util.flatten(this.activeTimers.map(function(e){return e.name})).filter(function(e){return null!=e}),this.activeTimers=t,a&&(this.programTimersStack=null),o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null},[4,Promise.all(r)];case 1:return s=u.sent(),o.kernelMs=p.util.sum(s),o.getExtraProfileInfo=function(){return s.map(function(e,t){return{name:i[t],ms:e}}).map(function(e){return"".concat(e.name,": ").concat(e.ms)}).join(", ")},this.uploadWaitMs=0,this.downloadWaitMs=0,[2,o]}})})},WebGPUBackend.prototype.makeTensorInfo=function(e,t,n){return"string"===t&&null!=n&&n.length>0&&p.util.isString(n[0])&&(n=n.map(function(e){return p.util.encodeString(e)})),{dataId:this.write(n,e,t),shape:e,dtype:t}},WebGPUBackend.prototype.tensorToBinding=function(e){if(!e)return null;var t=this.tensorMap.get(e.dataId).resource;return t instanceof GPUBuffer?{buffer:t}:t instanceof GPUTexture?t.createView():t},WebGPUBackend.prototype.uploadToGPU=function(e){var t,n=this.tensorMap.get(e);if(null==n.resource){var a=GPUBytesPerElement(n.dtype)*p.util.sizeFromShape(n.shape),r=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST;if(n.values){if("unmapped"===(t=this.bufferManager.acquireBuffer(a,r,!0)).mapState){var i=this.bufferManager.acquireBuffer(a,GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC,!0,!1),o=i.getMappedRange();"int32"===n.dtype||"bool"===n.dtype?new Int32Array(o).set(n.values):new Float32Array(o).set(n.values),i.unmap(),this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(i,0,t,0,a),this.stagingPendingDisposal.push(i)}else{var o=t.getMappedRange();"int32"===n.dtype||"bool"===n.dtype?new Int32Array(o).set(n.values):new Float32Array(o).set(n.values),t.unmap()}n.values=null}else t=this.bufferManager.acquireBuffer(a,r);n.resource=t}},WebGPUBackend.prototype.makeUniforms=function(e){var t=0,n=0,a=[],r=1;e.forEach(function(e){var i;switch(0===e.data.length&&(e.data=[1]),e.data.length){case 1:i=4;break;case 2:i=8;break;case 3:case 4:case 5:case 6:i=16;break;default:p.util.assert(!1,function(){return"Unsupported ".concat(e.data.length,"D shape")})}(5===n||6===n)&&(i=16),i>r&&(r=i),t=Math.ceil(t/i)*i,n=e.data.length,a.push(t),t+=4*e.data.length}),t=Math.ceil(t/r)*r;var i=new ArrayBuffer(t);e.forEach(function(e,t){var n=a[t];"int32"===e.type?new Int32Array(i,n,e.data.length).set(e.data):"uint32"===e.type?new Uint32Array(i,n,e.data.length).set(e.data):new Float32Array(i,n,e.data.length).set(e.data)});var o=this.bufferManager.acquireBuffer(t,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);return this.queue.writeBuffer(o,0,i,0,t),this.uniformPendingDisposal.push(o),{offset:0,size:t,buffer:o}},WebGPUBackend.prototype.runWebGPUProgram=function(e,t,n,a,r){var i=this;if(r||(r=this.makeTensorInfo(e.outputShape,n)),0===p.util.sizeFromShape(r.shape))return this.tensorMap.get(r.dataId).values=p.util.getTypedArrayFromDType(r.dtype,0),r;this.uploadToGPU(r.dataId),e.dispatch=reshapeDispatch(this.device,e);var o=t.map(function(t,n){if("complex64"===t.dtype)throw Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");return i.uploadToGPU(t.dataId),{dtype:i.tensorMap.get(t.dataId).dtype,shape:t.shape,name:e.variableNames[n]}});e.shaderKey=function(e,t,n){var a=e.shaderKey;if(null!=e.pixelsOpType)return a;var r=[],i=[];t.forEach(function(e){r.push(e.shape),i.push(e.dtype)}),r.push(n.shape),i.push(n.dtype);var o=t.map(function(e){return p.backend_util.getBroadcastDims(e.shape,n.shape)}),s=t.map(function(e){return p.util.arraysEqual(e.shape,n.shape)}).join("_"),u=o.map(function(e){return e.join("_")}).join(";"),c=isFlatDispatch(e)?"flatDispatch":"";return a+("_"+(e.workgroupSize?e.workgroupSize.join(","):"")+r.map(function(e){return e.length}).join(",")+i.join(",")+e.variableNames.join(",")+u+s)+c}(e,o,r);var s=p.env().getBool("WEBGPU_ENGINE_COMPILE_ONLY");return e.shaderKey in this.pipelineCache||(this.pipelineCache[e.shaderKey]=compileProgram(this.device,e,o,r,s)),e.pipeline=this.pipelineCache[e.shaderKey],s||this.recordAndSubmit(e,r,t,a),r},WebGPUBackend.prototype.recordAndSubmit=function(e,t,n,r){var i=this;if(e.pipeline instanceof Promise)throw Error("Please call checkCompileCompletionAsync to ensure parallel compilation is done!");var o=[],s=[],u="int32";if(null==e.pixelsOpType){o.push({type:"float32",data:[NaN]},{type:"float32",data:[1/0]});var c="int32";n.concat(t).map(function(e){return e.shape}).map(function(e){o.push({type:c,data:e});var t=p.util.computeStrides(e);o.push({type:c,data:t})})}else{var d=p.util.computeStrides(t.shape);o.push({type:u,data:d})}if(e.size){var l=p.util.sizeFromShape(e.outputShape);o.push({type:u,data:[e.outputComponent?l/e.outputComponent:l]})}r&&(o=__spreadArray(__spreadArray([],__read(o),!1),__read(r),!1));var h=__spreadArray(__spreadArray([this.tensorToBinding(t)],__read(n.map(function(e){return i.tensorToBinding(e)})),!1),[this.makeUniforms(o)],!1);n.forEach(function(e){i.commandQueueOwnedIds.add(e.dataId)}),this.commandQueueOwnedIds.add(t.dataId);var f=this.device.createBindGroup({layout:e.pipeline.getBindGroupLayout(0),entries:h.map(function(e,t){return{binding:t,resource:e}})}),m=null!=this.activeTimers;this.ensureCommandEncoderReady();var g={};m&&this.supportTimestampQuery?(this.endComputePassEncoder(),null==this.querySet&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.querySetCount})),g.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:0,endOfPassWriteIndex:1},this.computePassEncoder=this.commandEncoder.beginComputePass(g)):this.computePassEncoder||(this.computePassEncoder=this.commandEncoder.beginComputePass(g)),this.computePassEncoder.setPipeline(e.pipeline),this.computePassEncoder.setBindGroup(0,f),this.computePassEncoder.dispatchWorkgroups(e.dispatch[0],e.dispatch[1],e.dispatch[2]),this.dispatchCountInPass++,(m||p.env().get("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE")<=this.dispatchCountInPass||e.pixelsOpType===a.DRAW)&&(this.endComputePassEncoder(),m?this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime()}):this.submitQueue())},WebGPUBackend.prototype.getQueryTime=function(){return __awaiter(this,void 0,void 0,function(){var e,t,n;return __generator(this,function(a){switch(a.label){case 0:if(!this.supportTimestampQuery)return[2,0];return null==this.queryResolveBuffer&&(this.queryResolveBuffer=this.bufferManager.acquireBuffer(8*this.querySetCount,GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST|GPUBufferUsage.QUERY_RESOLVE)),this.commandEncoder.resolveQuerySet(this.querySet,0,this.querySetCount,this.queryResolveBuffer,0),e=this.bufferManager.acquireBuffer(8*this.querySetCount,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST),this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,e,0,8*this.querySetCount),this.submitQueue(),[4,e.mapAsync(GPUMapMode.READ)];case 1:return a.sent(),n=Number((t=new BigUint64Array(e.getMappedRange()))[1]-t[0])/1e6,e.unmap(),this.bufferManager.releaseBuffer(e),[2,n]}})})},WebGPUBackend.prototype.shouldExecuteOnCPU=function(e,t){var n=this;return void 0===t&&(t=x),p.env().getBool("WEBGPU_CPU_FORWARD")&&e.every(function(e){return null==n.tensorMap.get(e.dataId).resource&&p.util.sizeFromShape(e.shape)<t})},WebGPUBackend.prototype.numDataIds=function(){return this.tensorMap.numDataIds()-this.tensorDataPendingDisposal.length},WebGPUBackend.prototype.dispose=function(){this.disposed||(null!=this.querySet&&this.querySet.destroy(),this.bufferManager.dispose(),this.textureManager.dispose(),this.disposed=!0)},WebGPUBackend}(p.KernelBackend);function getBinaryOpString(e,t){var n;do{switch(e){case i.ATAN2:n="let resultTemp = atan2(a, b);";break;case i.MAX:n="let resultTemp = max(a, b);";break;case i.MIN:n="let resultTemp = min(a, b);";break;case i.MOD:n=t?"\n  let isNaN = !vec4<bool>(b);\n  var resultTemp = vec4<f32>(a % b);\n  if (!((a[0] < 0. && b[0] < 0.) || (a[0] >= 0. && b[0] > 0.))) {\n    resultTemp[0] = (resultTemp[0] + b[0]) % b[0];\n  }\n  if (!((a[1] < 0. && b[1] < 0.) || (a[1] >= 0. && b[1] > 0.))) {\n    resultTemp[1] = (resultTemp[1] + b[1]) % b[1];\n  }\n  if (!((a[2] < 0. && b[2] < 0.) || (a[2] >= 0. && b[2] > 0.))) {\n    resultTemp[2] = (resultTemp[2] + b[2]) % b[2];\n  }\n  if (!((a[3] < 0. && b[3] < 0.) || (a[3] >= 0. && b[3] > 0.))) {\n    resultTemp[3] = (resultTemp[3] + b[3]) % b[3];\n  }\n":"\n  let isNaN = b == 0.;\n  var resultTemp = a % b;\n  resultTemp = select((resultTemp + b) % b, resultTemp,\n      (a < 0. && b < 0.) || (a >= 0. && b > 0.));\n";break;case i.NOT_EQUAL:n=t?"\n  var resultTemp = vec4<f32>(a != b);\n  let valueForNaN = 1.0;\n":"\n  var resultTemp = f32(a != b);\n  let valueForNaN = 1.0;\n";break;case i.POW:n=t?"\n  let isModRound1Bool = vec4<i32>(round(abs(b) % vec4<f32>(2.0))) == vec4<i32>(1);\n  let isModRound1 = vec4<f32>(isModRound1Bool);\n  let multiplier = sign(a) * isModRound1 + (vec4<f32>(1.0) - isModRound1);\n  var resultTemp = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  let isExpZero = b == vec4<f32>(0.0);\n  if (isExpZero.r) {\n    resultTemp.r = 1.0;\n  }\n  if (isExpZero.g) {\n    resultTemp.g = 1.0;\n  }\n  if (isExpZero.b) {\n    resultTemp.b = 1.0;\n  }\n  if (isExpZero.a) {\n    resultTemp.a = 1.0;\n  }\n  let isNaN = (a < vec4<f32>(0.0)) & (floor(b) < b);\n":"\n  let isNaN = a < 0.0 && floor(b) < b;\n  if (b == 0.0) {\n    return 1.0;\n  }\n  var resultTemp = select(sign(a) * pow(abs(a), b), pow(abs(a), b),\n      round(abs(b) % 2.0) != 1.0);\n";break;default:continue}var a=void 0,r=void 0,o=void 0;return t?(a="isnanVec4",r="vec4<f32>",o="vec4<bool>"):(a="isnan",r="f32",o="bool"),"\n      let aIsNaN = ".concat(a,"(a);\n      let aPostLegalization = select(a, ").concat(r,"(42), aIsNaN);\n      let bIsNaN = ").concat(a,"(b);\n      let bPostLegalization = select(b, ").concat(r,"(42), bIsNaN);\n      let isNaN = false;\n      let valueForNaN = uniforms.NAN;\n      {\n        let a = aPostLegalization;\n        let b = bPostLegalization;\n        ").concat(n,"\n        return select(\n            resultTemp, ").concat(r,"(valueForNaN),\n            ").concat(o,"(isNaN) | aIsNaN | bIsNaN);\n      }\n    ")}while(!1);switch(e){case i.ADD:n="let resultTemp = a + b;";break;case i.COMPLEX_MULTIPLY_IMAG:n="let resultTemp = areal * bimag + aimag * breal;";break;case i.COMPLEX_MULTIPLY_REAL:n="let resultTemp = areal * breal - aimag * bimag;";break;case i.DIV:n="let resultTemp = a / b;";break;case i.ELU_DER:n="let resultTemp = select(a * (b + 1.0), a, b >= b - b);";break;case i.EQUAL:n="\n  let zero = sign(a) * 0 + 0;\n  let one = sign(b) * 0 + 1;\n  let resultTemp = select(zero, one, a == b);\n";break;case i.FLOOR_DIV:n="\n  let remainder =\n      select(a % b, round(a % b), (round(a) == a) & (round(b) == b));\n  let quotient = (a - remainder) / b;\n  let resultTemp =\n      round(select(quotient, quotient - 1, sign(remainder) == -sign(b)));\n";break;case i.GREATER:n="\n  let zero = sign(a) * 0 + 0;\n  let one = sign(b) * 0 + 1;\n  let resultTemp = select(zero, one, a > b);\n";break;case i.GREATER_EQUAL:n="\n  let zero = sign(a) * 0 + 0;\n  let one = sign(b) * 0 + 1;\n  let resultTemp = select(zero, one, a >= b);\n";break;case i.LESS:n="\n  let zero = sign(a) * 0 + 0;\n  let one = sign(b) * 0 + 1;\n  let resultTemp = select(zero, one, a < b);\n";break;case i.LESS_EQUAL:n="\n  let zero = sign(a) * 0 + 0;\n  let one = sign(b) * 0 + 1;\n  let resultTemp = select(zero, one, a <= b);\n";break;case i.LOGICAL_AND:return t?"return (vec4<f32>(a >= vec4<f32>(1.0)) *\n  vec4<f32>(b >= vec4<f32>(1.0)));":"return f32(a >= 1.0 && b >= 1.0);";case i.LOGICAL_OR:return t?"return min(vec4<f32>(a >= vec4<f32>(1.0)) +\n  vec4<f32>(b >= vec4<f32>(1.0)), vec4<f32>(1.0));":"return f32(a >= 1.0 || b >= 1.0);";case i.MUL:n="let resultTemp = a * b;";break;case i.PRELU:return t?"\n  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));\n  return (aLessThanZero * (b * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);\n":"if (a < 0.0) { return b * a; }  return a;";case i.SQUARED_DIFFERENCE:n="let resultTemp = (a - b) * (a - b);";break;case i.SUB:n="let resultTemp = a - b;"}return"\n    ".concat(n,"\n    return resultTemp;\n  ")}b.nextDataId=0,isWebGPUSupported()&&p.registerBackend("webgpu",function(){return __awaiter(void 0,void 0,void 0,function(){var e,t,n,a,r,i,o;return __generator(this,function(s){switch(s.label){case 0:return e={powerPreference:p.env().get("WEBGPU_USE_LOW_POWER_GPU")?"low-power":"high-performance"},[4,navigator.gpu.requestAdapter(e)];case 1:return t=s.sent(),n={},a=[],t.features.has("timestamp-query")&&a.push("timestamp-query"),t.features.has("bgra8unorm-storage")&&a.push(["bgra8unorm-storage"]),n.requiredFeatures=a,r=t.limits,n.requiredLimits={maxComputeWorkgroupStorageSize:r.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:r.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:r.maxStorageBufferBindingSize,maxBufferSize:r.maxBufferSize,maxComputeWorkgroupSizeX:r.maxComputeWorkgroupSizeX,maxComputeInvocationsPerWorkgroup:r.maxComputeInvocationsPerWorkgroup},[4,t.requestDevice(n)];case 2:return i=s.sent(),[4,t.requestAdapterInfo()];case 3:return o=s.sent(),[2,new b(i,o)]}})})},3),function(e){e[e.ADD=0]="ADD",e[e.ATAN2=1]="ATAN2",e[e.COMPLEX_MULTIPLY_IMAG=2]="COMPLEX_MULTIPLY_IMAG",e[e.COMPLEX_MULTIPLY_REAL=3]="COMPLEX_MULTIPLY_REAL",e[e.DIV=4]="DIV",e[e.ELU_DER=5]="ELU_DER",e[e.EQUAL=6]="EQUAL",e[e.FLOOR_DIV=7]="FLOOR_DIV",e[e.GREATER=8]="GREATER",e[e.GREATER_EQUAL=9]="GREATER_EQUAL",e[e.LESS=10]="LESS",e[e.LESS_EQUAL=11]="LESS_EQUAL",e[e.LOGICAL_AND=12]="LOGICAL_AND",e[e.LOGICAL_OR=13]="LOGICAL_OR",e[e.MAX=14]="MAX",e[e.MIN=15]="MIN",e[e.MOD=16]="MOD",e[e.MUL=17]="MUL",e[e.NOT_EQUAL=18]="NOT_EQUAL",e[e.POW=19]="POW",e[e.PRELU=20]="PRELU",e[e.SQUARED_DIFFERENCE=21]="SQUARED_DIFFERENCE",e[e.SUB=22]="SUB"}(i||(i={})),function(e){e[e.ABS=0]="ABS",e[e.ACOS=1]="ACOS",e[e.ACOSH=2]="ACOSH",e[e.ASIN=3]="ASIN",e[e.ASINH=4]="ASINH",e[e.ATAN=5]="ATAN",e[e.ATANH=6]="ATANH",e[e.CEIL=7]="CEIL",e[e.COS=8]="COS",e[e.COSH=9]="COSH",e[e.ELU=10]="ELU",e[e.ERF=11]="ERF",e[e.EXP=12]="EXP",e[e.EXPM1=13]="EXPM1",e[e.FLOOR=14]="FLOOR",e[e.IS_FINITE=15]="IS_FINITE",e[e.IS_INF=16]="IS_INF",e[e.IS_NAN=17]="IS_NAN",e[e.LINEAR=18]="LINEAR",e[e.LOG=19]="LOG",e[e.LOG1P=20]="LOG1P",e[e.LOGICAL_NOT=21]="LOGICAL_NOT",e[e.NEG=22]="NEG",e[e.RELU=23]="RELU",e[e.RELU6=24]="RELU6",e[e.LEAKYRELU=25]="LEAKYRELU",e[e.RECIPROCAL=26]="RECIPROCAL",e[e.ROUND=27]="ROUND",e[e.RSQRT=28]="RSQRT",e[e.SELU=29]="SELU",e[e.SIGMOID=30]="SIGMOID",e[e.SIGN=31]="SIGN",e[e.SIN=32]="SIN",e[e.SINH=33]="SINH",e[e.SOFTPLUS=34]="SOFTPLUS",e[e.SQRT=35]="SQRT",e[e.SQUARE=36]="SQUARE",e[e.STEP=37]="STEP",e[e.TAN=38]="TAN",e[e.TANH=39]="TANH",e[e.TO_INT=40]="TO_INT"}(o||(o={}));var S='\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  let p = '.concat(p.backend_util.ERF_P,";\n  let a1 = ").concat(p.backend_util.ERF_A1,";\n  let a2 = ").concat(p.backend_util.ERF_A2,";\n  let a3 = ").concat(p.backend_util.ERF_A3,";\n  let a4 = ").concat(p.backend_util.ERF_A4,";\n  let a5 = ").concat(p.backend_util.ERF_A5,";\n\n  let sign = sign(a);\n  let absA = abs(a);\n  let t = 1.0 / (1.0 + p * absA);\n  return sign * (1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * exp(-absA * absA));\n"),w="\n  if (a >= 0.0) {\n    return ".concat(p.backend_util.SELU_SCALE," * a;\n  } else {\n    return ").concat(p.backend_util.SELU_SCALEALPHA," * (exp(a) - 1.0);\n  }\n");function getUnaryOpString(e,t){switch(e){case o.ABS:return"return abs(a);";case o.ACOS:return"\n  if (abs(a) > 1.) {\n    return uniforms.NAN;\n  }\n  return acos(a);\n";case o.ACOSH:return"\n  if (a < 1.) {\n    return uniforms.NAN;\n  }\n  return acosh(a);\n";case o.ASIN:return"\n  if (abs(a) > 1.) {\n    return uniforms.NAN;\n  }\n  return asin(a);\n";case o.ASINH:return"return asinh(a);";case o.ATAN:return"\n  if (isnan(a)) {\n    return uniforms.NAN;\n  }\n  return atan(a);\n";case o.ATANH:return"\n  if (abs(a) > 1.) {\n    return uniforms.NAN;\n  }\n  if (a == 1.) {\n    return uniforms.INFINITY;\n  }\n  if (a == -1.) {\n    return -uniforms.INFINITY;\n  }\n  return atanh(a);\n";case o.COS:return"return cos(a);";case o.COSH:return"\n  let e2x = exp(-a);\n  return (e2x + 1.0 / e2x) / 2.0;\n";case o.CEIL:return"return ceil(a);";case o.ELU:return t?"\n  var resFloat = exp(a) - vec4<f32>(1.0);\n  if (a.r >= 0.0) {\n    resFloat.r = a.r;\n  }\n  if (a.g >= 0.0) {\n    resFloat.g = a.g;\n  }\n  if (a.b >= 0.0) {\n    resFloat.b = a.b;\n  }\n  if (a.a >= 0.0) {\n    resFloat.a = a.a;\n  }\n  return resFloat;\n":"if (a >= 0.0) { return a; }  return (exp(a) - 1.0);";case o.ERF:return S;case o.EXP:return"return exp(a);";case o.EXPM1:return"return exp(a) - 1.0;";case o.FLOOR:return"return floor(a);";case o.IS_FINITE:return"return f32(!isnan(a) && !isinf(a));";case o.IS_INF:return"return f32(isinf(a));";case o.IS_NAN:return"return f32(isnan(a));";case o.LINEAR:return"return a;";case o.LOG:return"if (a < 0.0) { return uniforms.NAN; }\n  return log(a);";case o.LOG1P:return"\n  if (isnan(a)) { return a; }\n  return log(1.0 + a);\n";case o.LOGICAL_NOT:return"return f32(!(a >= 1.0));";case o.NEG:return"return -a;";case o.LEAKYRELU:return t?"\n  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));\n  return (aLessThanZero * (uniforms.alpha * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);\n":"if (a < 0.0) { return uniforms.alpha * a; } return a;";case o.RECIPROCAL:return"return 1.0 / a;";case o.RELU:return t?"\n  return select(a, vec4<f32>(0.0), a < vec4<f32>(0.0));\n":"return select(a, 0.0, a < 0.0);";case o.RELU6:return t?"return clamp(a, vec4<f32>(0.0, 0.0, 0.0, 0.0), vec4<f32>(6.0, 6.0, 6.0, 6.0));":"return clamp(a, 0.0, 6.0);";case o.ROUND:return"return round(a);";case o.RSQRT:return"return inverseSqrt(a);";case o.SELU:return w;case o.SIGMOID:return"return 1.0 / (1.0 + exp(-1.0 * a));";case o.SIGN:return"return sign(a);";case o.SIN:return"return sin(a);";case o.SINH:return"\n  let e2x = exp(a);\n  return (e2x - 1.0 / e2x) / 2.0;\n";case o.SOFTPLUS:return"\n  let epsilon = 1.1920928955078125e-7;\n  let threshold = log(epsilon) + 2.0;\n\n  let too_large = a > -threshold;\n  let too_small = a < threshold;\n  let exp_a = exp(a);\n\n  if (too_large) {\n    return a;\n  } else if (too_small) {\n    return exp_a;\n  } else {\n    return log(exp_a + 1.0);\n  }\n";case o.SQRT:return"return sqrt(a);";case o.SQUARE:return"return a * a;";case o.STEP:return"\n  if (isnan(a)) {\n    return a;\n  }\n\n  return select(uniforms.stepAlpha, 1.0, a > 0.0);\n";case o.TAN:return"return tan(a);";case o.TANH:return"\n  let e2x = exp(-2.0 * abs(a));\n  return sign(a) * (1.0 - e2x) / (1.0 + e2x);\n";case o.TO_INT:return"return f32(i32((a)));";default:throw Error("BinaryType ".concat(e," is not implemented!"))}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function activationFnSnippet(e,t,n,a){if(void 0===t&&(t=!1),void 0===n&&(n=!1),void 0===a&&(a=3),null===e)return"";var r="";if("linear"===e)r=getUnaryOpString(o.LINEAR);else if("relu"===e)r=getUnaryOpString(o.RELU,n);else if("elu"===e)r=getUnaryOpString(o.ELU,n);else if("relu6"===e)r=getUnaryOpString(o.RELU6,n);else if("prelu"===e)r=getBinaryOpString(i.PRELU,n);else if("sigmoid"===e)r=getUnaryOpString(o.SIGMOID,n);else if("leakyrelu"===e)r=getUnaryOpString(o.LEAKYRELU,n);else throw Error("Activation ".concat(e," has not been implemented for the WebGPU backend."));var s=typeSnippet(n?4:1);return t?"\n      fn activation(a : ".concat(s,", coords : vec").concat(a,"<i32>) -> ").concat(s," {\n        let b = getPreluActivationWeightsByOutputCoords(coords);\n        ").concat(r,"\n      }"):"\n      fn activation(a : ".concat(s,", coords : vec").concat(a,"<i32>) -> ").concat(s," {\n        ").concat(r,"\n      }")}function biasActivationSnippet(e,t){return"\n      ".concat(e?"value = value + getBiasByOutputCoords(coords);":"","\n      ").concat(t?"value = activation(value, coords);":"","\n      ")}function matMulReadFnSource(e,t,n,a,r,i){void 0===n&&(n=!1),void 0===r&&(r=!1),void 0===i&&(i=1),p.util.assert(e&&1===i||!e,function(){return"transposeA ".concat(e," is not compatible with component size ").concat(i)});var o="\n      ".concat(e?"value = getA(batch, col, row);":"value = getA(batch, row, col);","\n\n    ");return"\n  fn mm_readA(batch: i32, row: i32, col: i32) -> ".concat(typeSnippet(i)," {\n    var value = ").concat(typeSnippet(i),"(0.0);\n    ").concat(n&&r?o:"\n    ".concat(e?"if(row < uniforms.dimAOuter && col < uniforms.dimInner)":"if(row < uniforms.aShape[1] && col < uniforms.aShape[2])","\n    {\n      ").concat(o,"\n    }\n    "),"\n    return value;\n  }\n\n  fn mm_readB(batch: i32, row: i32, col: i32) -> ").concat(typeSnippet(i)," {\n    var value = ").concat(typeSnippet(i),"(0.0);\n    ").concat(t?"value = getB(batch, col, row);":"value = getB(batch, row, col);","\n    return value;\n  }\n  ")}function matMulReadWriteFnSource(e,t,n,a,r,i,o,s){return void 0===r&&(r=!1),void 0===i&&(i=!1),void 0===o&&(o=!1),void 0===s&&(s=1),"\n  ".concat(matMulReadFnSource(n,a,r,i,o,s),"\n  fn mm_write(batch: i32, row: i32, col: i32, valueIn: ").concat(typeSnippet(s),") {\n    ").concat(r&&i?"":"if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)","\n    {\n      var value = valueIn;\n      let coords = vec3<i32>(batch, row, col);\n      ").concat(biasActivationSnippet(e,t),"\n      setOutputAtCoords(coords[0], coords[1], coords[2], value);\n    }\n  }\n  ")}var calculateResultSnippet=function(e,t,n,a){if(e)return"\n      for (var k = 0; k < ".concat(a,"; k++) {\n        let BCached0 = mm_Bsub[k][tileCol];\n        let ACached0 = mm_Asub[k][localRow];\n        for (var i = 0; i < ").concat(n,"; i++) {\n          acc[i] = fma(BCached0, vec4<f32>(ACached0[i]), acc[i]);\n        }\n      }");for(var r="",i="",o=0;o<t;o++)r+="let BCached".concat(o," = mm_Bsub[k * ").concat(t," + ").concat(o,"][tileCol];"),i+="acc[i] = fma(BCached".concat(o,", vec4<f32>(ACached[").concat(o,"]), acc[i]);");return"\n      for (var k = 0; k < ".concat(a/t,"; k++) {\n        ").concat(r,"\n        for (var i = 0; i < ").concat(n,"; i++) {\n          let ACached = mm_Asub[tileRow + i][k];\n          ").concat(i,"\n        }\n      }")};function makeMatMulPackedVec4Source(e,t,n,a,r,i,o){void 0===n&&(n=!1),void 0===a&&(a=32),void 0===r&&(r=!1),void 0===i&&(i=32),void 0===o&&(o=!1);var s=t[1]*e[1],u=t[0]*e[0],c=n?s:a,d=n?a:s,l=c/t[0],h=a/t[1],f=e[1],m=e[0];return p.util.assert((n&&4===l&&4===e[1]||!n&&(3===l||4===l))&&c%t[0]==0&&a%t[1]==0&&4===e[0],function(){return"If transposeA ".concat(n," is true, innerElementSize ").concat(l," and workPerThread[1] ").concat(e[1]," must be 4.\n          Otherwise, innerElementSize ").concat(l," must be 3 or 4.\n      tileAWidth ").concat(c," must be divisible by workgroupSize[0]").concat(t[0],". tileInner ").concat(a," must be divisible by workgroupSize[1] ").concat(t[1],". colPerThread ").concat(e[0]," must be 4.")}),"\n  var<workgroup> mm_Asub : array<array<vec".concat(l,"<f32>, ").concat(c/l,">, ").concat(d,">;\n  var<workgroup> mm_Bsub : array<array<vec4<f32>, ").concat(u/e[0],">, ").concat(a,">;\n\n  ").concat(getMainHeaderString()," {\n    let localRow = i32(localId.y);\n    let tileRow = localRow * ").concat(f,";\n    let tileCol = i32(localId.x);\n\n    let globalRow = i32(globalId.y) * ").concat(f,";\n    let globalCol = i32(globalId.x) * ").concat(m,";\n    let batch = ").concat(r?"0":"i32(globalId.z)",";\n    let batchA = ").concat(r||!o?"batch":"batch % uniforms.aShape[0]",";\n    let batchB = ").concat(r||!o?"batch":"batch % uniforms.bShape[0]",";\n    let globalRowStart = i32(workgroupId.y) * ").concat(s,";\n\n    let numTiles = ").concat(r?"".concat(Math.ceil(i/a)):"(uniforms.dimInner - 1) / ".concat(a," + 1"),";\n    var kStart = ").concat(r?"i32(globalId.z) * ".concat(i):"0",";\n\n    var acc: array<vec4<f32>, ").concat(f,">;\n\n    // Loop over shared dimension.\n    let tileRowB = localRow * ").concat(h,";\n    for (var t = 0; t < numTiles; t++) {\n        // Load one tile of A into local memory.\n        for (var innerRow = 0; innerRow < ").concat(f,"; innerRow++) {\n            let inputRow = tileRow + innerRow;\n            let inputCol = tileCol;\n            ").concat(n?"\n        mm_Asub[inputRow][inputCol] = mm_readA(batchA,\n          kStart + inputRow,\n          globalRowStart + inputCol * ".concat(l,");\n        "):"\n        mm_Asub[inputRow][inputCol] = mm_readA(batchA,\n          globalRow + innerRow,\n          kStart + inputCol * ".concat(l,");\n        "),"\n        }\n\n        // Load one tile of B into local memory.\n        for (var innerRow = 0; innerRow < ").concat(h,"; innerRow++) {\n            let inputRow = tileRowB + innerRow;\n            let inputCol = tileCol;\n            mm_Bsub[inputRow][inputCol] = mm_readB(batchB, kStart + inputRow, globalCol);\n        }\n        kStart = kStart + ").concat(a,";\n        workgroupBarrier();\n\n        // Compute acc values for a single thread.\n        ").concat(calculateResultSnippet(n,l,f,a),"\n        workgroupBarrier();\n    }\n\n    for (var innerRow = 0; innerRow < ").concat(f,"; innerRow++) {\n        mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);\n    }\n  }")}var writeDataToSubASnippet=function(e){return e?"\n        mm_Asub[inputRow][inputCol] = mm_readA(batchA,\n          kStart + inputRow,\n          globalRowStart + inputCol);\n        ":"\n        mm_Asub[inputRow][inputCol] = mm_readA(batchA,\n          globalRowStart + inputRow,\n          kStart + inputCol);\n        "};function makeMatMulPackedSource(e,t,n,a,r,i,o,s){void 0===n&&(n=!1),void 0===a&&(a=32),void 0===r&&(r=!1),void 0===i&&(i=32),void 0===o&&(o=!1),void 0===s&&(s=!1);var u=e[1]*t[1],c=e[0]*t[0],d=n?u:a,l=n?a:u;p.util.assert(l%t[1]==0&&d%t[0]==0&&a%t[1]==0,function(){return"tileAHight ".concat(l," must be divisible by workgroupSize[1]").concat(t[1],", tileAWidth ").concat(d," must be divisible by workgroupSize[0]").concat(t[0],", tileInner ").concat(a," must be divisible by workgroupSize[1]").concat(t[1])});var h=l/t[1],f=d/t[0],m=a/t[1],g=e[1],y=e[0],v=o?"\n      let localRow = i32(localId.y);\n      let localCol = i32(localId.x);\n      let globalRowStart = i32(workgroupId.y) * ".concat(u,";\n      let globalColStart = i32(workgroupId.x) * ").concat(c,";\n\n      // Loop over shared dimension.\n      for (var t = 0; t < numTiles; t++) {\n        // Load one tile of A into local memory.\n        for (var inputRow = localRow; inputRow < ").concat(l,"; inputRow = inputRow + ").concat(t[1],") {\n          for (var inputCol = localCol; inputCol < ").concat(d,"; inputCol = inputCol + ").concat(t[0],") {\n            ").concat(writeDataToSubASnippet(n),"\n          }\n        }\n        // Load one tile of B into local memory.\n        for (var inputRow = localRow; inputRow < ").concat(a,"; inputRow = inputRow + ").concat(t[1],") {\n              for (var inputCol = localCol; inputCol < ").concat(c,"; inputCol = inputCol + ").concat(t[0],") {\n            mm_Bsub[inputRow][inputCol] = mm_readB(batchB,\n              kStart + inputRow,\n              globalColStart + inputCol);\n          }\n        }\n        kStart = kStart + ").concat(a,";\n        workgroupBarrier();\n\n        // Compute acc values for a single thread.\n        var BCached : array<f32, ").concat(y,">;\n        for (var k = 0; k < ").concat(a,"; k++) {\n          for (var inner = 0; inner < ").concat(y,"; inner++) {\n            BCached[inner] = mm_Bsub[k][localCol + inner * ").concat(t[0],"];\n          }\n          for (var innerRow = 0; innerRow < ").concat(g,"; innerRow++) {\n            let ACached = ").concat(n?"mm_Asub[k][localRow + innerRow * ".concat(t[1],"];"):"mm_Asub[localRow + innerRow * ".concat(t[1],"][k];"),"\n            for (var innerCol = 0; innerCol < ").concat(y,"; innerCol++) {\n              acc[innerRow][innerCol] =\n                  fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);\n            }\n          }\n        }\n        workgroupBarrier();\n      }\n      for (var innerRow = 0; innerRow < ").concat(g,"; innerRow++) {\n        let gRow = globalRowStart + localRow + innerRow * ").concat(t[1],";\n        for (var innerCol = 0; innerCol < ").concat(y,"; innerCol++) {\n          let gCol = globalColStart + localCol + innerCol * ").concat(t[0],";\n          mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);\n        }\n      }\n      "):"\n  let tileRow = i32(localId.y) * ".concat(g,";\n  let tileCol = i32(localId.x) * ").concat(y,";\n\n  let globalRow = i32(globalId.y) * ").concat(g,";\n  let globalCol = i32(globalId.x) * ").concat(y,";\n  let globalRowStart = i32(workgroupId.y) * ").concat(u,";\n\n  let tileRowA = i32(localId.y) * ").concat(h,";\n  let tileColA = i32(localId.x) * ").concat(f,";\n  let tileRowB = i32(localId.y) * ").concat(m,";\n  // Loop over shared dimension.\n  for (var t = 0; t < numTiles; t++) {\n    // Load one tile of A into local memory.\n    for (var innerRow = 0; innerRow < ").concat(h,"; innerRow++) {\n      for (var innerCol = 0; innerCol < ").concat(f,"; innerCol++) {\n        let inputRow = tileRowA + innerRow;\n        let inputCol = tileColA + innerCol;\n        ").concat(writeDataToSubASnippet(n),"\n      }\n    }\n\n    // Load one tile of B into local memory.\n    for (var innerRow = 0; innerRow < ").concat(m,"; innerRow++) {\n      for (var innerCol = 0; innerCol < ").concat(y,"; innerCol++) {\n        let inputRow = tileRowB + innerRow;\n        let inputCol = tileCol + innerCol;\n        mm_Bsub[inputRow][inputCol] = mm_readB(batchB,\n          kStart + inputRow,\n          globalCol + innerCol);\n      }\n    }\n    kStart = kStart + ").concat(a,";\n    workgroupBarrier();\n\n    // Compute acc values for a single thread.\n    var BCached : array<f32, ").concat(y,">;\n    for (var k = 0; k < ").concat(a,"; k++) {\n      for (var inner = 0; inner < ").concat(y,"; inner++) {\n        BCached[inner] = mm_Bsub[k][tileCol + inner];\n      }\n\n      for (var innerRow = 0; innerRow < ").concat(g,"; innerRow++) {\n        ").concat(n?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];","\n        for (var innerCol = 0; innerCol < ").concat(y,"; innerCol++) {\n          acc[innerRow][innerCol] =\n              fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);\n        }\n      }\n    }\n\n    workgroupBarrier();\n  }\n\n  for (var innerRow = 0; innerRow < ").concat(g,"; innerRow++) {\n    for (var innerCol = 0; innerCol < ").concat(y,"; innerCol++) {\n      mm_write(batch, globalRow + innerRow, globalCol + innerCol,\n          acc[innerRow][innerCol]);\n    }\n  }\n  ");return"\n    var<workgroup> mm_Asub : array<array<f32, ".concat(d,">, ").concat(l,">;\n    var<workgroup> mm_Bsub : array<array<f32, ").concat(c,">, ").concat(a,">;\n\n    ").concat(getMainHeaderString()," {\n      let batch = ").concat(r?"0":"i32(globalId.z)",";\n      let batchA = ").concat(r||!s?"batch":"batch % uniforms.aShape[0]",";\n      let batchB = ").concat(r||!s?"batch":"batch % uniforms.bShape[0]",";\n      let numTiles = ").concat(r?"".concat(Math.ceil(i/a)):"(uniforms.dimInner - 1) / ".concat(a," + 1"),";\n      var kStart = ").concat(r?"i32(globalId.z) * ".concat(i):"0",";\n\n      var acc : array<array<f32, ").concat(y,">, ").concat(g,">;\n\n      // Without this initialization strange values show up in acc.\n      for (var innerRow = 0; innerRow < ").concat(g,"; innerRow++) {\n        for (var innerCol = 0; innerCol < ").concat(y,"; innerCol++) {\n          acc[innerRow][innerCol] = 0.0;\n        }\n      }\n      ").concat(v,"\n    }\n  ")}var C=function(){function MatMulPackedProgram(e,t,n,a,r,i,o,s){void 0===n&&(n=!1),void 0===a&&(a=!1),void 0===r&&(r=null),void 0===i&&(i=null),void 0===o&&(o=null),void 0===s&&(s=!1),this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=t,this.dispatchLayout={x:[2],y:[1],z:[0]};var u,c=n?e[1]:e[2];if(this.isVec4=(c%4==0&&!n||t[1]%4==0&&n)&&t[2]%4==0&&!a,this.outputComponent=this.isVec4?4:1,this.isVectorA=1===t[1]&&!n,!this.isVec4&&this.isVectorA)this.elementsPerThread=[1,1,1],this.workgroupSize=[32,1,1];else{var d=computeWorkgroupInfoForMatMul(t[1],c,t[2],n);this.workgroupSize=d.workgroupSize,this.elementsPerThread=d.elementsPerThread}this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread);var p=null!=r,l=null!=o;p&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),this.sequentialAccessByThreads=s,this.transposeA=n,this.transposeB=a,this.addBias=p,this.activation=i,this.hasPreluActivationWeights=l,u=__read(this.getShapeFit(t[1],t[2],c),3),this.fitAOuter=u[0],this.fitBOuter=u[1],this.fitInner=u[2],this.shaderKey="matMulPacked_".concat(this.elementsPerThread,"_").concat(n,"_").concat(a,"_").concat(this.activation,"_").concat(this.fitAOuter,"_").concat(this.fitBOuter,"_").concat(this.fitInner,"_").concat(this.isVec4,"_").concat(this.isVectorA,"_").concat(this.sequentialAccessByThreads)}return MatMulPackedProgram.prototype.getShapeFit=function(e,t,n){var a=this.workgroupSize[1]*this.elementsPerThread[1],r=this.workgroupSize[0]*this.elementsPerThread[0];return!this.isVec4&&this.isVectorA?this.tileInner=4*this.workgroupSize[0]:this.tileInner=r,[e%a==0,t%r==0,n%this.tileInner==0]},MatMulPackedProgram.prototype.getUserCode=function(){var e,t,n;return"\n      ".concat(activationFnSnippet(this.activation,this.hasPreluActivationWeights,this.isVec4),"\n      ").concat(matMulReadWriteFnSource(this.addBias,this.activation,!1,this.transposeB,this.fitAOuter,this.fitBOuter,this.fitInner,this.isVec4?4:1),"\n      ").concat(this.isVec4?makeMatMulPackedVec4Source(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,!0):this.isVectorA?(e=this.workgroupSize,void 0===(t=this.transposeA)&&(t=!1),p.util.assert(1===e[1]&&1===e[2],function(){return"A linear work group size is required. But got ".concat(e,".")}),n=4*e[0],"\n    var<workgroup> mm_Asub : array<vec4<f32>, ".concat(e[0],">;\n\n    ").concat(getMainHeaderString()," {\n      let tileCol = i32(localId.x);\n      let globalCol = i32(globalId.x);\n      let globalRow = i32(globalId.y);\n\n      let numTiles = (uniforms.dimInner - 1) / ").concat(n," + 1;\n      let batch = i32(globalId.z);\n      let batchA = batch % uniforms.aShape[0];\n      let batchB = batch % uniforms.bShape[0];\n      // Without this initialization strange values show up in acc.\n      var acc = 0.0;\n\n      // Loop over shared dimension.\n      for (var t = 0; t < numTiles; t++) {\n        // Load one tile of A into local memory.\n        let colA = t * ").concat(n," + tileCol * 4;\n        mm_Asub[tileCol] = vec4<f32>(").concat(t?"\n      mm_readA(batchA, colA, globalRow),\n      mm_readA(batchA, colA + 1, globalRow),\n      mm_readA(batchA, colA + 2, globalRow),\n      mm_readA(batchA, colA + 3, globalRow)\n  ":"\n      mm_readA(batchA, globalRow, colA),\n      mm_readA(batchA, globalRow, colA + 1),\n      mm_readA(batchA, globalRow, colA + 2),\n      mm_readA(batchA, globalRow, colA + 3)\n  ",");\n        workgroupBarrier();\n\n        // Compute acc values for a single thread.\n        for (var k = 0; k < ").concat(n/4,"; k++) {\n          let rowB = t * ").concat(n," + k * 4;\n          let BCached = vec4<f32>(mm_readB(batchB, rowB, globalCol),\n                              mm_readB(batchB, rowB + 1, globalCol),\n                              mm_readB(batchB, rowB + 2, globalCol),\n                              mm_readB(batchB, rowB + 3, globalCol));\n\n          let ACached = mm_Asub[k];\n          acc = acc + dot(ACached, BCached);\n        }\n\n        workgroupBarrier();\n      }\n\n      mm_write(batch, globalRow, globalCol, acc);\n    }\n  ")):makeMatMulPackedSource(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,this.sequentialAccessByThreads,!0),"\n    ")},MatMulPackedProgram}(),k=function(){function MatMulReduceProgram(e,t,n,a,r,i){void 0===t&&(t=!1),void 0===n&&(n=!1),void 0===a&&(a=null),void 0===r&&(r=null),void 0===i&&(i=null),this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout={x:[],y:[1,2],z:[0]},this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize);var o=null!=a,s=null!=i;o&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),this.transposeA=t,this.transposeB=n,this.addBias=o,this.activation=r,this.hasPreluActivationWeights=s,this.shaderKey="matMulReduce_".concat(this.activation,"_").concat(t,"_").concat(n)}return MatMulReduceProgram.prototype.getUserCode=function(){var e;return"\n      ".concat(activationFnSnippet(this.activation,this.hasPreluActivationWeights),"\n      ").concat(matMulReadWriteFnSource(this.addBias,this.activation,this.transposeA,this.transposeB),"\n      ").concat((e=this.workgroupSize[0],"\n    var<workgroup> sumValues : array<f32, ".concat(e,">;\n    ").concat(getMainHeaderString()," {\n      let coords = getOutputCoords();\n      let batch = coords[0];\n      let batchA = batch % uniforms.aShape[0];\n      let batchB = batch % uniforms.bShape[0];\n      let row = coords[1];\n      let col = coords[2];\n      var sum = 0.0;\n      let Length = uniforms.dimInner;\n      for (var k = i32(localId.x); k < Length; k = k + ").concat(e,") {\n        let dataA = mm_readA(batchA, row, k);\n        let dataB = mm_readB(batchB, k, col);\n        sum = sum + dataA * dataB;\n      }\n      sumValues[localId.x] = sum;\n      workgroupBarrier();\n\n      for(var currentSize = ").concat(e/2,"u; currentSize > 1u;\n          currentSize = currentSize / 2u) {\n        if (localId.x < currentSize)\n        {\n          sumValues[localId.x] = sumValues[localId.x] + sumValues[localId.x + currentSize];\n        }\n        workgroupBarrier();\n      }\n\n      if (localId.x == 0u) {\n        sum = sumValues[0] + sumValues[1];\n        mm_write(batch, row, col, sum);\n      }\n    }\n  ")),"\n    ")},MatMulReduceProgram}(),I=function(){function MatMulSmallOutputSizeProgram(e,t,n,a,r,i,o,s){void 0===a&&(a=!1),void 0===r&&(r=!1),void 0===i&&(i=null),void 0===o&&(o=null),void 0===s&&(s=null),this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[16,8,1],this.outputShape=n,this.dispatchLayout={x:[2],y:[1],z:[0]},this.dispatch=[Math.ceil(n[2]/this.workgroupSize[0]),Math.ceil(n[1]/this.workgroupSize[1]),n[0]];var u=null!=i;u&&this.variableNames.push("bias");var c=null!=s;c&&this.variableNames.push("preluActivationWeights"),this.transposeA=a,this.transposeB=r,this.addBias=u,this.activation=o,this.hasPreluActivationWeights=c,this.shaderKey="matMulSmallOutputSize_".concat(this.activation,"_").concat(a,"_").concat(r)}return MatMulSmallOutputSizeProgram.prototype.getUserCode=function(){var e,t,n,a;return"\n      ".concat(activationFnSnippet(this.activation,this.hasPreluActivationWeights),"\n      ").concat(matMulReadWriteFnSource(this.addBias,this.activation,this.transposeA,this.transposeB),"\n      ").concat((a=(t=(e=this.workgroupSize)[1])>(n=e[0])?t:n,"\n  var<workgroup> mm_Asub : array<array<f32, ".concat(a,">, ").concat(t,">;\n  var<workgroup> mm_Bsub : array<array<f32, ").concat(n,">, ").concat(a,">;\n\n  // If the output size is small for matrix multiplication, avoid to use vec4\n  // and handle some elements per thread to optimally utilize the ALU.\n  // Read data from global memory to registers firstly, then store them into\n  // shared memory, so it is instruction-Level parallelism for arithmetic\n  // operations and others handle IO operations between barrier api, makes ALU\n  // and load/store units work simultaneously, could improves the performance.\n  ").concat(getMainHeaderString()," {\n    let tileRow = i32(localId.y);\n    let tileCol = i32(localId.x);\n    let globalRow = i32(globalId.y);\n    let globalCol = i32(globalId.x);\n    let batch = i32(globalId.z);\n    let batchA = batch % uniforms.aShape[0];\n    let batchB = batch % uniforms.bShape[0];\n\n    // uniforms.dimInner should be greater than 0.\n    let numTiles = (uniforms.dimInner - 1) / ").concat(a," + 1;\n    var acc = 0.0;\n\n    var globalColA = tileCol;\n    var globalRowB = 0;\n    var regA = mm_readA(batchA, globalRow, globalColA);\n    var regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);\n    var regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);\n    globalColA = globalColA + ").concat(a,";\n    globalRowB = globalRowB + ").concat(a,";\n\n    for (var t = 0; t < numTiles; t = t + 1) {\n      mm_Asub[tileRow][tileCol] = regA;\n      mm_Bsub[2 * tileRow][tileCol] = regB0;\n      mm_Bsub[2 * tileRow + 1][tileCol] = regB1;\n\n      workgroupBarrier();\n\n      regA = mm_readA(batchA, globalRow, globalColA);\n      regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);\n      regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);\n      globalColA = globalColA + ").concat(a,";\n      globalRowB = globalRowB + ").concat(a,";\n\n      for (var k = 0; k < ").concat(a,"; k = k + 1) {\n        acc = acc + mm_Asub[tileRow][k] * mm_Bsub[k][tileCol];\n      }\n      workgroupBarrier();\n    }\n\n    mm_write(batch, globalRow, globalCol, acc);\n  }\n  ")),"\n    ")},MatMulSmallOutputSizeProgram}(),P=function(){function MatMulSplitKProgram(e,t,n,a){void 0===n&&(n=!1),void 0===a&&(a=!1),this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[8,8,1],this.atomic=!0,this.splitedDimInner=128,p.util.assert(1===e[0],function(){return"MatMulSplitKProgram only supports batch = 1."}),this.outputShape=e,this.dispatchLayout={x:[2],y:[1],z:[0,3]};var r=(n&&this.outputShape[1]%4==0||!n&&t%4==0)&&this.outputShape[2]%4==0;this.elementsPerThread=[4,4,this.splitedDimInner],this.outputComponent=r?4:1,!r&&(this.outputShape[1]<16&&(this.elementsPerThread[1]=1),this.outputShape[2]<16&&(this.elementsPerThread[0]=1)),this.dispatch=computeDispatch(this.dispatchLayout,[this.outputShape[0],this.outputShape[1],this.outputShape[2],t],this.workgroupSize,this.elementsPerThread),this.transposeA=n,this.transposeB=a,this.shaderKey="matMulSplitK_".concat(n,"_").concat(a,"_").concat(this.elementsPerThread,"_").concat(this.outputComponent)}return MatMulSplitKProgram.prototype.getUserCode=function(){var e=this.outputComponent;return"\n      ".concat(matMulReadFnSource(!1,this.transposeB,!1,!1,!1,e),"\n      fn mm_write(batch: i32, row : i32, col : i32, value : ").concat(typeSnippet(e),") {\n        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {\n          let coords = vec3<i32>(batch, row, col);\n          let flatIndex = getOutputIndexFromCoords(coords);\n          // The problem is that we should initialize output to zero before using.\n          // Otherwise, the original value will be added to the result.\n          for (var i = 0; i < ").concat(e,"; i = i + 1) {\n            ").concat(atomicAddSnippet("&result[flatIndex + i]","".concat(e>1?"value[i]":"value"),"float32"),"\n          }\n        }\n      }\n      ").concat(4===e?makeMatMulPackedVec4Source(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner):makeMatMulPackedSource(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner),"\n    ")},MatMulSplitKProgram}(),R=function(){function BiasActivationProgram(e,t,n,a){void 0===t&&(t=null),void 0===n&&(n=null),void 0===a&&(a=null),this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=null!=t,this.hasPreluActivationWeights=null!=a,this.activation=n,this.addBias&&this.variableNames.push("bias"),this.hasPreluActivationWeights&&this.variableNames.push("preluActivationWeights"),this.shaderKey="biasActivation_".concat(n)}return BiasActivationProgram.prototype.getUserCode=function(){return"\n    ".concat(activationFnSnippet(this.activation,this.hasPreluActivationWeights),"\n    ").concat(getMainHeaderString("index")," {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        var value = getXByOutputIndex(index);\n        ").concat(biasActivationSnippet(this.addBias,this.activation),"\n        setOutputAtIndex(index, value);\n      }\n    }\n    ")},BiasActivationProgram}(),D=function(){function FillProgram(e){this.variableNames=[],this.outputShape=[],this.uniforms="value : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="fill"}return FillProgram.prototype.getUserCode=function(){return"\n    ".concat(getMainHeaderString("index")," {\n      if (index < uniforms.size) {\n        setOutputAtIndex(index, uniforms.value);\n      }\n    }\n  ")},FillProgram}();/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fill(e){var t=e.backend,n=e.attrs,a=n.shape,r=n.value,i=n.dtype;if("string"===(i=i||p.util.inferDtype(r))){var o=p.util.getArrayFromDType(i,p.util.sizeFromShape(a));return o.fill(r),t.makeTensorInfo(a,i,o)}var s=new D(a),u=[{type:"float32",data:[r]}];return t.runWebGPUProgram(s,[],i,u)}var _={kernelName:p.Fill,backendName:"webgpu",kernelFunc:fill};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function reshape(e){var t=e.inputs,n=e.attrs,a=t.x,r=n.shape,i=p.util.sizeFromShape(a.shape),o=p.util.inferFromImplicitShape(r,i),s=p.util.sizeFromShape(o);return p.util.assert(i===s,function(){return"The new shape (".concat(o,") has ").concat(s," elements and the old ")+"shape (".concat(a.shape,") has ").concat(i," elements. The new shape and old ")+"shape must have the same number of elements."}),e.backend.incRef(a.dataId),{dataId:a.dataId,shape:o,dtype:a.dtype}}var A={kernelName:p.Reshape,backendName:"webgpu",kernelFunc:reshape};function batchMatMulImpl(e){var t,n,a,i,o,s,u=e.a,c=e.b,d=e.transposeA,l=e.transposeB,h=e.backend,f=e.bias,m=void 0===f?null:f,g=e.preluActivationWeights,y=void 0===g?null:g,v=e.leakyreluAlpha,x=void 0===v?0:v,b=e.activation,S=void 0===b?null:b,w=u.shape.length,D=c.shape.length,_=d?u.shape[w-2]:u.shape[w-1],A=l?c.shape[D-1]:c.shape[D-2],z=d?u.shape[w-1]:u.shape[w-2],N=l?c.shape[D-2]:c.shape[D-1],F=u.shape.slice(0,-2),T=c.shape.slice(0,-2),B=p.util.sizeFromShape(F),L=p.util.sizeFromShape(T),M=p.broadcast_util.assertAndGetBroadcastShape(u.shape.slice(0,-2),c.shape.slice(0,-2)).concat([z,N]);p.util.assert(_===A,function(){return"Error in matMul: inner shapes (".concat(_,") and (")+"".concat(A,") of Tensors with shapes ").concat(u.shape," and ")+"".concat(c.shape," and transposeA=").concat(d)+" and transposeB=".concat(l," must match.")});var W=d?[B,_,z]:[B,z,_],U=l?[L,N,A]:[L,A,N],E=reshape({inputs:{x:u},backend:h,attrs:{shape:W}}),O=reshape({inputs:{x:c},backend:h,attrs:{shape:U}}),V=[E,O],G=Math.max(B,L),H=[E,O],K=[{type:"int32",data:[z]},{type:"int32",data:[N]},{type:"int32",data:[_]}],X=[G,z,N],q=p.env().get("WEBGPU_MATMUL_PROGRAM_TYPE");if(q<0){var Y=p.env().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),j=Y>0?Y:h.thresholdToIncreaseWorkgroups,Q=G*Math.ceil(z/32)*Math.ceil(N/32);q=Q<=j||z<=8&&Q<=2*j?G*z*N<=128?r.MatMulReduceProgram:1===G&&A>=2e3?r.MatMulSplitKProgram:r.MatMulSmallOutputSizeProgram:r.MatMulPackedProgram}switch(q){case r.MatMulReduceProgram:o=new k(X,d,l,m,S,y);break;case r.MatMulSplitKProgram:if(s=fill({backend:h,attrs:{shape:X,value:0,dtype:u.dtype}}),o=new P(X,A,d,l),m||S){s=h.runWebGPUProgram(o,H,u.dtype,K,s);var Z=new R(s.shape,m,S,y),$=null,J=[s];m&&J.push(m),y&&J.push(y),"leakyrelu"===S&&($=[{type:"float32",data:[x]}],Z.uniforms+=" alpha : f32,");var ee=h.runWebGPUProgram(Z,J,s.dtype,$);V.push(s);var et=reshape({inputs:{x:ee},backend:h,attrs:{shape:M}});V.push(ee);try{for(var en=__values(V),ea=en.next();!ea.done;ea=en.next()){var er=ea.value;h.disposeData(er.dataId)}}catch(e){t={error:e}}finally{try{ea&&!ea.done&&(n=en.return)&&n.call(en)}finally{if(t)throw t.error}}return et}break;case r.MatMulSmallOutputSizeProgram:o=new I(W,U,X,d,l,m,S,y);break;case r.MatMulPackedProgram:var ei=h.adapterInfo.isIntel();o=new C(W,X,d,l,m,S,y,ei);break;default:throw Error("Unsupported MatMulProgramType ".concat(q,"."))}m&&H.push(m),y&&H.push(y),"leakyrelu"===S&&(K.push({type:"float32",data:[x]}),o.uniforms+=" alpha : f32,");var eo=reshape({inputs:{x:s=h.runWebGPUProgram(o,H,u.dtype,K,s)},backend:h,attrs:{shape:M}});V.push(s);try{for(var es=__values(V),eu=es.next();!eu.done;eu=es.next()){var er=eu.value;h.disposeData(er.dataId)}}catch(e){a={error:e}}finally{try{eu&&!eu.done&&(i=es.return)&&i.call(es)}finally{if(a)throw a.error}}return eo}var z={kernelName:p._FusedMatMul,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var t=e.inputs,n=e.backend,a=e.attrs,r=t.a,i=t.b,o=t.bias,s=t.preluActivationWeights,u=a.transposeA,c=a.transposeB,d=a.activation;return batchMatMulImpl({a:r,b:i,transposeA:u,transposeB:c,backend:n,bias:o,preluActivationWeights:s,leakyreluAlpha:a.leakyreluAlpha,activation:d})}},N=function(){function BinaryOpComplexProgram(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.workgroupSize=[128,1,1],this.size=!0,this.outputShape=p.backend_util.assertAndGetBroadcastShape(t,n),this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="binaryOpComplex_".concat(e),this.op=e}return BinaryOpComplexProgram.prototype.getUserCode=function(){var e=getBinaryOpString(this.op,!1);return"\n      fn binaryOpComplex(\n          areal : f32, aimag : f32, breal : f32, bimag : f32) -> f32 {\n        ".concat(e,"\n      }\n\n      ").concat(getMainHeaderString("index")," {\n        if(index < uniforms.size) {\n          let areal = getARealByOutputIndex(index);\n          let aimag = getAImagByOutputIndex(index);\n          let breal = getBRealByOutputIndex(index);\n          let bimag = getBImagByOutputIndex(index);\n          setOutputAtIndex(index, binaryOpComplex(areal, aimag, breal, bimag));\n        }\n      }\n    ")},BinaryOpComplexProgram}(),F=function(){function BinaryOpProgram(e,t,n){if(this.size=!0,this.variableNames=["A","B"],this.outputShape=p.backend_util.assertAndGetBroadcastShape(t,n),this.dispatchLayout=flatDispatchLayout(this.outputShape),this.op=e,this.useSharedMemoryWithA=t.length<=1&&n.length>1&&t[0]<128,this.useSharedMemoryWithB=n.length<=1&&t.length>1&&n[0]<128,this.useSharedMemoryWithA||this.useSharedMemoryWithB)this.outputComponent=1,this.variableComponents=[1,1],this.lastDimensionSize=this.useSharedMemoryWithB?n[0]:t[0],this.shaderKey="binary_".concat(e,"_").concat(this.lastDimensionSize),this.type="shared",this.workgroupSize=[256,1,1];else{var a=t.length>0&&t[t.length-1]%4==0,r=n.length>0&&n[n.length-1]%4==0;a&&r?(this.outputComponent=4,this.variableComponents=[4,4]):a&&(p.util.isScalarShape(n)||1===n[n.length-1])||r&&(p.util.isScalarShape(t)||1===t[t.length-1])?(this.outputComponent=4,this.variableComponents=a?[4,1]:[1,4]):(this.outputComponent=1,this.variableComponents=[1,1]),this.type="nonshared",this.shaderKey="binary_".concat(e,"_").concat(this.variableComponents),this.workgroupSize=[128,1,1]}this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.outputComponent,1,1])}return BinaryOpProgram.prototype.getUserCode=function(){var e,t=4===this.outputComponent?"vec4<f32>":"f32",n="\n    fn binaryOperation(a : ".concat(t,", b : ").concat(t,") -> ").concat(t," {\n      ").concat(getBinaryOpString(this.op,4===this.outputComponent),"\n    };\n    ");if("shared"===this.type){var a=this.lastDimensionSize>1?"coords[".concat(this.outputShape.length-1,"]"):"0",r=this.useSharedMemoryWithB?"let a = getAByOutputIndex(index);\n          let b = sharedBuf[".concat(a,"];"):"let a = sharedBuf[".concat(a,"];\n          let b = getBByOutputIndex(index);");e="\n        ".concat(n,"\n        var<workgroup> sharedBuf : array<f32, ").concat(this.lastDimensionSize,">;\n        ").concat(getMainHeaderString("index")," {\n          // Fill in the shared memory buffer.\n          let localIndex = i32(localId.x);\n          if(localIndex < ").concat(this.lastDimensionSize,") {\n            sharedBuf[localIndex] = f32(").concat(this.useSharedMemoryWithB?"B":"A","[localIndex]);\n          }\n          workgroupBarrier();\n\n          if(index < uniforms.size) {\n            let coords = getCoordsFromIndex(index);\n            ").concat(r,"\n            setOutputAtIndex(index, binaryOperation(a, b));\n          }\n        }\n        ")}else e="\n       ".concat(n,"\n       ").concat(getMainHeaderString("index")," {\n         if (index < uniforms.size) {\n           let coords = getCoordsFromIndex(index * ").concat(this.outputComponent,");\n           let a = ").concat(t,"(getAByOutputCoords(coords));\n           let b = ").concat(t,"(getBByOutputCoords(coords));\n           setOutputAtIndex(index, binaryOperation(a, b));\n         }\n       }\n       ");return e},BinaryOpProgram}();/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function identity(e){var t=e.inputs.x;return e.backend.incRef(t.dataId),{dataId:t.dataId,shape:t.shape,dtype:t.dtype}}var T={kernelName:p.Identity,backendName:"webgpu",kernelFunc:identity};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function complex(e){var t=e.inputs,n=e.backend,a=t.real,r=t.imag,i=n.makeTensorInfo(a.shape,"complex64"),o=n.tensorMap.get(i.dataId),s=identity({inputs:{x:a},backend:n}),u=identity({inputs:{x:r},backend:n});return o.complexTensorInfos={real:s,imag:u},i}var B={kernelName:p.Complex,backendName:"webgpu",kernelFunc:complex},L=function(){function UnaryOpProgram(e,t,n){void 0===n&&(n=""),this.variableNames=["A"],this.size=!0,this.workgroupSize=[128,1,1],this.outputShape=e,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.op=t,""!==n&&(this.uniforms=n),this.shaderKey="unary_".concat(t)}return UnaryOpProgram.prototype.getUserCode=function(){return"\n      fn unaryOperation(a : f32) -> f32 {\n        ".concat(getUnaryOpString(this.op,!1),"\n      }\n      ").concat(getMainHeaderString("index")," {\n        if (index < uniforms.size) {\n          let a = getAByOutputIndex(index);\n          setOutputAtIndex(index, unaryOperation(a));\n        }\n      }\n      ")},UnaryOpProgram}();function unaryKernelFunc(e){var t=e.opType,n=e.cpuKernelImpl,a=e.dtype;return function(e){var r=e.inputs,i=e.backend,o=r.x,s=a||o.dtype;if(i.shouldExecuteOnCPU([o])&&null!=n){var u=n(i.tensorMap.get(o.dataId).values,s);return i.makeTensorInfo(o.shape,s,u)}var c=new L(o.shape,t);return i.runWebGPUProgram(c,[o],s)}}function binaryKernelFunc(e){var t=e.opType,n=e.cpuKernelImpl,a=e.supportsComplex,r=void 0!==a&&a,o=e.dtype;return function(e){var a,s=e.inputs,u=e.backend,c=s.a,d=s.b;if(r&&"complex64"===c.dtype){var l=u.tensorMap.get(c.dataId),h=u.tensorMap.get(d.dataId),f=void 0,m=void 0;if(t!==i.MUL)f=(a=__read([[l.complexTensorInfos.real,h.complexTensorInfos.real],[l.complexTensorInfos.imag,h.complexTensorInfos.imag]].map(function(e){var n=__read(e,2),a=n[0],r=n[1],i={dataId:a.dataId,dtype:a.dtype,shape:c.shape},o={dataId:r.dataId,dtype:r.dtype,shape:d.shape},s=new F(t,c.shape,d.shape);return u.runWebGPUProgram(s,[i,o],p.upcastType(a.dtype,r.dtype))}),2))[0],m=a[1];else{var g=new N(i.COMPLEX_MULTIPLY_REAL,c.shape,d.shape),y=new N(i.COMPLEX_MULTIPLY_IMAG,c.shape,d.shape),v=[{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:c.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:c.shape},{dataId:h.complexTensorInfos.real.dataId,dtype:h.complexTensorInfos.real.dtype,shape:d.shape},{dataId:h.complexTensorInfos.imag.dataId,dtype:h.complexTensorInfos.imag.dtype,shape:d.shape}];f=u.runWebGPUProgram(g,v,"float32"),m=u.runWebGPUProgram(y,v,"float32")}var x=complex({inputs:{real:f,imag:m},backend:u});return u.disposeData(f.dataId),u.disposeData(m.dataId),x}var b=o||p.upcastType(c.dtype,d.dtype);if(("string"===c.dtype||"string"===d.dtype||u.shouldExecuteOnCPU([c,d]))&&null!=n){var l=u.tensorMap.get(c.dataId).values,h=u.tensorMap.get(d.dataId).values,S="string"===c.dtype?p.backend_util.fromUint8ToStringArray(l):l,w="string"===c.dtype?p.backend_util.fromUint8ToStringArray(h):h,C=__read(n(c.shape,d.shape,S,w,b),2),k=C[0],I=C[1];return u.makeTensorInfo(I,b,k)}var P=new F(t,c.shape,d.shape);return u.runWebGPUProgram(P,[c,d],b)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function createSimpleBinaryKernelImpl(e){return function(t,n,a,r,i){var o=p.backend_util.assertAndGetBroadcastShape(t,n),s=o.length,u=p.util.computeStrides(o),c=p.util.sizeFromShape(o),d=p.util.getTypedArrayFromDType(i,c),l=t.length,h=n.length,f=p.util.computeStrides(t),m=p.util.computeStrides(n),g=p.backend_util.getBroadcastDims(t,o),y=p.backend_util.getBroadcastDims(n,o);if(g.length+y.length===0)for(var v=0;v<d.length;++v)d[v]=e(a[v%a.length],r[v%r.length]);else for(var v=0;v<d.length;++v)!function(t){var n=p.util.indexToLoc(t,s,u),i=n.slice(-l);g.forEach(function(e){return i[e]=0});var o=p.util.locToIndex(i,l,f),c=n.slice(-h);y.forEach(function(e){return c[e]=0});var v=p.util.locToIndex(c,h,m);d[t]=e(a[o],r[v])}(v);return[d,o]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var M=createSimpleBinaryKernelImpl(function(e,t){return e+t});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function createSimpleUnaryImpl(e){return function(t,n,a){for(var r=p.util.getArrayFromDType(n,t.length),i=0;i<t.length;++i)r[i]=e(t[i],a);return r}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var W=createSimpleUnaryImpl(function(e){return Math.ceil(e)}),U=createSimpleBinaryKernelImpl(function(e,t){return e===t?1:0}),E=createSimpleUnaryImpl(function(e){return Math.exp(e)}),O=createSimpleUnaryImpl(function(e){return Math.expm1(e)}),V=createSimpleUnaryImpl(function(e){return Math.floor(e)}),G=createSimpleBinaryKernelImpl(function(e,t){return Math.floor(e/t)}),H=createSimpleBinaryKernelImpl(function(e,t){return e>t?1:0}),K=createSimpleBinaryKernelImpl(function(e,t){return e>=t?1:0}),X=createSimpleBinaryKernelImpl(function(e,t){return e<t?1:0}),q=createSimpleBinaryKernelImpl(function(e,t){return e<=t?1:0}),Y=createSimpleUnaryImpl(function(e){return Math.log(e)}),j=createSimpleBinaryKernelImpl(function(e,t){return Math.max(e,t)}),Q=createSimpleBinaryKernelImpl(function(e,t){return Math.min(e,t)}),Z=createSimpleBinaryKernelImpl(function(e,t){return e*t}),$=createSimpleBinaryKernelImpl(function(e,t){return e!==t?1:0});p.backend_util.RowPartitionType;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var J=createSimpleUnaryImpl(function(e){return 1/Math.sqrt(e)}),ee=function(){function StringNGramsOp(e,t,n,a,r,i){this.separator=p.util.encodeString(e),this.nGramWidths=t,this.leftPad=p.util.encodeString(n),this.rightPad=p.util.encodeString(a),this.padWidth=r,this.preserveShort=i}return StringNGramsOp.prototype.getPadWidth=function(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)},StringNGramsOp.prototype.getNumNGrams=function(e,t){return Math.max(0,e+2*this.getPadWidth(t)-t+1)},StringNGramsOp.prototype.createNGrams=function(e,t,n,a,r,i){for(var o=this,s=0;s<r;++s)!function(s){var u,c=o.getPadWidth(i),d=Math.max(0,c-s),p=Math.max(0,c-(r-(s+1))),l=i-(d+p),h=t+(d>0?0:s-c);u=0+d*o.leftPad.length;for(var f=0;f<l;++f)u+=e[h+f].length;u+=p*o.rightPad.length+(d+p+l-1)*o.separator.length,n[a+s]=new Uint8Array(u);for(var m=n[a+s],g=0,appendToNGram=function(e){return e.forEach(function(e){return m[g++]=e})},f=0;f<d;++f)appendToNGram(o.leftPad),appendToNGram(o.separator);for(var f=0;f<l-1;++f)appendToNGram(e[h+f]),appendToNGram(o.separator);if(l>0){appendToNGram(e[h+l-1]);for(var f=0;f<p;++f)appendToNGram(o.separator),appendToNGram(o.rightPad)}else{for(var f=0;f<p-1;++f)appendToNGram(o.rightPad),appendToNGram(o.separator);appendToNGram(o.rightPad)}}(s)},StringNGramsOp.prototype.compute=function(e,t){var n=this,a=e.length,r=t.length;if(r>0){var i=t[0];if(0!==i)throw Error("First split value must be 0, got ".concat(i));for(var o=1;o<r;++o){var s=t[o]>=i;if(!(s=s&&t[o]<=a))throw Error("Invalid split value ".concat(t[o],", must be in [").concat(i,", ").concat(a,"]"));i=t[o]}if(i!==a)throw Error("Last split value must be data size. Expected ".concat(a,", got ").concat(i))}var u=r-1,c=p.util.getArrayFromDType("int32",r);if(0===a||0===r){for(var d=Array(a),o=0;o<=u;++o)c[o]=0;return[d,c]}c[0]=0;for(var l=this,o=1;o<=u;++o)!function(e){var a=t[e]-t[e-1],r=0;l.nGramWidths.forEach(function(e){r+=n.getNumNGrams(a,e)}),l.preserveShort&&a>0&&0===r&&(r=1),c[e]=c[e-1]+r}(o);for(var h=Array(c[u]),_loop_3=function(a){var r=t[a],i=c[a];if(f.nGramWidths.forEach(function(o){var s=t[a+1]-t[a],u=n.getNumNGrams(s,o);n.createNGrams(e,r,h,i,u,o),i+=u}),f.preserveShort&&i===c[a]){var o=t[a+1]-t[a];if(0===o)return"continue";var s=o+2*f.padWidth;f.createNGrams(e,r,h,i,1,s)}},f=this,o=0;o<u;++o)_loop_3(o);return[h,c]},StringNGramsOp}(),et=createSimpleBinaryKernelImpl(function(e,t){return e-t}),comparePair=function(e,t){var n=t.value-e.value;return 0===n?e.index-t.index:n},castImplCPU=function(e,t,n,a){if("int32"===a)return[t,"int32",Int32Array.from(e)];if("bool"===a){var r=p.util.toTypedArray([0],n),i=__read(createSimpleBinaryKernelImpl(function(e,t){return e!==t?1:0})(t,[],e,r,"bool"),2),o=i[0];return[i[1],"bool",o]}throw Error("Error in Cast: failed to cast ".concat(n," to ").concat(a))},concatImplCPU=/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e,t,n,a){var r=p.util.getArrayFromDType(n,p.util.sizeFromShape(t));if(a&&"string"!==n){var i=0;e.forEach(function(e){var t=p.util.sizeFromShape(e.shape);r.set(e.vals,i),i+=t})}else{var o=0;e.forEach(function(e){for(var a="string"===n?p.backend_util.fromUint8ToStringArray(e.vals):e.vals,i=0,s=0;s<e.shape[0];++s)for(var u=s*t[1]+o,c=0;c<e.shape[1];++c)r[u+c]=a[i++];o+=e.shape[1]})}return r},gatherNdImplCPU=function(e,t,n,a,r,i,o,s,u){for(var c=p.buffer([a,i],n),d=0;d<a;d++){for(var l=[],h=0,f=0;f<r;f++){var m=e[d*r+f];h+=m*o[f],l.push(m)}if(h<0||h>=u/i)throw Error("Invalid indices: ".concat(l," does not index into ").concat(s));for(var g=0;g<i;g++)c.values[d*i+g]=t.get.apply(t,__spreadArray([],__read(t.indexToLoc(h*i+g)),!1))}return c},gatherV2ImplCPU=/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e,t,n){for(var a=p.buffer(n,e.dtype),r=0;r<a.size;++r){var i=a.indexToLoc(r).slice(),o=i[0],s=i[2],u=t.locToIndex([o,s]);i[2]=t.values[u];var c=e.locToIndex(i);0<=c&&c<e.values.length&&(a.values[r]=e.values[c])}return a},maxImplCPU=/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e,t,n,a){for(var r=p.util.getTypedArrayFromDType(a,p.util.sizeFromShape(n)),i=0;i<r.length;++i){for(var o=i*t,s=e[o],u=0;u<t;++u){var c=e[o+u];(Number.isNaN(c)||c>s)&&(s=c)}r[i]=s}return r},prodImplCPU=function(e,t,n,a){for(var r=__read(p.backend_util.computeOutAndReduceShapes(e,a),2),i=r[0],o=r[1],s=p.upcastType(t,"int32"),u=p.util.makeZerosTypedArray(p.util.sizeFromShape(i),s),c=p.util.sizeFromShape(o),d=0;d<u.length;++d){for(var l=d*c,h=1,f=0;f<c;++f)h*=n[l+f];u[d]=h}return{outVals:u,outShape:i,outDtype:s}},rangeImplCPU=/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e,t,n,a){var r=e<t&&n<0,i=t<e&&n>1;if(e===t||r||i)return p.util.makeZerosTypedArray(0,a);var o=Math.abs(Math.ceil((t-e)/n)),s=p.util.makeZerosTypedArray(o,a);t<e&&1===n&&(n=-1),s[0]=e;for(var u=1;u<s.length;u++)s[u]=s[u-1]+n;return s},scatterImplCPU=/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e,t,n,a,r,i,o,s,u,c){var d=[a/r,r],l=e.values,h=t.values;if(0===a)return p.buffer(n,t.dtype);var f=u instanceof p.TensorBuffer?u:p.buffer(d,t.dtype);"string"==typeof u?f.values.fill(u):"number"==typeof u?f.values.fill(u):"boolean"==typeof u&&f.values.fill(+u);for(var m=0;m<i;m++){for(var g=[],y=0,v=0;v<o;v++){var x=l[m*o+v];g.push(x),y+=x*s[v]}if(y<0||y>=a/r)throw Error("Invalid indices: ".concat(g," does not index into ").concat(n));for(var b=0;b<r;b++)c?f.values[y*r+b]+=h[m*r+b]:f.values[y*r+b]=0===t.rank?h[0]:h[m*r+b]}return f},sliceImplCPU=function(e,t,n,a,r){var i=p.slice_util.isSliceContinous(a,t,n),o=p.util.sizeFromShape(n),s=p.util.computeStrides(a);if(i){var u=p.slice_util.computeFlatOffset(t,s);return"string"===r?e.slice(u,u+o):e.subarray(u,u+o)}for(var c="string"===r?p.backend_util.fromUint8ToStringArray(e):e,d=p.buffer(a,r,c),l=p.buffer(n,r),h=0;h<l.size;++h){var f=l.indexToLoc(h),m=f.map(function(e,n){return e+t[n]});l.set.apply(l,__spreadArray([d.get.apply(d,__spreadArray([],__read(m),!1))],__read(f),!1))}return"string"===r?p.backend_util.fromStringArrayToUint8(l.values):l.values},stridedSliceImplCPU=function(e,t,n,a){for(var r=p.buffer(e,t.dtype),i=0;i<r.size;i++){for(var o=r.indexToLoc(i),s=Array(o.length),u=0;u<s.length;u++)s[u]=o[u]*n[u]+a[u];r.set.apply(r,__spreadArray([t.get.apply(t,__spreadArray([],__read(s),!1))],__read(o),!1))}return r},tileImplCPU=/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e,t){for(var n=Array(e.rank),a=0;a<n.length;a++)n[a]=e.shape[a]*t[a];for(var r=p.buffer(n,e.dtype),a=0;a<r.values.length;++a){for(var i=r.indexToLoc(a),o=Array(e.rank),s=0;s<o.length;s++)o[s]=i[s]%e.shape[s];var u=e.locToIndex(o);r.values[a]=e.values[u]}return r},topKImplCPU=function(e,t,n,a,r){for(var i=t[t.length-1],o=__read([e.length/i,i],2),s=o[0],u=o[1],c=p.util.getTypedArrayFromDType(n,s*a),d=p.util.getTypedArrayFromDType("int32",s*a),l=0;l<s;l++)!function(t){var n=t*u,i=e.subarray(n,n+u),o=Array(i.length);i.forEach(function(e,t){return o[t]={value:e,index:t}}),a<o.length&&(function select$1(e,t,n,a){for(void 0===n&&(n=0),void 0===a&&(a=e.length-1);a>n;){if(a-n>600){var r=a-n+1,i=t-n+1,o=Math.log(r),s=.5*Math.exp(2*o/3),u=.5*Math.sqrt(o*s*(r-s)/r)*Math.sign(i-r/2),c=Math.max(n,Math.floor(t-i*s/r+u)),d=Math.min(a,Math.floor(t+(r-i)*s/r+u));select$1(e,t,c,d)}var l=e[t],h=n,f=a;for(p.util.swap(e,n,t),comparePair(e[a],l)>0&&p.util.swap(e,n,a);h<f;){for(p.util.swap(e,h,f),h++,f--;0>comparePair(e[h],l);)h+=1;for(;comparePair(e[f],l)>0;)f-=1}0===comparePair(e[n],l)?p.util.swap(e,n,f):(f+=1,p.util.swap(e,f,a)),f<=t&&(n=f+1),t<=f&&(a=f-1)}}(o,a),o=o.slice(0,a)),r&&o.sort(comparePair);for(var s=t*a,l=c.subarray(s,s+a),h=d.subarray(s,s+a),f=0;f<a;f++)l[f]=o[f].value,h[f]=o[f].index}(l);var h=t.slice();return h[h.length-1]=a,[p.buffer(h,n,c),p.buffer(h,"int32",d)]},transposeImplCPU=/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e,t,n,a,r){for(var i=t.length,o=p.util.sizeFromShape(t),s=p.util.computeStrides(t),u=p.util.computeStrides(r),c=p.util.getTypedArrayFromDType(n,p.util.sizeFromShape(r)),d=0;d<o;++d){for(var l=p.util.indexToLoc(d,i,s),h=Array(l.length),f=0;f<h.length;f++)h[f]=l[a[f]];c[p.util.locToIndex(h,i,u)]=e[d]}return c},en=unaryKernelFunc({opType:o.ABS,cpuKernelImpl:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){for(var t=new Float32Array(e.length),n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}}),ea={kernelName:p.Abs,backendName:"webgpu",kernelFunc:en},er=unaryKernelFunc({opType:o.ACOS}),ei={kernelName:p.Acos,backendName:"webgpu",kernelFunc:er},eo=unaryKernelFunc({opType:o.ACOSH}),es={kernelName:p.Acosh,backendName:"webgpu",kernelFunc:eo},eu=binaryKernelFunc({opType:i.ADD,cpuKernelImpl:M,supportsComplex:!0}),ec={kernelName:p.Add,backendName:"webgpu",kernelFunc:eu},ed=function(){function AddNPackedProgram(e){this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e[0],this.variableNames=e.map(function(e,t){return"T".concat(t)}),this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="addN"}return AddNPackedProgram.prototype.getUserCode=function(){var e=[];this.variableNames.forEach(function(t){e.push("let v".concat(t," = get").concat(t,"ByOutputCoords(coords);"))});var t=this.variableNames.map(function(e){return"v".concat(e)}).join(" + ");return"\n      ".concat(getMainHeaderString("index")," {\n        for (var i = 0; i < ").concat(this.workPerThread,"; i = i + 1) {\n          let flatIndex = index * ").concat(this.workPerThread," + i;\n          if (flatIndex < uniforms.size) {\n            let coords = getCoordsFromIndex(flatIndex);\n            ").concat(e.join("\n        "),"\n            setOutputAtIndex(flatIndex, ").concat(t,");\n          }\n        }\n      }\n    ")},AddNPackedProgram}(),ep={kernelName:p.AddN,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var t=e.inputs,n=e.backend;if(1===t.length)return identity({inputs:{x:t[0]},backend:n});var a=t.map(function(e){return e.dtype}).reduce(function(e,t){return p.upcastType(e,t)}),r=t.map(function(e){return e.shape}),i=new ed(r);return n.runWebGPUProgram(i,t,a)}},el=function(){function TransposeSharedProgram(e,t){this.variableNames=["A"],this.workgroupSize=[16,16,1];for(var n=Array(e.length),a=0;a<n.length;a++)n[a]=e[t[a]];this.outputShape=n,this.dispatchLayout={x:[0],y:[1]},this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize,[1,1,1]),this.shaderKey="transposeShared"}return TransposeSharedProgram.prototype.getUserCode=function(){var e=this;p.util.assert(this.workgroupSize[0]===this.workgroupSize[1],function(){return"Must be a square tile, current tile shape is ".concat(e.workgroupSize[0]," x ").concat(e.workgroupSize[1])});var t=this.workgroupSize[0];return"\n      var<workgroup> tile : array<array<f32, ".concat(this.workgroupSize[0]+1,">, ").concat(this.workgroupSize[0],">;\n      ").concat(getMainHeaderString()," {\n        var x = i32(workgroupId.x) * ").concat(t," + i32(localId.x);\n        var y = i32(workgroupId.y) * ").concat(t," + i32(localId.y);\n        let width = uniforms.outShape[0];\n        let height = uniforms.outShape[1];\n        if (x < width && y < height) {\n          tile[localId.y][localId.x] = f32(A[y * width + x]);\n        }\n        workgroupBarrier();\n\n        x = i32(workgroupId.y) * ").concat(t," + i32(localId.x);\n        y = i32(workgroupId.x) * ").concat(t," + i32(localId.y);\n        if (x < height && y < width) {\n          setOutputAtIndex((y * height + x), tile[localId.x]\n            [localId.y]);\n        }\n      }\n    ")},TransposeSharedProgram}(),eh=function(){function TransposeProgram(e,t){this.variableNames=["A"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0;for(var n=Array(e.length),a=0;a<n.length;a++)n[a]=e[t[a]];this.outputShape=n,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.newDim=t,this.shaderKey="transpose_".concat(t)}return TransposeProgram.prototype.getUserCode=function(){var e=getCoordsDataType(this.outputShape.length),t=getSwitchedCoords(this.newDim);return"\n      ".concat(getMainHeaderString("index")," {\n        for(var i = 0; i < ").concat(this.workPerThread,"; i = i + 1) {\n          let flatIndex = index * ").concat(this.workPerThread," + i;\n          if(flatIndex < uniforms.size) {\n            let coords = getCoordsFromIndex(flatIndex);\n            setOutputAtIndex(flatIndex, A[getIndexFromCoords").concat(this.outputShape.length,"D(\n              ").concat(e,"(").concat(t,"), uniforms.aShape)]);\n          }\n        }\n      }\n    ")},TransposeProgram}();function getSwitchedCoords(e){var t=e.length;if(t>6)throw Error("Transpose for rank ".concat(t," is not yet supported"));for(var n=Array(t),a=0;a<e.length;a++)n[e[a]]="coords.".concat(getCoordsXYZ(a));return n.join()}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function transpose(e){for(var t=e.inputs,n=e.backend,a=e.attrs,r=t.x,i=a.perm,o=Array(r.shape.length),s=0;s<o.length;s++)o[s]=r.shape[i[s]];if(n.shouldExecuteOnCPU([r])){var u=transposeImplCPU(n.tensorMap.get(r.dataId).values,r.shape,r.dtype,i,o);return n.makeTensorInfo(o,r.dtype,u)}if(2===r.shape.length&&p.util.arraysEqual(i,[1,0])){var c=new el(r.shape,i);return n.runWebGPUProgram(c,[r],r.dtype)}var d=new eh(r.shape,i);return n.runWebGPUProgram(d,[r],r.dtype)}var ef={kernelName:p.Transpose,backendName:"webgpu",kernelFunc:transpose},em=function(){function ReduceProgram(e,t,n){this.variableNames=["x"],this.uniforms="reduceSize : i32,",this.size=!0,this.inputShape=[e.batchSize,e.inSize];var a=__read(p.backend_util.computeOutAndReduceShapes(this.inputShape,[1]),1)[0];this.outputShape=0===a.length?[1]:a,e.inSize>=32768&&n>=512?this.workgroupSize=[512,1,1]:e.inSize>=4096?this.workgroupSize=[256,1,1]:this.workgroupSize=[64,1,1],this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,[1,1,1]),this.reduceType=t,this.shaderKey="reduce_".concat(t)}return ReduceProgram.prototype.getUserCode=function(){var e="",t="0.0",n=this.workgroupSize[0];"min"===this.reduceType||"max"===this.reduceType?(e="\n         if (isnan(candidate)) {\n          bestValue = uniforms.NAN;\n         } else if (!isnan(bestValue) && candidate ".concat("min"===this.reduceType?"<":">"," bestValue)\n           {  bestValue = candidate; }"),t="f32(x[offset])"):"sum"===this.reduceType||"mean"===this.reduceType?e=" bestValue = bestValue + candidate; ":"prod"===this.reduceType?(e=" bestValue = bestValue * candidate; ",t="1.0"):"all"===this.reduceType?(e=" bestValue = f32(bestValue >= 1.0 && candidate >= 1.0); ",t="1.0"):"any"===this.reduceType&&(e=" bestValue = f32(bestValue >= 1.0 || candidate >= 1.0); ",t="0.0");var a="mean"===this.reduceType?"setOutputAtIndex(outputIndex, bestValue / f32(uniforms.reduceSize));":"setOutputAtIndex(outputIndex, bestValue);",r="\n         var<workgroup> xBestValues : array<f32, ".concat(n,">;\n       ");return"\n       fn DIV_CEIL(a : u32, b : u32) -> u32 {\n        return ((a - 1u) / b + 1u);\n       }\n\n       ".concat(r,"\n       fn getOffset(outputIndex : i32) -> i32 {\n         let outputCoords = getCoordsFromIndex(outputIndex);\n         let offset = ").concat(1===this.outputShape.length?"outputCoords":"outputCoords[0]"," * uniforms.reduceSize;\n          return offset;\n       }\n       ").concat(getMainHeaderString("index")," {\n         let outputIndex = index / ").concat(n,";\n         let offset = getOffset(outputIndex);\n         var bestValue = ").concat(t,";\n         let Length = uniforms.reduceSize;\n         let WorkPerThread = DIV_CEIL(u32(Length), ").concat(n,"u);\n         for (var k = i32(localId.x); k < Length && outputIndex < uniforms.size;\n             k = k + ").concat(n,") {\n           let candidate = f32(x[offset + k]);\n           ").concat(e,"\n         }\n         xBestValues[localId.x] = bestValue;\n         workgroupBarrier();\n\n         var reduceSize = min(u32(Length), ").concat(n,"u);\n         for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n             currentSize = reduceSize / 2u) {\n           let interval = DIV_CEIL(reduceSize, 2u);\n           if (localId.x < currentSize) {\n            let candidate = xBestValues[localId.x + interval];\n            ").concat(e,"\n            xBestValues[localId.x] = bestValue;\n           }\n           reduceSize = interval;\n           workgroupBarrier();\n         }\n\n         if (localId.x == 0u && outputIndex < uniforms.size) {\n          ").concat(a,"\n        }\n       }\n     ")},ReduceProgram}(),eg={mean:"float32",all:"bool",any:"bool"};function reduce(e,t,n,a,r){var i,o=e.shape.length,s=[],u=p.util.parseAxisParam(t,e.shape),c=u,d=p.backend_util.getAxesPermutation(c,o),l=e;null!=d&&(l=transpose({inputs:{x:e},attrs:{perm:d},backend:r}),c=p.backend_util.getInnerMostAxes(c.length,o),s.push(l)),p.backend_util.assertAxesAreInnerMostDims(a,c,o);var h=__read(p.backend_util.computeOutAndReduceShapes(l.shape,c),2),f=h[0],m=h[1],g=f;if(n&&(g=p.backend_util.expandShapeToKeepDim(f,u)),("max"===a||"prod"===a)&&r.shouldExecuteOnCPU([l])){var y=r.tensorMap.get(l.dataId).values;switch(a){case"max":var v=maxImplCPU(y,p.util.sizeFromShape(m),g,e.dtype);i=r.makeTensorInfo(g,e.dtype,v);break;case"prod":var x=prodImplCPU(l.shape,l.dtype,y,c),b=x.outVals,S=x.outShape,w=x.outDtype;i=r.makeTensorInfo(S,w,b);break;default:throw Error("".concat(a," CPU implementation is not yet supported."))}}else{var C=p.util.sizeFromShape(m),k=p.util.sizeFromShape(l.shape)/C,I=eg[a]||p.sumOutType(e.dtype),P=new em({windowSize:C,inSize:C,batchSize:k,outSize:1},a,r.device.limits.maxComputeWorkgroupSizeX),R=r.runWebGPUProgram(P,[l],I,[{type:"int32",data:[C]}]);s.push(R),i=reshape({inputs:{x:R},attrs:{shape:g},backend:r})}return s.forEach(function(e){return r.disposeData(e.dataId)}),i}var ey={kernelName:p.All,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var t=e.inputs,n=e.backend,a=e.attrs,r=t.x,i=a.keepDims;return reduce(r,a.axis,i,"all",n)}},ev={kernelName:p.Any,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var t=e.inputs,n=e.backend,a=e.attrs,r=t.x,i=a.keepDims;return reduce(r,a.axis,i,"any",n)}},ex=function(){function ArgMinMaxProgram(e,t,n){this.workgroupSize=[64,1,1],this.variableNames=["x"],this.uniforms="infinityValue : f32,",this.size=!0;var a=[t];this.op="min"===n?"<":">";var r=__read(p.backend_util.computeOutAndReduceShapes(e,a),2),i=r[0],o=r[1];this.outputShape=0===i.length?[1]:i,this.dispatchLayout=flatDispatchLayout(this.outputShape),32>p.util.sizeFromShape(o)?(this.type="plain",this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize)):(this.type="shared",this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,[1,1,1])),this.inputShape=e,this.shaderKey="argMinMax_".concat(this.op,"_").concat(this.type)}return ArgMinMaxProgram.prototype.getUserCode=function(){var e=this,t=this.workgroupSize[0],getInputShapeLastDim=function(){return 1===e.inputShape.length?"uniforms.xShape":"uniforms.xShape.".concat(getCoordsXYZ(e.inputShape.length-1))},splitOutputCoords=function(){var t="";if(1===e.outputShape.length)1!==e.inputShape.length&&(t+="outputCoords,");else for(var n=0;n<e.outputShape.length;n++)t+="outputCoords.".concat(getCoordsXYZ(n),",");return t};if("shared"===this.type){var n="\n      var<workgroup> xBestIndices : array<i32, ".concat(t,">;\n      var<workgroup> xBestValues : array<f32, ").concat(t,">;\n    "),a="\n      fn DIV_CEIL(a : u32, b : u32) -> u32 {\n        return ((a - 1u) / b + 1u);\n      }\n\n      ".concat(n,"\n\n      ").concat(getMainHeaderString("index")," {\n        let outputIndex = index / ").concat(t,";\n        let reduceLength = ").concat(getInputShapeLastDim(),";\n\n        var bestIndex = i32(localId.x);\n        var bestValue = uniforms.infinityValue;\n        let outputCoords = getCoordsFromIndex(outputIndex);\n        for (var k = i32(localId.x); k < reduceLength && outputIndex < uniforms.size;\n            k = k + ").concat(t,") {\n          let candidate = getX(").concat(splitOutputCoords()," k);\n          if (!isnan(candidate) && candidate ").concat(this.op," bestValue) {\n            bestValue = candidate;\n            bestIndex = k;\n          }\n        }\n        xBestValues[localId.x] = bestValue;\n        xBestIndices[localId.x] = bestIndex;\n        workgroupBarrier();\n\n        var reduceSize = min(u32(reduceLength), ").concat(t,"u);\n        for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n            currentSize = reduceSize / 2u) {\n          let interval = DIV_CEIL(reduceSize, 2u);\n          if (localId.x < currentSize) {\n            let candidate = xBestValues[localId.x + interval];\n            if (candidate ").concat(this.op," bestValue) {\n              bestValue = candidate;\n              xBestValues[localId.x] = bestValue;\n              xBestIndices[localId.x] = xBestIndices[localId.x + interval];\n            }\n          }\n          reduceSize = interval;\n          workgroupBarrier();\n        }\n\n        if (localId.x == 0u && outputIndex < uniforms.size) {\n          setOutputAtIndexI32(outputIndex, xBestIndices[localId.x]);\n        }\n      }\n    ");return a}var a="\n      ".concat(getMainHeaderString("index")," {\n        if (index < uniforms.size) {\n          let outputCoords = getCoordsFromIndex(index);\n          var bestIndex = 0;\n          var bestValue = getX(").concat(splitOutputCoords()," 0);\n          let reduceLength = ").concat(getInputShapeLastDim(),";\n          for (var i = 1; i < reduceLength; i++) {\n            let candidate = getX(").concat(splitOutputCoords()," i);\n            if (candidate ").concat(this.op," bestValue) {\n              bestValue = candidate;\n              bestIndex = i;\n            }\n          }\n          setOutputAtIndexI32(index, bestIndex);\n        }\n      }\n      ");return a},ArgMinMaxProgram}(),eb={kernelName:p.ArgMax,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var t=e.inputs,n=e.backend,a=e.attrs,r=t.x,i=a.axis,o=p.util.parseAxisParam(i,r.shape),s=p.backend_util.getAxesPermutation(o,r.shape.length),u=r,c=[];null!=s&&(c.push(u=transpose({inputs:{x:r},backend:n,attrs:{perm:s}})),o=p.backend_util.getInnerMostAxes(o.length,u.shape.length)),p.backend_util.assertAxesAreInnerMostDims("argMax",[o[0]],u.shape.length);var d=new ex(u.shape,o[0],"max"),l=[{type:"float32",data:[Number.NEGATIVE_INFINITY]}],h=n.runWebGPUProgram(d,[u],"int32",l);return c.forEach(function(e){return n.disposeData(e.dataId)}),h}},eS={kernelName:p.ArgMin,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var t=e.inputs,n=e.backend,a=e.attrs,r=t.x,i=a.axis,o=p.util.parseAxisParam(i,r.shape),s=p.backend_util.getAxesPermutation(o,r.shape.length),u=r,c=[];null!=s&&(c.push(u=transpose({inputs:{x:r},backend:n,attrs:{perm:s}})),o=p.backend_util.getInnerMostAxes(o.length,u.shape.length)),p.backend_util.assertAxesAreInnerMostDims("argMin",[o[0]],u.shape.length);var d=new ex(u.shape,o[0],"min"),l=[{type:"float32",data:[Number.POSITIVE_INFINITY]}],h=n.runWebGPUProgram(d,[u],"int32",l);return c.forEach(function(e){return n.disposeData(e.dataId)}),h}},ew=unaryKernelFunc({opType:o.ASIN}),eC={kernelName:p.Asin,backendName:"webgpu",kernelFunc:ew},ek=unaryKernelFunc({opType:o.ASINH}),eI={kernelName:p.Asinh,backendName:"webgpu",kernelFunc:ek},eP=unaryKernelFunc({opType:o.ATAN}),eR={kernelName:p.Atan,backendName:"webgpu",kernelFunc:eP},eD=binaryKernelFunc({opType:i.ATAN2}),e_={kernelName:p.Atan2,backendName:"webgpu",kernelFunc:eD},eA=unaryKernelFunc({opType:o.ATANH}),ez={kernelName:p.Atanh,backendName:"webgpu",kernelFunc:eA},eN=function(){function PoolWithFilterSizeEqualsOneProgram(e){this.variableNames=["x"],this.uniforms="strides : vec2<i32>,",this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="poolWithFilterSizeEqualsOne"}return PoolWithFilterSizeEqualsOneProgram.prototype.getUserCode=function(){return"\n      ".concat(getMainHeaderString("index")," {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let batch = coords[0];\n          let d = coords[3];\n\n          let xRCCorner = coords.yz * uniforms.strides;\n          let xRCorner = xRCCorner.x;\n          let xCCorner = xRCCorner.y;\n\n          let value = getX(batch, xRCorner, xCCorner, d);\n          setOutputAtIndex(index, value);\n        }\n      }\n    ")},PoolWithFilterSizeEqualsOneProgram}(),eF=function(){function Pool2DProgram(e,t,n,a,r){if(void 0===n&&(n=!1),void 0===a&&(a=!1),void 0===r&&(r=!1),this.variableNames=["x"],this.uniforms="strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, convDims : vec2<i32>, filterDims : vec2<i32>,",this.workgroupSize=[128,1,1],this.size=!0,"avg"===t&&n)throw Error("Cannot compute positions for average pool.");this.outputShape=e.outShape,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.poolType=t,this.computePositions=n,this.flattenPositions=a,this.includeBatchIndex=r,this.shaderKey="pool2D_".concat(t,"_").concat(n,"_").concat(a,"_").concat(r)}return Pool2DProgram.prototype.getUserCode=function(){if("avg"===this.poolType)e="resultValue = resultValue + value; count = count + 1.0;";else if(this.computePositions){var e,t=this.flattenPositions?this.includeBatchIndex?"((batch * uniforms.xShape[1] + xR) * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d":"(xR * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d":"wR * uniforms.filterDims.y + wC";e="let currMaxValue = mix(value, maxValue, maxValueFound);\n      if (value >= currMaxValue) {\n        maxValue = value;\n        maxValueFound = 1.0;\n        maxPosition = ".concat(t,";\n      }")}else e="resultValue = max(value, resultValue);";var n="resultValue";return"avg"===this.poolType&&(n="resultValue / max(count, 1.0)"),"\n      ".concat(getMainHeaderString("index")," {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n          let batch = coords[0];\n          let d = coords[3];\n          let xRCCorner = vec2<i32>(coords.yz) * uniforms.strides - uniforms.pads;\n          let xRCorner = xRCCorner.x;\n          let xCCorner = xRCCorner.y;\n\n          ").concat(this.computePositions?"var maxValue = 0.0;\n            var maxValueFound = 0.0;\n            var maxPosition = 0;":"var resultValue = ".concat("avg"===this.poolType?"0.0":"-1.0 / pow(10.0, -20.0)",";"),"\n\n          var count = 0.0;\n          for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + uniforms.dilations.x) {\n            let xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= uniforms.convDims.x) {\n              continue;\n            }\n\n            for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + uniforms.dilations.y) {\n              let xC = xCCorner + wC;\n              if (xC < 0 || xC >= uniforms.convDims.y) {\n                continue;\n              }\n\n              let value = getX(batch, xR, xC, d);\n              ").concat(e,"\n            }\n          }\n\n          ").concat(this.computePositions?"setOutputAtIndexI32(index, maxPosition);":"setOutputAtIndex(index, ".concat(n,");"),"\n        }\n      }\n    ")},Pool2DProgram}(),eT=function(){function Pool3DProgram(e,t,n,a,r){if(void 0===n&&(n=!1),void 0===a&&(a=!1),void 0===r&&(r=!1),this.variableNames=["x"],this.uniforms="strides : vec3<i32>, pads : vec3<i32>, convDims : vec3<i32>, filterDims : vec3<i32>,",this.workgroupSize=[128,1,1],this.size=!0,"avg"===t&&n)throw Error("Cannot compute positions for average pool.");this.outputShape=e.outShape,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.poolType=t,this.computePositions=n,this.flattenPositions=a,this.includeBatchIndex=r,this.shaderKey="pool3D_".concat(t,"_").concat(n,"_").concat(a,"_").concat(r)}return Pool3DProgram.prototype.getUserCode=function(){if("avg"===this.poolType)e="resultValue += value; count += 1.0;";else if(this.computePositions){var e,t=this.flattenPositions?this.includeBatchIndex?"(((batch * uniforms.xShape.y + xD) * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch":"((xD * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch":"wD * uniforms.filterDims.y * uniforms.filterDims.y + wR * uniforms.filterDims.z + wC";e="let currMaxValue = mix(value, maxValue, maxValueFound);\n      if (value >= currMaxValue) {\n        maxValue = value;\n        maxValueFound = 1.0;\n        maxPosition = ".concat(t,";\n      }")}else e="resultValue = max(value, resultValue);";var n="resultValue";return"avg"===this.poolType&&(n="resultValue / max(count, 1.0)"),"\n      ".concat(getMainHeaderString("index")," {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let batch = coords.x;\n          let ch = coords.u;\n\n          let xCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;\n          let xDCorner = xCorner.x;\n          let xRCorner = xCorner.y;\n          let xCCorner = xCorner.z;\n\n          ").concat(this.computePositions?"var maxValue = 0.0;\n            var maxValueFound = 0.0;\n            var maxPosition = 0;":"var resultValue = ".concat("avg"===this.poolType?"0.0":"-1.0 / pow(10.0, -20.0)",";"),"\n\n          var count = 0.0;\n          for (var wD = 0; wD < uniforms.filterDims.x; wD++) {\n            let xD = xDCorner + wD;\n            if (xD < 0 || xD >= uniforms.convDims.x) {\n              continue;\n            }\n\n            for (var wR = 0; wR < uniforms.filterDims.y; wR++) {\n              let xR = xRCorner + wR;\n              if (xR < 0 || xR >= uniforms.convDims.y) {\n                continue;\n              }\n\n              for (var wC = 0; wC < uniforms.filterDims.z; wC++) {\n                let xC = xCCorner + wC;\n                if (xC < 0 || xC >= uniforms.convDims.z) {\n                  continue;\n                }\n\n                let value = getX(batch, xD, xR, xC, ch);\n                ").concat(e,"\n              }\n            }\n          }\n\n          ").concat(this.computePositions?"setOutputAtIndexI32(index, maxPosition);":"setOutputAtIndex(index, ".concat(n,");"),"\n        }\n      }\n    ")},Pool3DProgram}();/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function max(e){var t=e.inputs,n=e.backend,a=e.attrs;return reduce(t.x,a.reductionIndices,a.keepDims,"max",n)}var eB={kernelName:p.Max,backendName:"webgpu",kernelFunc:max};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mean(e){var t=e.inputs,n=e.backend,a=e.attrs,r=t.x,i=a.keepDims;return reduce(r,a.axis,i,"mean",n)}var eL={kernelName:p.Mean,backendName:"webgpu",kernelFunc:mean};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function poolImpl(e,t,n,a){if(1===t.filterWidth&&1===t.filterHeight&&p.util.arraysEqual(t.inShape,t.outShape))return identity({inputs:{x:e},backend:a});if(t.filterWidth===t.inWidth&&t.filterHeight===t.inHeight&&1===t.batchSize&&"VALID"===t.padInfo.type){var r,i=e.shape.length,o=reshape({inputs:{x:e},backend:a,attrs:{shape:[e.shape[i-3]*e.shape[i-2],e.shape[i-1]]}}),s=void 0;"avg"===n?s=mean({inputs:{x:o},backend:a,attrs:{axis:0,keepDims:!1}}):(p.util.assert("max"===n,function(){return"Invalid pool type ".concat(n)}),s=max({inputs:{x:o},backend:a,attrs:{reductionIndices:0,keepDims:!1}}));var u=reshape({inputs:{x:s},backend:a,attrs:{shape:t.outShape}});return a.disposeData(o.dataId),a.disposeData(s.dataId),u}var c=[{type:"int32",data:[t.strideHeight,t.strideWidth]}];return 1===t.filterHeight&&1===t.filterWidth?r=new eN(t):("avg"===n?r=new eF(t,"avg"):(p.util.assert("max"===n,function(){return"Invalid pool type ".concat(n)}),r=new eF(t,"max")),c.push({type:"int32",data:[t.padInfo.top,t.padInfo.left]},{type:"int32",data:[t.dilationHeight,t.dilationWidth]},{type:"int32",data:[t.inHeight,t.inWidth]},{type:"int32",data:[t.effectiveFilterHeight,t.effectiveFilterWidth]})),a.runWebGPUProgram(r,[e],e.dtype,c)}var eM={kernelName:p.AvgPool,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var t=e.inputs,n=e.backend,a=e.attrs,r=t.x,i=a.filterSize,o=a.strides,s=a.pad,u=a.dimRoundingMode,c=p.backend_util.computePool2DInfo(r.shape,i,o,1,s,u);return poolImpl(r,c,"avg",n)}},eW={kernelName:p.AvgPool3D,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var t=e.inputs,n=e.backend,a=e.attrs,r=t.x,i=a.filterSize,o=a.strides,s=a.pad,u=a.dataFormat,c=a.dimRoundingMode,d=p.backend_util.computePool3DInfo(r.shape,i,o,[1,1,1],s,c,u),l=new eT(d,"avg"),h=[{type:"int32",data:[d.strideDepth,d.strideHeight,d.strideWidth]},{type:"int32",data:[d.padInfo.front,d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.inDepth,d.inHeight,d.inWidth]},{type:"int32",data:[d.effectiveFilterDepth,d.effectiveFilterHeight,d.effectiveFilterWidth]}];return n.runWebGPUProgram(l,[r],r.dtype,h)}},eU=function(){function AvgPool2DBackpropProgram(e){this.variableNames=["dy"],this.uniforms="strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,\n       outHeight : i32, outWidth : i32, avgMultiplier : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avgPool2DBackprop"}return AvgPool2DBackpropProgram.prototype.getUserCode=function(){return"\n      ".concat(getMainHeaderString("index")," {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords[0];\n        let d = coords[3];\n\n        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;\n        let dyRCorner = dyRCCorner.x;\n        let dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        for (var wR = 0; wR < uniforms.filterDims[0]; wR = wR + uniforms.dilations[0]) {\n          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);\n\n          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {\n            continue;\n          }\n          let idyR = i32(dyR);\n\n          for (var wC = 0; wC < uniforms.filterDims[1]; wC = wC + uniforms.dilations[1]) {\n            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);\n\n            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {\n              continue;\n            }\n            let idyC = i32(dyC);\n\n            let dyValue = getDy(batch, idyR, idyC, d);\n\n            dotProd = dotProd + dyValue * uniforms.avgMultiplier;\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n    ")},AvgPool2DBackpropProgram}(),eE=function(){function AvgPool3DBackpropProgram(e){this.variableNames=["dy"],this.uniforms="strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,\n       outDepth : i32, outHeight : i32, outWidth : i32, avgMultiplier : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avgPool3DBackprop"}return AvgPool3DBackpropProgram.prototype.getUserCode=function(){return"\n      ".concat(getMainHeaderString("index")," {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords.x;\n        let ch = coords.u;\n\n        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;\n        let dyDCorner = dyCorner.x;\n        let dyRCorner = dyCorner.y;\n        let dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {\n          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);\n\n          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {\n            continue;\n          }\n          let idyD = i32(dyD);\n\n          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {\n            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);\n\n            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {\n              continue;\n            }\n            let idyR = i32(dyR);\n\n            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {\n              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);\n\n              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {\n                continue;\n              }\n              let idyC = i32(dyC);\n\n              let dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              dotProd += dyValue * uniforms.avgMultiplier;\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n    ")},AvgPool3DBackpropProgram}(),eO={kernelName:p.AvgPool3DGrad,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var t=e.inputs,n=e.backend,a=e.attrs,r=t.dy,i=t.input,o=a.filterSize,s=a.strides,u=a.pad,c=a.dimRoundingMode,d=p.backend_util.computePool3DInfo(i.shape,o,s,1,u,c),l=new eE(d),h=1/(d.filterDepth*d.filterHeight*d.filterWidth),f=[{type:"int32",data:[d.strideDepth,d.strideHeight,d.strideWidth]},{type:"int32",data:[d.effectiveFilterDepth-1-d.padInfo.front,d.effectiveFilterHeight-1-d.padInfo.top,d.effectiveFilterWidth-1-d.padInfo.left]},{type:"int32",data:[d.effectiveFilterDepth,d.effectiveFilterHeight,d.effectiveFilterWidth]},{type:"int32",data:[d.outDepth]},{type:"int32",data:[d.outHeight]},{type:"int32",data:[d.outWidth]},{type:"float32",data:[h]}];return n.runWebGPUProgram(l,[r],i.dtype,f)}},eV={kernelName:p.AvgPoolGrad,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var t=e.inputs,n=e.backend,a=e.attrs,r=t.dy,i=t.input;assertNotComplex([r,i],"avgPoolGrad");var o=a.filterSize,s=a.strides,u=a.pad,c=p.backend_util.computePool2DInfo(i.shape,o,s,1,u),d=new eU(c),l=1/(c.filterHeight*c.filterWidth),h=[{type:"int32",data:[c.strideHeight,c.strideWidth]},{type:"int32",data:[c.effectiveFilterHeight-1-c.padInfo.top,c.effectiveFilterWidth-1-c.padInfo.left]},{type:"int32",data:[c.dilationHeight,c.dilationWidth]},{type:"int32",data:[c.effectiveFilterHeight,c.effectiveFilterWidth]},{type:"int32",data:[c.outHeight]},{type:"int32",data:[c.outWidth]},{type:"float32",data:[l]}];return n.runWebGPUProgram(d,[r],i.dtype,h)}},eG={kernelName:p.BatchMatMul,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var t=e.inputs,n=e.backend,a=e.attrs;return batchMatMulImpl({a:t.a,b:t.b,transposeA:a.transposeA,transposeB:a.transposeB,backend:n})}},eH=function(){function SliceProgram(e,t){this.variableNames=["source"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.rank=t.length,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.start=e,this.uniforms="start : ".concat(getCoordsDataType(e.length),", "),this.shaderKey="slice"}return SliceProgram.prototype.getUserCode=function(){var e,t=getCoordsDataType(this.rank),n=function(e){if(1===e)return"sourceLoc";if(e<=6)return eK.slice(0,e).map(function(e){return"sourceLoc.".concat(e)}).join(",");throw Error("Slicing for rank ".concat(e," is not yet supported"))}(this.rank);return e=1===this.start.length?this.outputShape.map(function(e,t){return"sourceLoc = uniforms.start + coords;"}):this.outputShape.map(function(e,t){return"sourceLoc.".concat(eK[t]," = uniforms.start.").concat(getCoordsXYZ(t)," + coords.").concat(eK[t],";")}),"\n      ".concat(getMainHeaderString("index")," {\n        if (index < uniforms.size) {\n          var sourceLoc : ").concat(t,";\n          let coords = getCoordsFromIndex(index);\n          ").concat(e.join("\n"),"\n          setOutputAtIndex(index, getSource(").concat(n,"));\n        }\n      }\n    ")},SliceProgram}(),eK=["x","y","z","w","u","v"];function slice(e){var t=e.inputs,n=e.backend,a=e.attrs,r=t.x,i=a.begin,o=a.size,s=__read(p.slice_util.parseSliceParams(r,i,o),2),u=s[0],c=s[1];if(p.slice_util.assertParamsValid(r,u,c),n.shouldExecuteOnCPU([r])||"string"===r.dtype){var d=sliceImplCPU(n.tensorMap.get(r.dataId).values,u,c,r.shape,r.dtype);return n.makeTensorInfo(c,r.dtype,d)}if(0===p.util.sizeFromShape(c))return n.makeTensorInfo(c,r.dtype,[]);var l=new eH(u,c),h=[{type:"int32",data:u}];return n.runWebGPUProgram(l,[r],r.dtype,h)}var eX={kernelName:p.Slice,backendName:"webgpu",kernelFunc:slice},eq={kernelName:p.BatchToSpaceND,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,a=e.attrs,r=t.x,i=a.blockShape,o=a.crops;p.util.assert(r.shape.length<=4,function(){return"batchToSpaceND for rank > 4 with a WebGPU backend not implemented yet"});var s=i.reduce(function(e,t){return e*t}),u=p.backend_util.getReshaped(r.shape,i,s),c=p.backend_util.getPermuted(u.length,i.length),d=p.backend_util.getReshapedPermuted(r.shape,i,s),l=p.backend_util.getSliceBeginCoords(o,i.length),h=p.backend_util.getSliceSize(d,o,i.length),f=[],m=reshape({inputs:{x:r},backend:n,attrs:{shape:u}}),g=transpose({inputs:{x:m},backend:n,attrs:{perm:c}}),y=reshape({inputs:{x:g},backend:n,attrs:{shape:d}}),v=slice({inputs:{x:y},backend:n,attrs:{begin:l,size:h}});return f.push(m),f.push(g),f.push(y),f.forEach(function(e){return n.disposeData(e.dataId)}),v}},eY="\n  fn bincount_write(index: i32, value: f32) {\n    ".concat(atomicAddSnippet("&result[index]","value","float32"),"\n  }\n"),ej=function(){function BincountProgram(e,t,n){void 0===n&&(n=!1),this.outputShape=[],this.variableNames=["x"],this.uniforms="binCountSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.hasWeights=!0,this.binaryOutput=!1,this.outputShape=e,this.rank=e.length,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.binaryOutput=n,n&&(this.atomic=!1),this.hasWeights=t,this.hasWeights&&this.variableNames.push("w"),this.shaderKey="bincount_".concat(this.hasWeights,"_").concat(this.binaryOutput,"_").concat(this.rank)}return BincountProgram.prototype.getUserCode=function(){return"\n    ".concat(this.binaryOutput?"\n  fn bincount_write(index: i32, value: f32) {\n    atomicStore(&result[index], bitcast<i32>(value));\n  }\n":eY,"\n  ").concat(getMainHeaderString("index")," {\n    ").concat(1===this.rank?"if (index < uniforms.xShape) {\n      let indexVal = i32(getX(index));\n      if (indexVal < uniforms.binCountSize) {\n        let value = ".concat(this.binaryOutput?1:this.hasWeights?"getW(index)":"1.",";\n        bincount_write(indexVal, value);\n      }\n    }"):"let coord = getCoordsFromIndex(index);\n    if (coordsInBounds2D(coord, uniforms.xShape)) {\n      let indexVal = i32(getX(coord[0], coord[1]));\n      if (indexVal < uniforms.binCountSize) {\n        let value = ".concat(this.binaryOutput?1:this.hasWeights?"getW(coord[0], coord[1])":"1.",";\n        bincount_write(coord.x * uniforms.binCountSize + indexVal, value);\n      }\n    }"),"\n  }\n  ")},BincountProgram}(),eQ={kernelName:p.Bincount,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var t=e.inputs,n=e.backend,a=e.attrs,r=t.x,i=t.weights,o=a.size,s=p.util.sizeFromShape(r.shape),u=p.util.sizeFromShape(i.shape)>0,c=[o],d=i.dtype,l=fill({backend:n,attrs:{shape:c,value:0,dtype:d}}),h=new ej([s],u),f=[{type:"int32",data:[o]}],m=u?[r,i]:[r];return n.runWebGPUProgram(h,m,d,f,l)}},eZ=function(){function BroadcastArgsProgram(e){this.outputShape=[],this.variableNames=["s0","s1"],this.uniforms="s0Size : i32, s1Size : i32, ",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e],this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="broadcastArgs"}return BroadcastArgsProgram.prototype.getUserCode=function(){return"\n  ".concat(getMainHeaderString("index")," {\n    if (index < uniforms.size) {\n      var s0 = 1.0;\n      var s1 = 1.0;\n      let indexS0 = index - uniforms.size + uniforms.s0Size;\n      let indexS1 = index - uniforms.size + uniforms.s1Size;\n      if (indexS0 >= 0) {\n        s0 = getS0(indexS0);\n      }\n      if (indexS1 >= 0) {\n        s1 = getS1(indexS1);\n      }\n\n      if (s0 == 1.0) {\n        setOutputAtIndex(index, s1);\n      } else if (s1 == 1.0) {\n        setOutputAtIndex(index, s0);\n      } else if (s0 != s1) {\n        setOutputAtIndex(index, uniforms.NAN);\n      } else {\n        setOutputAtIndex(index, s0);\n      }\n    }\n  }\n  ")},BroadcastArgsProgram}(),e$={kernelName:p.BroadcastArgs,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var t=e.inputs,n=e.backend,a=t.s0,r=t.s1;if(n.shouldExecuteOnCPU([a,r])){var i=n.tensorMap.get(a.dataId),o=n.tensorMap.get(r.dataId),s=i.values,u=o.values,c=p.backend_util.assertAndGetBroadcastShape(Array.from(s),Array.from(u));return n.makeTensorInfo([c.length],"int32",Int32Array.from(c))}var d=p.util.sizeFromShape(a.shape),l=p.util.sizeFromShape(r.shape),h=Math.max(d,l),f=new eZ(h),m=[{type:"int32",data:[d]},{type:"int32",data:[l]}];return n.runWebGPUProgram(f,[a,r],"int32",m)}},eJ=binaryKernelFunc({opType:i.NOT_EQUAL,dtype:"bool",cpuKernelImpl:$}),e2={kernelName:p.NotEqual,backendName:"webgpu",kernelFunc:eJ};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function real(e){var t=e.inputs,n=e.backend,a=t.input;return identity({inputs:{x:n.tensorMap.get(a.dataId).complexTensorInfos.real},backend:n})}var e0={kernelName:p.Real,backendName:"webgpu",kernelFunc:real},e1={kernelName:p.Cast,backendName:"webgpu",kernelFunc:function cast(e){var t,n,a=e.inputs,r=e.backend,i=e.attrs,s=a.x,u=i.dtype;if("complex64"===u){if("complex64"===s.dtype)return identity({inputs:{x:s},backend:r});var c=l.zeros(s.shape),d=cast({inputs:{x:s},backend:r,attrs:{dtype:"float32"}}),h=complex({inputs:{real:d,imag:c},backend:r});return c.dispose(),r.disposeData(d.dataId),h}if("complex64"===s.dtype){var f=real({inputs:{input:s},backend:r}),h=cast({inputs:{x:f},backend:r,attrs:{dtype:u}});return r.disposeData(f.dataId),h}if(!p.util.hasEncodingLoss(s.dtype,u)){var h=identity({inputs:{x:s},backend:r});return{dataId:h.dataId,shape:h.shape,dtype:u}}if(r.shouldExecuteOnCPU([s])){var m=__read(castImplCPU(r.tensorMap.get(s.dataId).values,s.shape,s.dtype,u),3),g=m[0],y=m[1],v=m[2];return r.makeTensorInfo(g,y,v)}if("int32"===u)return t=new L(s.shape,o.TO_INT),{dataId:(n=r.runWebGPUProgram(t,[s],"int32")).dataId,shape:n.shape,dtype:n.dtype};if("bool"===u){var x=r.makeTensorInfo([],"bool",p.util.getTypedArrayFromDType("bool",1)),h=eJ({inputs:{a:s,b:x},backend:r});return r.disposeData(x.dataId),h}throw Error("Error in Cast: failed to cast ".concat(s.dtype," to ").concat(u))}},e3=unaryKernelFunc({opType:o.CEIL,cpuKernelImpl:W}),e4={kernelName:p.Ceil,backendName:"webgpu",kernelFunc:e3},e6=function(){function ClipVec4Program(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workPerThread=4,this.workgroupSize=[64,1,1],this.outputComponent=4,this.size=!0,this.outputShape=e,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="clipVec4"}return ClipVec4Program.prototype.getUserCode=function(){return"\n      ".concat(getMainHeaderString("index")," {\n        if(index < uniforms.size) {\n          let value = getAByOutputIndex(index);\n          var clampedValue = clamp(\n              value, vec4<f32>(uniforms.minVal), vec4<f32>(uniforms.maxVal));\n          clampedValue = select(clampedValue, value, isnanVec4(value));\n          setOutputAtIndex(index, clampedValue);\n        }\n      }\n    ")},ClipVec4Program}(),e5=function(){function ClipProgram(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="clip"}return ClipProgram.prototype.getUserCode=function(){return"\n      ".concat(getMainHeaderString("index")," {\n        if(index < uniforms.size) {\n          let value = getAByOutputIndex(index);\n          if (isnan(value)) {\n            setOutputAtIndex(index, value);\n            return;\n          }\n          setOutputAtIndex(index, clamp(value, uniforms.minVal, uniforms.maxVal));\n        }\n      }\n    ")},ClipProgram}(),e8={kernelName:p.ClipByValue,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var t,n=e.inputs,a=e.backend,r=e.attrs,i=n.x,o=[{type:"float32",data:[r.clipValueMin]},{type:"float32",data:[r.clipValueMax]}];return t=p.util.sizeFromShape(i.shape)%4==0?new e6(i.shape):new e5(i.shape),a.runWebGPUProgram(t,[i],i.dtype,o)}},e9=function(){function ComplexAbsProgram(e){this.outputShape=[],this.variableNames=["real","imag"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="complexAbs"}return ComplexAbsProgram.prototype.getUserCode=function(){return"\n    ".concat(getMainHeaderString("index")," {\n      if (index < uniforms.size) {\n        let re = abs(getRealByOutputIndex(index));\n        let im = abs(getImagByOutputIndex(index));\n        let mx = max(re, im);\n\n        // The length function in wgsl may be not underflow-safe on some GPUs.\n        // So the safe solution is to ensure underflow-safety in all cases.\n        setOutputAtIndex(index, select(mx * length(vec2<f32>(1, min(re, im)/mx)), 0.0, mx == 0.0));\n      }\n    }\n  ")},ComplexAbsProgram}();/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function makeComplexComponentTensorInfo(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}var e7={kernelName:p.ComplexAbs,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,a=t.x,r=n.tensorMap.get(a.dataId),i=new e9(a.shape),o=[makeComplexComponentTensorInfo(a,r.complexTensorInfos.real),makeComplexComponentTensorInfo(a,r.complexTensorInfos.imag)];return n.runWebGPUProgram(i,o,o[0].dtype)}},te=function(){function ConcatProgram(e){this.uniforms="",this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=p.backend_util.computeOutShape(e,1),this.variableNames=e.map(function(e,t){return"T".concat(t)}),this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.offsetLength=e.length-1;for(var t=0;t<this.offsetLength;t++)this.uniforms+="offset".concat(t," : i32,");this.shaderKey="concat"}return ConcatProgram.prototype.getUserCode=function(){var e=[];if(this.offsetLength>0){e.push("if (yC < uniforms.offset0){ setOutputAtCoords(coords.x, coords.y, getT0(yR, yC)); }");for(var t=1;t<this.offsetLength;t++)e.push("else if (yC < uniforms.offset".concat([t],"){ ")+"setOutputAtCoords(coords.x, coords.y, getT".concat(t,"(yR, yC - uniforms.offset").concat(t-1,")); }"));var n=this.offsetLength,a=this.offsetLength-1;e.push("else { setOutputAtCoords(coords.x, coords.y, getT".concat(n,"(yR, yC - uniforms.offset").concat(a,")); }"))}else e.push("setOutputAtCoords(coords.x, coords.y, getT0(yR, yC));");return"\n      ".concat(getMainHeaderString("index")," {\n        for(var i = 0; i < ").concat(this.workPerThread,"; i = i + 1) {\n          let flatIndex = index * ").concat(this.workPerThread," + i;\n          if(flatIndex < uniforms.size) {\n            let coords = getCoordsFromIndex(flatIndex);\n            let yR = coords.x;\n            let yC = coords.y;\n\n            ").concat(e.join("\n        "),"\n          }\n        }\n      }\n    ")},ConcatProgram}();/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function imag(e){var t=e.inputs,n=e.backend,a=t.input;return identity({inputs:{x:n.tensorMap.get(a.dataId).complexTensorInfos.imag},backend:n})}var tt={kernelName:p.Imag,backendName:"webgpu",kernelFunc:imag};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function concat(e){var t=e.inputs,n=e.backend,a=e.attrs.axis,r=p.util.parseAxisParam(a,t[0].shape)[0],i=t.map(function(e){return e.shape});p.backend_util.assertParamsConsistent(i,r);var o=p.backend_util.computeOutShape(t.map(function(e){return e.shape}),r);if(0===p.util.sizeFromShape(o))return n.makeTensorInfo(o,t[0].dtype,[]);var s=t.filter(function(e){return p.util.sizeFromShape(e.shape)>0});return 1===s.length?identity({inputs:{x:s[0]},backend:n}):function concatImpl(e,t,n){var a,r,i,o=e[0].dtype;if("complex64"===o){var s=e.map(function(e){return real({inputs:{input:e},backend:n})}),u=e.map(function(e){return imag({inputs:{input:e},backend:n})}),c=concatImpl(s,t,n),d=concatImpl(u,t,n),l=complex({inputs:{real:c,imag:d},backend:n});return s.forEach(function(e){return n.disposeData(e.dataId)}),u.forEach(function(e){return n.disposeData(e.dataId)}),n.disposeData(c.dataId),n.disposeData(d.dataId),l}var h=n.shouldExecuteOnCPU(e);if("string"===o&&(h=!0),h){var f=e.map(function(e){var a=p.util.sizeFromShape(e.shape.slice(t));return reshape({inputs:{x:e},backend:n,attrs:{shape:[-1,a]}})}),m=concatImplCPU(f.map(function(e){return{vals:n.readSync(e.dataId),shape:e.shape}}),p.backend_util.computeOutShape(f.map(function(e){return e.shape}),1),o,1===f[0].shape[0]),g=p.backend_util.computeOutShape(e.map(function(e){return e.shape}),t),y=n.makeTensorInfo(g,o,m);return f.forEach(function(e){return n.disposeData(e.dataId)}),y}var v=n.device.limits.maxStorageBuffersPerShaderStage-1;if(e.length>v){for(var x=[],b=0;b<e.length;b+=v){var S=e.slice(b,b+v);x.push(concatImpl(S,t,n))}var l=concatImpl(x,t,n);try{for(var w=__values(x),C=w.next();!C.done;C=w.next()){var b=C.value;n.disposeData(b.dataId)}}catch(e){r={error:e}}finally{try{C&&!C.done&&(i=w.return)&&i.call(w)}finally{if(r)throw r.error}}return l}var k=(a=p.backend_util.computeOutShape(e.map(function(e){return e.shape}),t),{tensors2D:e.map(function(e){return reshape({inputs:{x:e},backend:n,attrs:{shape:[p.util.sizeFromShape(e.shape.slice(0,t)),p.util.sizeFromShape(e.shape.slice(t))]}})}),outShape:a}),I=k.tensors2D,P=k.outShape,R=I.map(function(e){return e.shape}),D=new te(R),_=[],A=Array(R.length-1);if(A.length>0){A[0]=R[0][1],_.push({type:"int32",data:[A[0]]});for(var b=1;b<A.length;b++)A[b]=A[b-1]+R[b][1],_.push({type:"int32",data:[A[b]]})}var z=n.runWebGPUProgram(D,I,I[0].dtype,_);I.forEach(function(e){return n.disposeData(e.dataId)});var N=reshape({inputs:{x:z},backend:n,attrs:{shape:P}});return n.disposeData(z.dataId),N}(s,r,n)}var tn={kernelName:p.Concat,backendName:"webgpu",kernelFunc:concat},ta=function(){function Conv2DMMProgram(e,t,n,a,r,i,o,s){void 0===r&&(r=!1),void 0===i&&(i=null),void 0===o&&(o=!1),void 0===s&&(s=!1),this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.outShape,this.isChannelsLast="channelsLast"===e.dataFormat,this.isVec4=((e.inChannels%4==0||e.inChannels%3==0)&&this.isChannelsLast||e.outWidth%4==0&&!this.isChannelsLast)&&e.outChannels%4==0,this.dispatchLayout=this.isChannelsLast?{x:[3],y:[1,2],z:[0]}:{x:[2,3],y:[1],z:[0]},this.workgroupSize=computeWorkgroupSizeForConv2d(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=computeWorkPerThreadForConv2d(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4?(this.outputComponent=4,this.isChannelsLast&&e.inChannels%4!=0?(this.innerElementSize=3,this.variableComponents=[1,4]):(this.innerElementSize=4,this.variableComponents=[4,4]),r&&(this.variableNames.push("bias"),this.variableComponents.push(4)),o&&(this.variableNames.push("preluActivationWeights"),this.variableComponents.push(4))):(this.innerElementSize=this.elementsPerThread[0],r&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights")),this.sequentialAccessByThreads=s,this.addBias=r,this.activation=i,this.hasPreluActivationWeights=o,this.tileAOuter=this.workgroupSize[1]*this.elementsPerThread[1],this.tileBOuter=this.workgroupSize[0]*this.elementsPerThread[0],this.tileInner=Math.max(this.workgroupSize[0]*this.innerElementSize,this.workgroupSize[1]),this.fitAOuter=t%this.tileAOuter==0,this.fitBOuter=n%this.tileBOuter==0,this.fitInner=a%this.tileInner==0,this.shaderKey="conv2DMM_".concat(this.elementsPerThread,"_").concat(this.activation,"}_").concat(this.fitAOuter,"_").concat(this.fitBOuter,"_").concat(this.fitInner,"_").concat(this.isVec4,"_").concat(this.innerElementSize,"_").concat(this.isChannelsLast,"_").concat(this.sequentialAccessByThreads)}return Conv2DMMProgram.prototype.getUserCode=function(){var e,t,n,a,r,i,o,s,u,c,d,p,l,h,f,m,g,y,v,x,b,S,w=this.isVec4?makeMatMulPackedVec4Source(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner):makeMatMulPackedSource(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner,!1,null,this.sequentialAccessByThreads),C=this.isVec4?[this.innerElementSize,4,4]:[1,1,1];return"\n    ".concat((e=this.isChannelsLast,t=this.fitAOuter,n=this.fitBOuter,a=this.fitInner,r=this.addBias,i=this.activation,o=this.hasPreluActivationWeights,s=C[0],u=C[1],c=C[2],void 0===r&&(r=!1),void 0===i&&(i=null),void 0===o&&(o=!1),void 0===s&&(s=4),void 0===u&&(u=4),void 0===c&&(c=4),d=e?"\n      let coord = vec4<i32>(batch, xRow, xCol, xCh);\n      ":"\n      let coord = vec4<i32>(batch, xCh, xRow, xCol);\n      ",p=e?"\n      let coords = vec4<i32>(\n        batch,\n        row / outWidth,\n        row % outWidth,\n        col);\n      ":"\n      let coords = vec4<i32>(\n        batch,\n        row,\n        col / outWidth,\n        col % outWidth);\n      ",l=e?"uniforms.xShape[1]":"uniforms.xShape[2]",h=e?"uniforms.xShape[2]":"uniforms.xShape[3]",f=e?"row":"col",m=e?"col":"row",g="\n      let inChannels = uniforms.wShape[2];\n      let outWidth = ".concat(e?"uniforms.outShape[2]":"uniforms.outShape[3]",";\n      let outRow = ").concat(f," / outWidth;\n      let outCol = ").concat(f," % outWidth;\n\n      let WRow = ").concat(m," / (uniforms.filterDims[1] * inChannels);\n      let WCol = ").concat(m," / inChannels % uniforms.filterDims[1];\n      let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * WRow - uniforms.pads[0];\n      let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * WCol - uniforms.pads[1];\n      let xCh = ").concat(m," % inChannels;\n      var resData = ").concat(typeSnippet(s),"(0.0);\n      // The bounds checking is always needed since we use it to pad zero for\n      // the 'same' padding type.\n      if (xRow >= 0 && xRow < ").concat(l," && xCol >= 0 && xCol < ").concat(h,") {\n        ").concat(d,"\n        let xIndex = getIndexFromCoords4D(coord, uniforms.xShape);\n        ").concat(function(e){switch(e){case 1:return"resData = f32(x[xIndex]);";case 3:return"resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);";case 4:return"resData = vec4<f32>(x[xIndex / 4]);";default:throw Error("innerElementSize ".concat(e," is not supported."))}}(s),"\n      }\n      return resData;"),y=e?t&&a?"\n      ".concat(g):"\n      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {\n        ".concat(g,"\n      }\n      return ").concat(typeSnippet(s),"(0.0);"):a&&n?"\n      ".concat(g):"\n      if (row < uniforms.dimInner && col < uniforms.dimBOuter) {\n        ".concat(g,"\n      }\n      return ").concat(typeSnippet(s),"(0.0);"),v="".concat(function(e){switch(e){case 1:return"return f32(W[row * uniforms.wShape[3] + col]);";case 4:return"return vec4<f32>(W[(row * uniforms.wShape[3] + col) / 4]);";default:throw Error("innerElementSize ".concat(e," is not supported."))}}(u)),x=typeSnippet(c),b=e?typeSnippet(s):typeSnippet(u),S=e?typeSnippet(u):typeSnippet(s),"\n      ".concat(activationFnSnippet(i,o,4===c,4),"\n      fn mm_readA(batch: i32, row : i32, col : i32) -> ").concat(b," {\n        ").concat(e?y:v,"\n      }\n\n      fn mm_readB(batch: i32, row : i32, col : i32) -> ").concat(S," {\n        ").concat(e?v:y,"\n      }\n\n      fn mm_write(batch: i32, row : i32, col : i32, valueIn : ").concat(x,") {\n        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)\n        {\n        var value = valueIn;\n        let outWidth = ").concat(e?"uniforms.outShape[2]":"uniforms.outShape[3]",";\n        ").concat(p,"\n        ").concat(biasActivationSnippet(r,i),"\n        setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n        }\n      }")),"\n    ").concat(w,"\n  ")},Conv2DMMProgram}(),tr=function(){function Conv2DNaiveProgram(e,t,n,a){void 0===t&&(t=!1),void 0===n&&(n=null),void 0===a&&(a=!1),this.variableNames=["x","W"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>,",this.workgroupSize=[4,4,8],this.outputShape=e.outShape,this.isChannelsLast="channelsLast"===e.dataFormat,this.dispatchLayout=this.isChannelsLast?{x:[2],y:[1],z:[0,3]}:{x:[3],y:[2],z:[0,1]},this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=t,this.activation=n,this.hasPreluActivationWeights=a,t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),this.shaderKey="conv2dnaive_".concat(this.activation,"_").concat(this.isChannelsLast)}return Conv2DNaiveProgram.prototype.getUserCode=function(){return"\n       ".concat(activationFnSnippet(this.activation,this.hasPreluActivationWeights,!1,4),"\n       fn readInp(batch : i32, row : i32, col : i32, chan : i32) -> f32{\n         let coords = vec4<i32>(batch, row, col, chan);\n         if (coordsInBounds4D(coords, uniforms.xShape)) {\n           return  getX(batch, row, col, chan);\n         } else {\n          return 0.0;\n         }\n       }\n       fn readFilt(row : i32, col : i32, xChannel : i32, outChannel : i32) -> f32{\n         let coords = vec4<i32>(row, col, xChannel, outChannel);\n         if(coordsInBounds4D(coords, uniforms.wShape)) {\n           return getW(row, col, xChannel, outChannel);\n          } else {\n            return 0.0;\n          }\n       }\n       fn writeResult(batch : i32, row : i32, col : i32, chan : i32, valueIn : f32) {\n         let coords = ").concat(this.isChannelsLast?"vec4<i32>(batch, row, col, chan);":"vec4<i32>(batch, chan, row, col);","\n         if (coordsInBounds4D(coords, uniforms.outShape)) {\n           var value = valueIn;\n           ").concat(biasActivationSnippet(this.addBias,this.activation),"\n           setOutputAtCoords(coords.x, coords.y, coords.z, coords.w, value);\n         }\n       }\n       ").concat(getMainHeaderString("index")," {\n         let coords = getOutputCoords();\n         let batch = coords[0];\n         let outChannel = ").concat(this.isChannelsLast?"coords[3];":"coords[1];","\n         let outRow = ").concat(this.isChannelsLast?"coords[1];":"coords[2];","\n         let outCol = ").concat(this.isChannelsLast?"coords[2];":"coords[3];","\n         var acc : f32 = 0.0;\n         for (var row = 0; row < uniforms.filterDims[0]; row = row + 1) {\n           for (var col = 0; col < uniforms.filterDims[1]; col = col + 1) {\n             let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * row - uniforms.pads[0];\n             let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * col - uniforms.pads[1];\n             for (var xChannel = 0; xChannel < ").concat(this.isChannelsLast?"uniforms.xShape[3];":"uniforms.xShape[1];"," xChannel = xChannel + 1) {\n               ").concat(this.isChannelsLast?"let v = readInp(batch, xRow, xCol, xChannel);":"let v = readInp(batch, xChannel, xRow, xCol);","\n               let f = readFilt(row, col, xChannel, outChannel);\n               acc = acc + v * f;\n             }\n           }\n         }\n         writeResult(batch, outRow, outCol, outChannel, acc);\n       }\n     ")},Conv2DNaiveProgram}(),ti=function(){function Im2ColProgram(e,t){this.variableNames=["x"],this.uniforms="pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, outWidth : i32, itemsPerBlockRow : i32,\n       inChannels : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=t,this.shaderKey="im2col_".concat(this.isChannelsLast)}return Im2ColProgram.prototype.getUserCode=function(){var e=this.isChannelsLast?1:2,t=this.isChannelsLast?2:3,n=this.isChannelsLast?"coords[1]":"coords[2]",a=this.isChannelsLast?"coords[2]":"coords[1]",r=this.isChannelsLast?"getX(batch, xRow, xCol, ch)":"getX(batch, ch, xRow, xCol)";return"\n    ".concat(getMainHeaderString("index")," {\n      let coords = getCoordsFromIndex(index);\n      if(index < uniforms.size) {\n        let batch = coords[0];\n        let row = ").concat(n,";\n        let col = ").concat(a,";\n        let offsetY = (row / uniforms.outWidth) * uniforms.strides[0] - uniforms.pads[0];\n        let xRow = offsetY + uniforms.dilations[0] * (col / uniforms.itemsPerBlockRow);\n        var value = 0.0;\n        if(xRow < uniforms.xShape[").concat(e,"] && xRow >= 0) {\n          let offsetX = (row % uniforms.outWidth) * uniforms.strides[1] -\n              uniforms.pads[1];\n          let xCol = offsetX + uniforms.dilations[1] * ((col %\n              uniforms.itemsPerBlockRow) / uniforms.inChannels);\n          let ch = col % uniforms.inChannels;\n          if(xCol < uniforms.xShape[").concat(t,"] && xCol >= 0) {\n            value = ").concat(r,";\n          }\n        }\n        setOutputAtIndex(index, value);\n      }\n    }\n   ")},Im2ColProgram}();function getShapeForBatchMatMul(e,t){var n=e.length;return n>=3?t?__spreadArray(__spreadArray([],__read(e.slice(0,-3)),!1),[e[n-3]*e[n-2],e[n-1]],!1):__spreadArray(__spreadArray([],__read(e.slice(0,-3)),!1),[e[n-3],e[n-2]*e[n-1]],!1):!t&&1===n&&e[0]>1?[e[0],1]:null}function conv2DImpl(e){var t,n,a,r=e.x,i=e.filter,o=e.convInfo,s=e.backend,u=e.bias,c=void 0===u?null:u,d=e.preluActivationWeights,l=void 0===d?null:d,h=e.leakyreluAlpha,f=void 0===h?0:h,m=e.activation,g=void 0===m?null:m,y=null!=c,v=null!=l,x="channelsLast"===o.dataFormat,b=x&&o.filterHeight===o.inHeight&&o.filterWidth===o.inWidth&&"VALID"===o.padInfo.type,S=p.env().getBool("WEBGPU_USE_NAIVE_CONV2D_DEBUG");if(!S&&(b||1===o.filterHeight&&1===o.filterWidth&&1===o.dilationHeight&&1===o.dilationWidth&&1===o.strideHeight&&1===o.strideWidth&&("SAME"===o.padInfo.type||"VALID"===o.padInfo.type)))return function(e){var t,n,a,r,i=e.x,o=e.filter,s=e.convInfo,u=e.backend,c=e.bias,d=void 0===c?null:c,p=e.preluActivationWeights,l=void 0===p?null:p,h=e.leakyreluAlpha,f=e.activation,m="channelsLast"===s.dataFormat,g=!m,y=m&&s.filterHeight===s.inHeight&&s.filterWidth===s.inWidth&&"VALID"===s.padInfo.type,v=[];if(y){var x=s.inHeight*s.inWidth*s.inChannels;a=reshape({inputs:{x:i},backend:u,attrs:{shape:[1,s.batchSize,x]}}),r=reshape({inputs:{x:o},backend:u,attrs:{shape:[1,x,s.outChannels]}})}else a=reshape({inputs:{x:i},backend:u,attrs:{shape:m?[s.batchSize,s.inHeight*s.inWidth,s.inChannels]:[s.batchSize,s.inChannels,s.inHeight*s.inWidth]}}),r=reshape({inputs:{x:o},backend:u,attrs:{shape:[1,s.inChannels,s.outChannels]}});if(v.push(a),v.push(r),null!=l){var b=getShapeForBatchMatMul(l.shape,m);null!=b&&(l=reshape({inputs:{x:l},backend:u,attrs:{shape:b}}),v.push(l))}if(null!=d){var b=getShapeForBatchMatMul(d.shape,m);null!=b&&(d=reshape({inputs:{x:d},backend:u,attrs:{shape:b}}),v.push(d))}var S=batchMatMulImpl({a:m?a:r,b:m?r:a,transposeA:g,transposeB:!1,backend:u,bias:d,activation:void 0===f?null:f,preluActivationWeights:l,leakyreluAlpha:void 0===h?0:h}),w=reshape({inputs:{x:S},backend:u,attrs:{shape:s.outShape}});v.push(S);try{for(var C=__values(v),k=C.next();!k.done;k=C.next()){var I=k.value;u.disposeData(I.dataId)}}catch(e){t={error:e}}finally{try{k&&!k.done&&(n=C.return)&&n.call(C)}finally{if(t)throw t.error}}return w}({x:r,filter:i,convInfo:o,backend:s,bias:c,activation:g,preluActivationWeights:l,leakyreluAlpha:f});var w=p.env().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),C=w>-1?w:s.thresholdToIncreaseWorkgroups,k=o.batchSize*Math.ceil(o.outHeight*o.outWidth/32)*Math.ceil(o.outChannels/32);if(p.env().getBool("WEBGPU_CONV_SEPARATE_IM2COL_SHADER")||k<=C)return function(e){var t,n,a=e.x,r=e.filter,i=e.convInfo,o=e.backend,s=e.bias,u=void 0===s?null:s,c=e.preluActivationWeights,d=void 0===c?null:c,p=e.leakyreluAlpha,l=e.activation,h=i.filterWidth,f=i.filterHeight,m=i.inChannels,g=i.strideWidth,y=i.strideHeight,v=i.padInfo,x=i.outWidth,b=i.outHeight,S=i.dilationWidth,w=i.dilationHeight,C="channelsLast"===i.dataFormat,k=h*f*m,I=b*x,P=C?[i.batchSize,I,k]:[i.batchSize,k,I],R=new ti(P,C),D=[{type:"int32",data:[v.top,v.left]},{type:"int32",data:[y,g]},{type:"int32",data:[w,S]},{type:"int32",data:[x]},{type:"int32",data:[m*h]},{type:"int32",data:[m]}],_=o.runWebGPUProgram(R,[a],a.dtype,D),A=[];A.push(_);var z=reshape({inputs:{x:r},backend:o,attrs:{shape:[1,k,-1]}});if(A.push(z),null!=d){var N=getShapeForBatchMatMul(d.shape,C);null!=N&&(d=reshape({inputs:{x:d},backend:o,attrs:{shape:N}}),A.push(d))}if(null!=u){var N=getShapeForBatchMatMul(u.shape,C);null!=N&&(u=reshape({inputs:{x:u},backend:o,attrs:{shape:N}}),A.push(u))}var F=!C,T=batchMatMulImpl({a:C?_:z,b:C?z:_,transposeA:F,transposeB:!1,backend:o,bias:u,activation:void 0===l?null:l,preluActivationWeights:d,leakyreluAlpha:void 0===p?0:p}),B=reshape({inputs:{x:T},backend:o,attrs:{shape:i.outShape}});A.push(T);try{for(var L=__values(A),M=L.next();!M.done;M=L.next()){var W=M.value;o.disposeData(W.dataId)}}catch(e){t={error:e}}finally{try{M&&!M.done&&(n=L.return)&&n.call(L)}finally{if(t)throw t.error}}return B}({x:r,filter:i,convInfo:o,backend:s,bias:c,preluActivationWeights:l,leakyreluAlpha:f,activation:g});var I=[o.padInfo.top,o.padInfo.left],P=[{type:"int32",data:[o.filterHeight,o.filterWidth]},{type:"int32",data:__spreadArray([],__read(I),!1)},{type:"int32",data:[o.strideHeight,o.strideWidth]},{type:"int32",data:[o.dilationHeight,o.dilationWidth]}];if(S)a=new tr(o,y,g,v);else{var R=x?o.outHeight*o.outWidth:o.outChannels,D=x?o.outChannels:o.outHeight*o.outWidth,_=o.filterHeight*o.filterWidth*o.inChannels;P.push({type:"int32",data:[R]},{type:"int32",data:[D]},{type:"int32",data:[_]});var A=s.adapterInfo.isIntel();a=new ta(o,R,D,_,y,g,v,A)}var z=[],N=[r,i];y&&(x||1!==c.shape.length||(c=reshape({inputs:{x:c},backend:s,attrs:{shape:[c.shape[0],1,1]}}),z.push(c)),N.push(c)),v&&(x||1!==l.shape.length||(l=reshape({inputs:{x:l},backend:s,attrs:{shape:[l.shape[0],1,1]}}),z.push(l)),N.push(l)),"leakyrelu"===g&&(P.push({type:"float32",data:[f]}),a.uniforms+=" alpha : f32,");var F=s.runWebGPUProgram(a,N,r.dtype,P);try{for(var T=__values(z),B=T.next();!B.done;B=T.next()){var L=B.value;s.disposeData(L.dataId)}}catch(e){t={error:e}}finally{try{B&&!B.done&&(n=T.return)&&n.call(T)}finally{if(t)throw t.error}}return F}var to={kernelName:p.Conv2D,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var t=e.inputs,n=e.attrs,a=e.backend,r=t.x,i=t.filter,o=n.strides,s=n.pad,u=n.dataFormat,c=n.dilations,d=n.dimRoundingMode,l=p.backend_util.convertConv2DDataFormat(u),h=p.backend_util.computeConv2DInfo(r.shape,i.shape,o,c,s,d,!1,l);return conv2DImpl({x:r,filter:i,convInfo:h,backend:a})}},ts=function(){function Conv2DDerInputProgram(e){this.variableNames=["dy","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>,",this.workgroupSize=[64,1,1],this.size=!1,this.isVec4=!1,this.workPerThread=1,this.outputShape=e.inShape,this.isChannelsLast="channelsLast"===e.dataFormat,this.isVec4=this.isChannelsLast&&e.outChannels%4==0&&e.inChannels%4==0,this.isVec4?(this.workPerThread=2,this.outputComponent=4,this.workgroupSize=[4,4,4],this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize,[4,this.workPerThread,1])):(this.size=!0,this.workPerThread=1,this.workgroupSize=[64,1,1],this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize)),this.shaderKey="conv2DDerInput_".concat(this.isChannelsLast,"_").concat(this.isVec4,"_").concat(this.workPerThread)}return Conv2DDerInputProgram.prototype.getUserCode=function(){var e=this.isChannelsLast?1:2,t=this.isChannelsLast?2:3,n=this.isChannelsLast?3:1,a="\n    ".concat(getMainHeaderString()," {\n      let batch = i32(globalId.z) / uniforms.outShape[1];\n      let r = i32(globalId.z) % uniforms.outShape[1];\n      let c = i32(globalId.y) * ").concat(this.workPerThread,";\n      let d1 = i32(globalId.x) * 4;\n\n      let dyCorner = vec2<i32>(r, c) - uniforms.pads;\n\n      // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n      // ? = to be determined. : = across all values in that axis.\n      var dotProd: array<vec4<f32>, ").concat(this.workPerThread,">;\n      for (var i = 0; i < ").concat(this.workPerThread,"; i++) {\n        dotProd[i] = vec4<f32>(0.0);\n      }\n      for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {\n        let dyR = f32(dyCorner.x + wR) / f32(uniforms.strides.x);\n        let wRPerm = uniforms.filterDims.x - 1 - wR;\n        if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) ||\n            fract(dyR) > 0.0) {\n          continue;\n        }\n        let idyR = i32(dyR);\n\n        for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {\n          let dyC = f32(dyCorner.y + wC) / f32(uniforms.strides.y);\n          let dyC2 = f32(dyCorner.y + 1 + wC) / f32(uniforms.strides.y);\n          let wCPerm = uniforms.filterDims.y - 1 - wC;\n          var bDyCVal = true;\n          var bDyCVal2 = true;\n          if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||\n              fract(dyC) > 0.0) {\n            bDyCVal = false;\n          }\n          if (dyC2 < 0.0 || dyC2 >= f32(uniforms.outBackprop[2]) ||\n              fract(dyC2) > 0.0) {\n            bDyCVal2 = false;\n          }\n\n          let idyC = i32(dyC);\n          let idyC2 = i32(dyC2);\n          if (bDyCVal && bDyCVal2) {\n            let d2Length = uniforms.outBackprop[3];\n            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {\n              let wValue0 = getW(wRPerm, wCPerm, d1, d2);\n              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);\n              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);\n              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);\n              var xValue =  getDy(batch, idyR, idyC, d2);\n              let tmpval = vec4<f32>(dot(xValue, wValue0),\n                                     dot(xValue, wValue1),\n                                     dot(xValue, wValue2),\n                                     dot(xValue, wValue3));\n              dotProd[0] = dotProd[0] + tmpval;\n              xValue = getDy(batch, idyR, idyC2, d2);\n              dotProd[1] = dotProd[1] + vec4<f32>(dot(xValue, wValue0),\n                                                  dot(xValue, wValue1),\n                                                  dot(xValue, wValue2),\n                                                  dot(xValue, wValue3));\n            }\n          } else if (bDyCVal) {\n            let d2Length = uniforms.outBackprop[3];\n            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {\n              let wValue0 = getW(wRPerm, wCPerm, d1, d2);\n              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);\n              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);\n              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);\n              var xValue =  getDy(batch, idyR, idyC, d2);\n              let tmpval = vec4<f32>(dot(xValue, wValue0),\n                                     dot(xValue, wValue1),\n                                     dot(xValue, wValue2),\n                                     dot(xValue, wValue3));\n              dotProd[0] = dotProd[0] + tmpval;\n            }\n          } else if (bDyCVal2) {\n            let d2Length = uniforms.outBackprop[3];\n            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {\n              let wValue0 = getW(wRPerm, wCPerm, d1, d2);\n              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);\n              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);\n              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);\n              var xValue =  getDy(batch, idyR, idyC2, d2);\n              let tmpval = vec4<f32>(dot(xValue, wValue0),\n                                     dot(xValue, wValue1),\n                                     dot(xValue, wValue2),\n                                     dot(xValue, wValue3));\n              dotProd[1] = dotProd[1] + tmpval;\n            }\n          }\n        }\n      }\n\n      for (var i = 0; i < ").concat(this.workPerThread,"; i = i + 1) {\n        let coords = vec4<i32>(batch, r, c + i, d1);\n        if (coordsInBounds4D(coords, uniforms.outShape)) {\n          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], dotProd[i]);\n        }\n      }\n    }\n    ");return this.isVec4?"\n    ".concat(a,"\n    "):"\n    ".concat(getMainHeaderString("index")," {\n      if(index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords[0];\n        let d1 = coords[").concat(n,"];\n\n        let dyCorner = vec2<i32>(coords[").concat(e,"], coords[").concat(t,"]) - uniforms.pads;\n        let dyRCorner = dyCorner.x;\n        let dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {\n          let dyR = (f32(dyRCorner) + f32(wR)) / f32(uniforms.strides.x);\n          let wRPerm = uniforms.filterDims.x - 1 - wR;\n          if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) || fract(dyR) > 0.0 ||\n              wRPerm < 0) {\n            continue;\n          }\n          let idyR = i32(dyR);\n\n          for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {\n            let dyC = (f32(dyCCorner) + f32(wC)) / f32(uniforms.strides.y);\n            let wCPerm = uniforms.filterDims.y - 1 - wC;\n            if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||\n                fract(dyC) > 0.0 || wCPerm < 0) {\n              continue;\n            }\n            let idyC = i32(dyC);\n\n            for (var d2 = 0; d2 < uniforms.outBackprop[3]; d2 = d2 + 1) {\n              let xValue = ").concat(this.isChannelsLast?"getDy(batch, idyR, idyC, d2)":"getDy(batch, d2, idyR, idyC)",";\n              let wValue = getW(wRPerm, wCPerm, d1, d2);\n              dotProd = dotProd + xValue * wValue;\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n  ")},Conv2DDerInputProgram}(),tu=function(){function Conv2DDerFilterProgram(e){this.variableNames=["x","dy"],this.uniforms="pads : vec2<i32>, strides : vec2<i32>, batchSize : i32, outHeight : i32, outWidth : i32, inHeight : i32, inWidth : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast="channelsLast"===e.dataFormat,this.shaderKey="conv2DDerFilter_".concat(this.isChannelsLast)}return Conv2DDerFilterProgram.prototype.getUserCode=function(){return"\n    ".concat(getMainHeaderString("index")," {\n      if(index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let wR = coords[0];\n        let wC = coords[1];\n        let d1 = coords[2];\n        let d2 = coords[3];\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        for (var b = 0; b < uniforms.batchSize; b = b + 1) {\n          for (var yR = 0; yR < uniforms.outHeight; yR = yR + 1) {\n            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];\n            if (xR < 0 || xR >= uniforms.inHeight) {\n              continue;\n            }\n\n            for (var yC = 0; yC < uniforms.outWidth; yC = yC + 1) {\n              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];\n\n              if (xC < 0 || xC >= uniforms.inWidth) {\n                continue;\n              }\n\n              if (").concat(this.isChannelsLast,") {\n                let dyValue = getDy(b, yR, yC, d2);\n                let xValue = getX(b, xR, xC, d1);\n                dotProd = dotProd + xValue * dyValue;\n              } else {\n                let dyValue = getDy(b, d2, yR, yC);\n                let xValue = getX(b, d1, xR, xC);\n                dotProd = dotProd + xValue * dyValue;\n              }\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n  ")},Conv2DDerFilterProgram}(),tc=function(){function Conv3DDerFilterProgram(e){this.variableNames=["x","dy"],this.uniforms="pads : vec3<i32>, strides : vec3<i32>, batchSize : i32, outDepth : i32,\n       outHeight : i32, outWidth : i32, inDepth : i32, inHeight : i32, inWidth : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3DDerFilter"}return Conv3DDerFilterProgram.prototype.getUserCode=function(){return"\n    ".concat(getMainHeaderString("index")," {\n      if(index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let wF = coords.x;\n        let wR = coords.y;\n        let wC = coords.z;\n        let d1 = coords.w;\n        let d2 = coords.u;\n\n        var dotProd = 0.0;\n        for (var b = 0; b < uniforms.batchSize; b++) {\n          for (var yF = 0; yF < uniforms.outDepth; yF++) {\n            let xF = wF + yF * uniforms.strides[0] - uniforms.pads[0];\n            if (xF < 0 || xF >= uniforms.inDepth) {\n              continue;\n            }\n\n            for (var yR = 0; yR < uniforms.outHeight; yR++) {\n              let xR = wR + yR * uniforms.strides[1] - uniforms.pads[1];\n              if (xR < 0 || xR >= uniforms.inHeight) {\n                continue;\n              }\n\n              for (var yC = 0; yC < uniforms.outWidth; yC++) {\n                let xC = wC + yC * uniforms.strides[2] - uniforms.pads[2];\n                if (xC < 0 || xC >= uniforms.inWidth) {\n                  continue;\n                }\n\n                let dyValue = getDy(b, yF, yR, yC, d2);\n                let xValue = getX(b, xF, xR, xC, d1);\n                dotProd += xValue * dyValue;\n              }\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n  ")},Conv3DDerFilterProgram}(),td=function(){function Conv3DDerInputProgram(e){this.variableNames=["dy","W"],this.uniforms="filterDims : vec3<i32>, pads : vec3<i32>, strides : vec3<i32>,\n      outDepth : i32, outHeight : i32, outWidth : i32, outChannels : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3DDerInput"}return Conv3DDerInputProgram.prototype.getUserCode=function(){return"\n    ".concat(getMainHeaderString("index")," {\n      if(index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords.x;\n        let d1 = coords.u;\n\n        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;\n        let dyFCorner = dyCorner.x;\n        let dyRCorner = dyCorner.y;\n        let dyCCorner = dyCorner.z;\n\n        var dotProd = 0.0;\n        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {\n          let dyF = f32(dyFCorner + wF) / f32(uniforms.strides[0]);\n          if (dyF < 0.0 || dyF >= f32(uniforms.outDepth) || fract(dyF) > 0.0) {\n            continue;\n          }\n          let idyF = i32(dyF);\n\n          let wFPerm = uniforms.filterDims[0] - 1 - wF;\n\n          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {\n            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);\n\n            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {\n              continue;\n            }\n            let idyR = i32(dyR);\n\n            let wRPerm = uniforms.filterDims[1] - 1 - wR;\n\n            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {\n              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);\n\n              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {\n                continue;\n              }\n              let idyC = i32(dyC);\n\n              let wCPerm = uniforms.filterDims[2] - 1 - wC;\n\n              for (var d2 = 0; d2 < uniforms.outChannels; d2++) {\n                let xValue = getDy(batch, idyF, idyR, idyC, d2);\n                let wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n  ")},Conv3DDerInputProgram}(),tp={kernelName:p.Conv2DBackpropFilter,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var t=e.inputs,n=e.backend,a=e.attrs,r=t.x,i=t.dy,o=a.strides,s=a.pad,u=a.dataFormat,c=a.dimRoundingMode,d=a.filterShape,l=p.backend_util.convertConv2DDataFormat(u),h=p.backend_util.computeConv2DInfo(r.shape,d,o,1,s,c,!1,l),f=new tu(h),m=[{type:"int32",data:[h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.batchSize]},{type:"int32",data:[h.outHeight]},{type:"int32",data:[h.outWidth]},{type:"int32",data:[h.inHeight]},{type:"int32",data:[h.inWidth]}];return n.runWebGPUProgram(f,[r,i],r.dtype,m)}},tl=function(){function Conv2DDerInputMMProgram(e){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.inShape,p.util.assert("channelsLast"===e.dataFormat,function(){return"TODO: NCHW is unimplemented"}),this.isVec4=e.inChannels%4==0&&e.outChannels%4==0,this.dispatchLayout={x:[3],y:[1,2],z:[0]},this.workgroupSize=computeWorkgroupSizeForConv2d(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=computeWorkPerThreadForConv2d(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4&&(this.outputComponent=4,this.variableComponents=[4,1]),this.shaderKey="conv2DDerInputMM_".concat(this.isVec4,"_").concat(this.elementsPerThread)}return Conv2DDerInputMMProgram.prototype.getUserCode=function(){var e,t,n,a=this.isVec4?makeMatMulPackedVec4Source(this.elementsPerThread,this.workgroupSize):makeMatMulPackedSource(this.elementsPerThread,this.workgroupSize);return"\n    ".concat((e=this.isVec4?4:1,t="\n      let outRow = row / uniforms.outShape[2];\n      let outCol = row % uniforms.outShape[2];\n\n      let WRow = col / (uniforms.filterDims[1] * uniforms.outBackprop[3]);\n      let WCol = col / uniforms.outBackprop[3] % uniforms.filterDims[1];\n      let xR = f32(outRow - uniforms.pads[0] + WRow) / f32(uniforms.strides[0]);\n      let xC = f32(outCol - uniforms.pads[1] + WCol) / f32(uniforms.strides[1]);\n      if (xR < 0.0 || xR >= f32(uniforms.outBackprop[1]) || fract(xR) > 0.0) {\n        return ".concat(typeSnippet(e),"(0.0);\n      }\n      if (xC < 0.0 || xC >= f32(uniforms.outBackprop[2]) || fract(xC) > 0.0) {\n        return ").concat(typeSnippet(e),"(0.0);\n      }\n      let coord = vec4<i32>(\n          batch,\n          i32(xR),\n          i32(xC),\n          col % uniforms.outBackprop[3]);\n      return x[getIndexFromCoords4D(coord, uniforms.xShape)/").concat(e,"];"),n="if (row < uniforms.dimAOuter && col < uniforms.dimInner) {\n        ".concat(t,"\n      }\n      return ").concat(typeSnippet(e),"(0.0);"),"\n  fn mm_readA(batch: i32, row : i32, col : i32) -> ".concat(typeSnippet(e)," {\n    ").concat(n,"\n  }\n\n  fn mm_readB(batch: i32, row : i32, col : i32) -> ").concat(typeSnippet(e)," {\n    let coordX = uniforms.filterDims.x - 1 -\n        row / (uniforms.filterDims[1] * uniforms.outBackprop[3]);\n    let coordY = uniforms.filterDims.y - 1 -\n        (row / uniforms.outBackprop[3]) % uniforms.filterDims[1];\n    if (row < uniforms.dimInner && col < uniforms.dimBOuter &&\n        coordX >= 0 && coordY >= 0) {\n      let rowInner = row % uniforms.outBackprop[3];\n      let coord = vec4<i32>(coordX, coordY, col, rowInner);\n      ").concat(function(e){switch(e){case 1:return"return W[getIndexFromCoords4D(coord, uniforms.wShape)];";case 4:return"\n            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);\n            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);\n            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);\n            let v0 = W[getIndexFromCoords4D(coord, uniforms.wShape)];\n            let v1 = W[getIndexFromCoords4D(coord1, uniforms.wShape)];\n            let v2 = W[getIndexFromCoords4D(coord2, uniforms.wShape)];\n            let v3 = W[getIndexFromCoords4D(coord3, uniforms.wShape)];\n            return vec4<f32>(v0, v1, v2, v3);\n            ";default:throw Error("innerElementSize ".concat(e," is not supported."))}}(e),"\n    }\n    return ").concat(typeSnippet(e),"(0.0);\n  }\n\n  fn mm_write(batch: i32, row : i32, col : i32, valueInput : ").concat(typeSnippet(e),") {\n    if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {\n      var value = valueInput;\n      let outCoord = vec4<i32>(\n          batch,\n          row / uniforms.outShape[2],\n          row % uniforms.outShape[2],\n          col);\n      result[getIndexFromCoords4D(outCoord, uniforms.outShape)/").concat(e,"] = value;\n    }\n  }")),"\n    ").concat(a,"\n    ")},Conv2DDerInputMMProgram}(),th={kernelName:p.Conv2DBackpropInput,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var t,n=e.inputs,a=e.backend,r=e.attrs,i=n.dy,o=n.filter,s=r.inputShape,u=r.strides,c=r.pad,d=r.dataFormat,l=r.dimRoundingMode,h=p.backend_util.convertConv2DDataFormat(d),f=p.backend_util.computeConv2DInfo(s,o.shape,u,1,c,l,!1,h),m=[{type:"int32",data:[f.filterHeight,f.filterWidth]},{type:"int32",data:[f.filterHeight-1-f.padInfo.top,f.filterWidth-1-f.padInfo.left]},{type:"int32",data:[f.strideHeight,f.strideWidth]},{type:"int32",data:[f.batchSize,f.outHeight,f.outWidth,f.outChannels]}];if(p.env().getBool("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE")||"channelsLast"!==f.dataFormat)t=new ts(f);else{t=new tl(f);var g=f.inHeight*f.inWidth,y=f.inChannels,v=f.filterHeight*f.filterWidth*f.outChannels;m.push({type:"uint32",data:[g]},{type:"uint32",data:[y]},{type:"uint32",data:[v]})}return a.runWebGPUProgram(t,[i,o],"float32",m)}},tf=function(){function Conv3DNaiveProgram(e){this.variableNames=["x","W"],this.uniforms="filterDims: vec3<i32>, pads: vec3<i32>, strides: vec3<i32>, dilations: vec3<i32>,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3dnaive"}return Conv3DNaiveProgram.prototype.getUserCode=function(){return"\n    ".concat(getMainHeaderString("index")," {\n      if (index < uniforms.size) {\n        let coords = getOutputCoords();\n        let batch = coords.x;\n        let d2 = coords.u;\n\n        let xFRCCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;\n        let xFCorner = xFRCCorner.x;\n        let xRCorner = xFRCCorner.y;\n        let xCCorner = xFRCCorner.z;\n\n        let inputDepthNearestVec4 = (uniforms.xShape.u / 4) * 4;\n        let inputDepthVec4Remainder = uniforms.xShape.u % 4;\n\n        var dotProd = 0.0;\n        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {\n          let xF = xFCorner + wF * uniforms.dilations[0];\n          if (xF < 0 || xF >= uniforms.xShape.y) {\n            continue;\n          }\n\n          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {\n            let xR = xRCorner + wR * uniforms.dilations[1];\n            if (xR < 0 || xR >= uniforms.xShape.z) {\n              continue;\n            }\n\n            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {\n              let xC = xCCorner + wC * uniforms.dilations[2];\n              if (xC < 0 || xC >= uniforms.xShape.w) {\n                continue;\n              }\n\n              for (var d1 = 0; d1 < inputDepthNearestVec4; d1 += 4) {\n                let xValues = vec4<f32>(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                let wValues = vec4<f32>(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (inputDepthVec4Remainder == 1) {\n                dotProd += getX(batch, xF, xR, xC, inputDepthNearestVec4) *\n                  getW(wF, wR, wC, inputDepthNearestVec4, d2);\n              } else if (inputDepthVec4Remainder == 2) {\n                let xValues = vec2<f32>(\n                  getX(batch, xF, xR, xC, inputDepthNearestVec4),\n                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1)\n                );\n                let wValues = vec2<f32>(\n                  getW(wF, wR, wC, inputDepthNearestVec4, d2),\n                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (inputDepthVec4Remainder == 3) {\n                let xValues = vec3<f32>(\n                  getX(batch, xF, xR, xC, inputDepthNearestVec4),\n                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),\n                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2)\n                );\n                let wValues = vec3<f32>(\n                  getW(wF, wR, wC, inputDepthNearestVec4, d2),\n                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2),\n                  getW(wF, wR, wC, inputDepthNearestVec4 + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }")},Conv3DNaiveProgram}(),tm={kernelName:p.Conv3D,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,a=e.attrs,r=t.x,i=t.filter,o=a.strides,s=a.pad,u=a.dilations,c=p.backend_util.computeConv3DInfo(r.shape,i.shape,o,u,s),d=[c.padInfo.front,c.padInfo.top,c.padInfo.left],l=[{type:"int32",data:[c.filterDepth,c.filterHeight,c.filterWidth]},{type:"int32",data:__spreadArray([],__read(d),!1)},{type:"int32",data:[c.strideDepth,c.strideHeight,c.strideWidth]},{type:"int32",data:[c.dilationDepth,c.dilationHeight,c.dilationWidth]}],h=new tf(c),f=p.upcastType(r.dtype,i.dtype);return n.runWebGPUProgram(h,[r,i],f,l)}},tg={kernelName:p.Conv3DBackpropFilterV2,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var t=e.inputs,n=e.backend,a=e.attrs,r=t.x,i=t.dy,o=a.strides,s=a.pad,u=a.filterShape,c=p.backend_util.computeConv3DInfo(r.shape,u,o,1,s),d=new tc(c),l=[{type:"int32",data:[c.padInfo.front,c.padInfo.top,c.padInfo.left]},{type:"int32",data:[c.strideDepth,c.strideHeight,c.strideWidth]},{type:"int32",data:[c.batchSize]},{type:"int32",data:[c.outDepth]},{type:"int32",data:[c.outHeight]},{type:"int32",data:[c.outWidth]},{type:"int32",data:[c.inDepth]},{type:"int32",data:[c.inHeight]},{type:"int32",data:[c.inWidth]}];return n.runWebGPUProgram(d,[r,i],i.dtype,l)}},ty={kernelName:p.Conv3DBackpropInputV2,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var t=e.inputs,n=e.backend,a=e.attrs,r=t.dy,i=t.filter,o=a.strides,s=a.pad,u=a.inputShape,c=p.backend_util.computeConv3DInfo(u,i.shape,o,1,s),d=new td(c),l=[{type:"int32",data:[c.filterDepth,c.filterHeight,c.filterWidth]},{type:"int32",data:[c.filterDepth-1-c.padInfo.front,c.filterHeight-1-c.padInfo.top,c.filterWidth-1-c.padInfo.left]},{type:"int32",data:[c.strideDepth,c.strideHeight,c.strideWidth]},{type:"int32",data:[c.outDepth]},{type:"int32",data:[c.outHeight]},{type:"int32",data:[c.outWidth]},{type:"int32",data:[c.outChannels]}];return n.runWebGPUProgram(d,[r,i],r.dtype,l)}},tv=unaryKernelFunc({opType:o.COS}),tx={kernelName:p.Cos,backendName:"webgpu",kernelFunc:tv},tb=unaryKernelFunc({opType:o.COSH}),tS={kernelName:p.Cosh,backendName:"webgpu",kernelFunc:tb},tw=function(){function CropAndResizeProgram(e,t,n,a){this.variableNames=["Image","Boxes","BoxInd"],this.uniforms="extrapolationValue : f32,",this.workgroupSize=[64,1,1],this.size=!0;var r=__read(t,1)[0];this.outputShape=[r,n[0],n[1],e],this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.methodId="bilinear"===a?1:0,this.cropHeightBiggerThan1=this.outputShape[1]>1,this.cropWidthBiggerThan1=this.outputShape[2]>1,this.shaderKey="cropAndResize_".concat(this.methodId,"_").concat(this.cropHeightBiggerThan1,"_").concat(this.cropWidthBiggerThan1)}return CropAndResizeProgram.prototype.getUserCode=function(){var e=__read(["f32(uniforms.imageShape[1] - 1)","f32(uniforms.imageShape[2] - 1)"],2),t=e[0],n=e[1],a=__read(this.cropHeightBiggerThan1?["(".concat(t," / f32(uniforms.outShape[1] - 1))"),"(y2-y1) * height_ratio","y1*".concat(t," + f32(y)*(height_scale)")]:["0.0","0.0","0.5 * (y1+y2) * ".concat(t)],3),r=a[0],i=a[1],o=a[2],s=__read(this.cropWidthBiggerThan1?["(".concat(n," / f32(uniforms.outShape[2] - 1))"),"(x2-x1) * width_ratio","x1*".concat(n," + f32(x)*(width_scale)")]:["0.0","0.0","0.5 * (x1+x2) * ".concat(n)],3),u=s[0],c=s[1],d=s[2];return"\n    ".concat(getMainHeaderString("index")," {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let height_ratio = f32(").concat(r,");\n        let width_ratio = f32(").concat(u,");\n        let b = coords[0];\n        let y = coords[1];\n        let x = coords[2];\n        let d = coords[3];\n        // get box vals\n        let y1 = getBoxes(b, 0);\n        let x1 = getBoxes(b, 1);\n        let y2 = getBoxes(b, 2);\n        let x2 = getBoxes(b, 3);\n        // get image in batch index\n        let bInd = i32(round(getBoxInd(b)));\n        if(bInd < 0 || bInd >= uniforms.outShape[0]) {\n          return;\n        }\n        let height_scale = ").concat(i,";\n        let width_scale = ").concat(c,";\n        let in_y = ").concat(o,";\n        if( in_y < 0.0 || in_y > ").concat(t," ) {\n          setOutputAtIndex(index, uniforms.extrapolationValue);\n          return;\n        }\n        let in_x = ").concat(d,";\n        if( in_x < 0.0 || in_x > ").concat(n," ) {\n          setOutputAtIndex(index, uniforms.extrapolationValue);\n          return;\n        }\n        let sourceFracIndexCR = vec2<f32>(in_x,in_y);\n        if(").concat(this.methodId," == 1) {\n          // Compute the four integer indices.\n          let sourceFloorCR = vec2<i32>(sourceFracIndexCR);\n          let sourceCeilCR = vec2<i32>(ceil(sourceFracIndexCR));\n          let topLeft = getImage(bInd, sourceFloorCR.y, sourceFloorCR.x, d);\n          let bottomLeft = getImage(bInd, sourceCeilCR.y, sourceFloorCR.x, d);\n          let topRight = getImage(bInd, sourceFloorCR.y, sourceCeilCR.x, d);\n          let bottomRight = getImage(bInd, sourceCeilCR.y, sourceCeilCR.x, d);\n          let fracCR = sourceFracIndexCR - vec2<f32>(sourceFloorCR);\n          let top = topLeft + (topRight - topLeft) * fracCR.x;\n          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          let newValue = top + (bottom - top) * fracCR.y;\n          setOutputAtIndex(index, newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          let sourceNearestCR = vec2<i32>(floor(\n            sourceFracIndexCR + vec2<f32>(0.5,0.5)));\n          let newValue = getImage(\n            bInd, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutputAtIndex(index, newValue);\n        }\n      }\n    }\n    ")},CropAndResizeProgram}(),tC={kernelName:p.CropAndResize,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,a=e.attrs,r=t.image,i=t.boxes,o=t.boxInd,s=a.cropSize,u=a.method,c=a.extrapolationValue,d=new tw(r.shape[3],i.shape,s,u),p=[{type:"float32",data:[c]}];return n.runWebGPUProgram(d,[r,i,o],"float32",p)}};!function(e){e.Prod="*",e.Sum="+"}(s||(s={}));var tk=function(){function CumProgram(e,t,n,a){this.variableNames=["x"],this.uniforms="index : f32,",this.size=!0,this.workgroupSize=[128,1,1],this.outputShape=t,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.exclusive=n,this.reverse=a,this.op=e,this.shaderKey="cum_".concat(this.op,"_").concat(this.exclusive,"_").concat(this.reverse)}return CumProgram.prototype.getUserCode=function(){var e=this.outputShape.length,t=this.op===s.Prod?"1.0":"0.0",n=this.exclusive?t:"getX(".concat(getCoords(e,"coords",this.op),")"),a=this.outputShape[this.outputShape.length-1],r="",i="";return this.exclusive?(r=this.reverse?"end != ".concat(a-1):"end != 0",i=this.reverse?"end + 1":"end - 1"):(r=this.reverse?"end + pow2 < ".concat(a):"end >= pow2",i=this.reverse?"end + pow2":"end - pow2"),"\n      ".concat(getMainHeaderString("index")," {\n       if (index < uniforms.size) {\n         var coords = getCoordsFromIndex(index);\n\n         let end = ").concat(getFinalCoord(e,"coords",this.op),";\n         var val = ").concat(n,";\n         let pow2 = i32(pow(2.0, uniforms.index));\n         if (").concat(r,") {\n           let idx = ").concat(i,";\n           ").concat(getFinalCoord(e,"coords",this.op)," = idx;\n           val ").concat(this.op,"= getX(").concat(getCoords(e,"coords",this.op),");\n         }\n         setOutputAtIndex(index, val);\n       }\n      }\n    ")},CumProgram}();function getCoords(e,t,n){if(1===e)return"".concat(t);if(2===e)return"".concat(t,".x, ").concat(t,".y");if(3===e)return"".concat(t,".x, ").concat(t,".y, ").concat(t,".z");if(4===e)return"".concat(t,".x, ").concat(t,".y, ").concat(t,".z, ").concat(t,".w");throw Error("Cumulative ".concat(n," for rank ").concat(e," is not yet supported"))}function getFinalCoord(e,t,n){if(1===e)return"".concat(t);if(2===e)return"".concat(t,".y");if(3===e)return"".concat(t,".z");if(4===e)return"".concat(t,".w");throw Error("Cumulative ".concat(n," for rank ").concat(e," is not yet supported"))}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cumImpl(e,t,n,a,r,i){var o=t.shape.length,s=p.backend_util.getAxesPermutation([a],o),u=t;null!=s&&(u=transpose({inputs:{x:t},backend:n,attrs:{perm:s}}));var c=p.backend_util.getInnerMostAxes(1,o)[0];if(c!==o-1)throw Error("WebGPU cumprod shader expects an inner-most axis=".concat(t.shape.length-1," ")+"but got axis=".concat(a));for(var d=u.shape[c],l=identity({inputs:{x:u},backend:n}),h=0;h<=Math.ceil(Math.log2(d))-1;h++){var f=new tk(e,u.shape,!1,i),m=l,g=[{type:"float32",data:[h]}];l=n.runWebGPUProgram(f,[l],l.dtype,g),n.disposeData(m.dataId)}if(r){var f=new tk(e,u.shape,r,i),m=l,g=[{type:"float32",data:[0]}];l=n.runWebGPUProgram(f,[l],l.dtype,g),n.disposeData(m.dataId)}if(null!=s){var y=transpose({inputs:{x:l},backend:n,attrs:{perm:p.backend_util.getUndoAxesPermutation(s)}});return n.disposeData(l.dataId),n.disposeData(u.dataId),y}return l}var tI={kernelName:p.Cumprod,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var t=e.inputs,n=e.backend,a=e.attrs,r=t.x,i=a.axis,o=a.exclusive,u=a.reverse;return cumImpl(s.Prod,r,n,i,o,u)}},tP={kernelName:p.Cumsum,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var t=e.inputs,n=e.backend,a=e.attrs,r=t.x,i=a.axis,o=a.exclusive,u=a.reverse;return cumImpl(s.Sum,r,n,i,o,u)}},tR={kernelName:p.DenseBincount,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var t=e.inputs,n=e.backend,a=e.attrs,r=t.x,i=t.weights,o=a.size,s=a.binaryOutput,u=1===r.shape.length,c=p.util.sizeFromShape(i.shape)>0,d=i.dtype,l=u?[r.shape[0]]:[r.shape[0],r.shape[1]],h=fill({backend:n,attrs:{shape:u?[o]:[r.shape[0],o],value:0,dtype:d}}),f=new ej(l,c,s),m=[{type:"int32",data:[o]}],g=c?[r,i]:[r];return n.runWebGPUProgram(f,g,d,m,h)}},tD=function(){function DepthToSpaceProgram(e,t){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.uniforms="blockSize : i32,",this.outputShape=e,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthToSpace_".concat(t),this.dataFormat=t}return DepthToSpaceProgram.prototype.getUserCode=function(){return"\n      ".concat(getMainHeaderString("index")," {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let b = coords[0];\n          let h = ").concat(this.getHeightCoordString(),";\n          let w = ").concat(this.getWidthCoordString(),";\n          let d = ").concat(this.getDepthCoordString(),";\n\n          let in_h = h / uniforms.blockSize;\n          let offset_h = h % uniforms.blockSize;\n          let in_w = w / uniforms.blockSize;\n          let offset_w = w % uniforms.blockSize;\n          let offset_d = (offset_h * uniforms.blockSize + offset_w) *\n            ").concat(this.getOutputDepthSize(),";\n          let in_d = d + offset_d;\n\n          let rlt = ").concat(this.getInputSamplingString(),";\n          setOutputAtIndex(index, rlt);\n        }\n      }")},DepthToSpaceProgram.prototype.getHeightCoordString=function(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"},DepthToSpaceProgram.prototype.getWidthCoordString=function(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"},DepthToSpaceProgram.prototype.getDepthCoordString=function(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"},DepthToSpaceProgram.prototype.getOutputDepthSize=function(){return"NHWC"===this.dataFormat?"uniforms.outShape[3]":"uniforms.outShape[1]"},DepthToSpaceProgram.prototype.getInputSamplingString=function(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"},DepthToSpaceProgram}(),t_={kernelName:p.DepthToSpace,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var t=e.inputs,n=e.backend,a=e.attrs,r=t.x,i=a.blockSize,o=a.dataFormat,s=r.shape[0],u="NHWC"===o?r.shape[1]:r.shape[2],c="NHWC"===o?r.shape[2]:r.shape[3],d="NHWC"===o?r.shape[3]:r.shape[1],p=u*i,l=c*i,h=d/(i*i),f="NHWC"===o?[s,p,l,h]:[s,h,p,l],m=[{type:"int32",data:[i]}],g=new tD(f,o);return n.runWebGPUProgram(g,[r],r.dtype,m)}},tA=function(){function DepthwiseConv2DNCHWSharedProgram(e,t,n,a,r,i){void 0===a&&(a=!1),void 0===r&&(r=null),void 0===i&&(i=!1),this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>,",this.workgroupSize=[16,16,1],this.outputShape=e,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),a&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),this.addBias=a,this.activation=r,this.hasPreluActivation=i,this.filterHeight=t,this.filterWidth=n,this.shaderKey="depthwiseNCHW_".concat(this.activation,"_").concat(this.filterHeight,"_").concat(this.filterWidth)}return DepthwiseConv2DNCHWSharedProgram.prototype.getUserCode=function(){var e=this.filterWidth*this.filterHeight,t=this.workgroupSize[0]*this.workgroupSize[1]*this.workgroupSize[2],n=this.workgroupSize[1]+this.filterHeight-1,a=this.workgroupSize[0]+this.filterWidth-1;return"\n      ".concat(activationFnSnippet(this.activation,this.hasPreluActivation,!1,4),"\n\n      var<workgroup> mm_Asub : array<array<f32, ").concat(a,">, ").concat(n,">;\n      var<workgroup> mm_Bsub : array<array<f32, ").concat(this.filterWidth,">, ").concat(this.filterHeight,">;\n      fn readX(batch : i32, channel : i32, row : i32, col : i32) -> f32 {\n        var value = 0.0;\n        if (row >=0 && row < uniforms.inDims[0] && col >=0 && col < uniforms.inDims[1])\n        {\n          value = getX(batch, channel, row, col);\n        }\n        return value;\n      }\n\n      ").concat(getMainHeaderString()," {\n        let coords = getOutputCoords();\n        let batch = coords[0];\n        let xRCCorner = vec2<i32>(coords.zw) - uniforms.pads;\n        let channelMul = uniforms.wShape[3];\n        let d1 = coords[1] / channelMul;\n        let q = coords[1] % channelMul;\n\n        let inputRowStart = xRCCorner.x;\n        let inputColStart = xRCCorner.y;\n\n        let localRow = i32(localId.y);\n        let localCol = i32(localId.x);\n\n        // Load one tile of X into local memory.\n        for (var inputRow = localRow; inputRow < ").concat(n,"; inputRow = inputRow + ").concat(this.workgroupSize[1],") {\n          for (var inputCol = localCol; inputCol < ").concat(a,"; inputCol = inputCol + ").concat(this.workgroupSize[0],") {\n            let rowOffset = inputRow - localRow;\n            let colOffset = inputCol - localCol;\n            mm_Asub[inputRow][inputCol] = readX(batch, d1, inputRowStart + rowOffset, inputColStart + colOffset);\n          }\n        }\n\n        // Load one tile of W into local memory.\n        var wIndex = i32(localIndex);\n        ").concat(e<t?"if (wIndex < ".concat(e,")"):"for(; wIndex < ".concat(e,"; wIndex = wIndex + ").concat(t,")"),"\n\n        {\n          let wRow = wIndex / ").concat(this.filterWidth,";\n          let wCol = wIndex % ").concat(this.filterWidth,";\n          mm_Bsub[wRow][wCol] = getW(wRow, wCol, d1, q);\n        }\n\n        workgroupBarrier();\n\n        var value = 0.0;\n        for (var wR = 0; wR < ").concat(this.filterHeight,"; wR = wR + 1) {\n          for (var wC = 0; wC < ").concat(this.filterWidth,"; wC = wC + 1) {\n            let xVal = mm_Asub[localRow + wR][localCol + wC];\n            let wVal = mm_Bsub[wR][wC];\n            value = fma(xVal, wVal, value);\n          }\n        }\n        ").concat(biasActivationSnippet(this.addBias,this.activation),"\n        if (coordsInBounds4D(coords, uniforms.outShape)) {\n          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n        }\n      }\n    ")},DepthwiseConv2DNCHWSharedProgram}(),tz=function(){function DepthwiseConv2DVec4Program(e,t,n,a){void 0===t&&(t=!1),void 0===n&&(n=null),void 0===a&&(a=!1),this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>, virtualWidth : i32,",this.workgroupSize=[64,1,1],this.workPerThread=4,this.outputComponent=4,this.outputShape=e.outShape,this.virtualWidth=Math.ceil(this.outputShape[2]/this.workPerThread)*this.workPerThread;var r=[this.outputShape[0],this.outputShape[1],this.virtualWidth,this.outputShape[3]];this.dispatchLayout=flatDispatchLayout(r),this.dispatch=computeDispatch(this.dispatchLayout,r,this.workgroupSize,[this.outputComponent*this.workPerThread,1,1]),p.util.assert("channelsLast"===e.dataFormat,function(){return"TODO: NCHW is unimplemented"}),t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=n,this.hasPreluActivation=a,this.shaderKey="depthwiseVec4_".concat(n,"_").concat(this.convInfo.filterHeight,"_").concat(this.convInfo.filterWidth,"_").concat(this.convInfo.strideHeight,"_").concat(this.convInfo.strideWidth,"_").concat(this.workPerThread)}return DepthwiseConv2DVec4Program.prototype.getUserCode=function(){var e=(this.workPerThread-1)*this.convInfo.strideWidth+this.convInfo.filterWidth,t=this.convInfo.strideHeight,n=this.convInfo.strideWidth;return"\n      ".concat(activationFnSnippet(this.activation,this.hasPreluActivation,!0,4),"\n      fn readX(batch : i32, row : i32, col : i32, channel : i32) -> vec4<f32> {\n        var value = vec4<f32>(0.0);\n        if (col >=0 && col < uniforms.inDims[1]) {\n          value = getX(batch, row, col, channel);\n        }\n        return value;\n      }\n\n      ").concat(getMainHeaderString("index")," {\n        let width0 = uniforms.outShape[3] / ").concat(this.outputComponent,";\n        let d1 = (index % width0) * ").concat(this.outputComponent,";\n        var index1 = index / width0;\n        let width1 = uniforms.virtualWidth / ").concat(this.workPerThread,";\n        let c = (index1 % width1) * ").concat(this.workPerThread,";\n        index1 = index1 / width1;\n        let r = index1 % uniforms.outShape[1];\n        let batch = index1 / uniforms.outShape[1];\n\n        let xRCCorner = vec2<i32>(r, c) * vec2<i32>(").concat(t,", ").concat(n,") - uniforms.pads;\n\n        let xRCorner = xRCCorner.x;\n        let xCCorner = xRCCorner.y;\n        var xVals : array<vec4<f32>, ").concat(e,">;\n        var dotProd : array<vec4<f32>, ").concat(this.workPerThread,">;\n        for (var i = 0; i < ").concat(this.workPerThread,"; i++) {\n          dotProd[i] = vec4<f32>(0.0);\n        }\n\n        // Use constant instead of uniform can give better performance.\n        for (var wR = 0; wR < ").concat(this.convInfo.filterHeight,"; wR = wR + 1) {\n          let xR = xRCorner + wR;\n          if (xR >=0 && xR < uniforms.inDims[0]) {\n            for (var i = 0; i < ").concat(e,"; i++) {\n              xVals[i] = readX(batch, xR, xCCorner + i, d1);\n            }\n            for (var wC = 0; wC < ").concat(this.convInfo.filterWidth,"; wC = wC + 1) {\n              let wValue = getW(wR, wC, d1, 0);\n              for (var i = 0; i < ").concat(this.workPerThread,"; i++) {\n                dotProd[i] = fma(xVals[i * ").concat(n," + wC], wValue, dotProd[i]);\n              }\n            }\n          }\n        }\n\n        for (var i = 0; i < ").concat(this.workPerThread,"; i = i + 1) {\n          let coords = vec4<i32>(batch, r, c + i, d1);\n          if (coordsInBounds4D(coords, uniforms.outShape)) {\n            var value = dotProd[i];\n            ").concat(biasActivationSnippet(this.addBias,this.activation),"\n            setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n          }\n        }\n      }\n    ")},DepthwiseConv2DVec4Program}(),tN=function(){function DepthwiseConv2DProgram(e,t,n,a){void 0===t&&(t=!1),void 0===n&&(n=null),void 0===a&&(a=!1),this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>, filterHeight : i32,\n      filterWidth : i32, strides : vec2<i32>, dilations : vec2<i32>,",this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast="channelsLast"===e.dataFormat,t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=n,this.hasPreluActivation=a,this.shaderKey="depthwise_".concat(this.activation,"_").concat(this.isChannelsLast)}return DepthwiseConv2DProgram.prototype.getUserCode=function(){var e=this.isChannelsLast?"getX(batch, xR, xC, d1);":"getX(batch, d1, xR, xC);";return"\n      ".concat(activationFnSnippet(this.activation,this.hasPreluActivation,!1,4),"\n\n      ").concat(getMainHeaderString("index")," {\n        if (index < uniforms.size) {\n          let coords = getOutputCoords();\n          let batch = coords[0];\n          let xRCCorner = vec2<i32>(coords.").concat(this.isChannelsLast?"yz":"zw",") * uniforms.strides - uniforms.pads;\n          let d2 = coords[").concat(this.isChannelsLast?3:1,"];\n          let channelMul = uniforms.wShape[3];\n          let d1 = d2 / channelMul;\n          let q = d2 % channelMul;\n\n          let inputRowStart = xRCCorner.x;\n          let inputColStart = xRCCorner.y;\n          let inputRowEnd = inputRowStart + uniforms.filterHeight *\n              uniforms.dilations[0];\n          let inputColEnd = inputColStart + uniforms.filterWidth *\n              uniforms.dilations[1];\n\n          // Convolve x(?, ?, d1)|x(d1, ?, ?) with w(:, :, d1, q) to get\n          // y(yR, yC, d2)|y(d2, yR, yC). ? = to be determined. : = across all\n          // values in that axis. x(?, ?, d1) and y(yR, yC, d2) is for NHWC.\n          // x(d1, ?, ?) and y(d2, yR, yC) is for NCHW.\n          var value = 0.0;\n\n          // Extract if checking out of for loop for performance.\n          if (inputRowStart >= 0 && inputColStart >= 0 &&\n            inputRowEnd < uniforms.inDims[0] &&\n                inputColEnd < uniforms.inDims[1]) {\n              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {\n                let xR = inputRowStart + wR * uniforms.dilations[0];\n\n                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {\n                  let xC = inputColStart + wC * uniforms.dilations[1];\n\n                  let xVal = ").concat(e,";\n                  let wVal = getW(wR, wC, d1, q);\n                  value = value + xVal * wVal;\n                }\n              }\n            } else {\n              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {\n                let xR = inputRowStart + wR * uniforms.dilations[0];\n\n                if (xR < 0 || xR >= uniforms.inDims[0]) {\n                  continue;\n                }\n\n                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {\n                  let xC = inputColStart + wC * uniforms.dilations[1];\n\n                  if (xC < 0 || xC >= uniforms.inDims[1]) {\n                    continue;\n                  }\n\n                  let xVal = ").concat(e,";\n                  let wVal = getW(wR, wC, d1, q);\n                  value = value + xVal * wVal;\n                }\n              }\n            }\n            ").concat(biasActivationSnippet(this.addBias,this.activation),"\n          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n        }\n      }\n    ")},DepthwiseConv2DProgram}(),tF={kernelName:p.DepthwiseConv2dNative,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var t,n=e.inputs,a=e.backend,r=e.attrs,i=n.x,o=n.filter,s=r.strides,u=r.pad,c=r.dataFormat,d=r.dilations,l=r.dimRoundingMode,h=p.backend_util.convertConv2DDataFormat(c),f=d;null==f&&(f=[1,1]);var m=p.backend_util.computeConv2DInfo(i.shape,o.shape,s,f,u,l,!0,h),g=[{type:"int32",data:[m.padInfo.top,m.padInfo.left]},{type:"int32",data:[m.inHeight,m.inWidth]}],y="channelsLast"===m.dataFormat;return!y&&m.inHeight>16&&m.inWidth>16&&1===m.strideHeight&&1===m.strideWidth&&1===m.dilationWidth&&1===m.dilationHeight&&m.inChannels===m.outChannels?t=new tA(m.outShape,m.filterHeight,m.filterWidth):y&&m.outHeight>4&&m.outWidth>4&&m.strideWidth<=2&&m.inChannels===m.outChannels&&1===m.dilationHeight&&1===m.dilationWidth&&m.inChannels%4==0?(t=new tz(m),g.push({type:"int32",data:[t.virtualWidth]})):(t=new tN(m),g.push({type:"int32",data:[m.filterHeight]},{type:"int32",data:[m.filterWidth]},{type:"int32",data:[m.strideHeight,m.strideWidth]},{type:"int32",data:[m.dilationHeight,m.dilationWidth]})),a.runWebGPUProgram(t,[i,o],i.dtype,g)}},tT=function(){function DepthwiseConv2DDerFilterProgram(e){this.variableNames=["x","dy"],this.uniforms="strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>, outHeight : i32,\n      outWidth : i32, inHeight : i32, inWidth : i32, batchSize : i32, channelMul : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthwise_conv2d_backprop_filter"}return DepthwiseConv2DDerFilterProgram.prototype.getUserCode=function(){return"\n      ".concat(getMainHeaderString("index")," {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let wR = coords[0];\n        let wC = coords[1];\n        let d1 = coords[2];\n        let dm = coords[3];\n        let d2 = d1 * uniforms.channelMul + dm;\n\n        var dotProd = 0.0;\n        for (var b = 0; b < uniforms.batchSize; b++) {\n          for (var yR = 0; yR < uniforms.outHeight; yR++) {\n            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];\n\n            if (xR < 0 || xR >= uniforms.inHeight) {\n              continue;\n            }\n\n            for (var yC = 0; yC < uniforms.outWidth; yC++) {\n              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];\n\n              if (xC < 0 || xC >= uniforms.inWidth) {\n                continue;\n              }\n\n              let dyValue = getDy(b, yR, yC, d2);\n              let xValue = getX(b, xR, xC, d1);\n              dotProd += xValue * dyValue;\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n    ")},DepthwiseConv2DDerFilterProgram}(),tB=function(){function DepthwiseConv2DDerInputProgram(e){this.variableNames=["dy","W"],this.uniforms="strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>,\n       outHeight : i32, outWidth : i32, channelMul : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthwise_conv2d_backprop_input"}return DepthwiseConv2DDerInputProgram.prototype.getUserCode=function(){return"\n      ".concat(getMainHeaderString("index")," {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords[0];\n        let d1 = coords[3];\n        let dyCorner = coords.yz - uniforms.pads;\n        let dyRCorner = dyCorner.x;\n        let dyCCorner = dyCorner.y;\n\n        var dotProd = 0.0;\n        for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {\n          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);\n\n          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {\n            continue;\n          }\n\n          let idyR = i32(dyR);\n          let wRPerm = uniforms.filterDims[0] - 1 - wR;\n\n          for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {\n            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);\n\n            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {\n              continue;\n            }\n\n            let idyC = i32(dyC);\n            let wCPerm = uniforms.filterDims[1] - 1 - wC;\n\n            for (var dm = 0; dm < uniforms.channelMul; dm++) {\n              let d2 = d1 * uniforms.channelMul + dm;\n              let xValue = getDy(batch, idyR, idyC, d2);\n              let wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n    ")},DepthwiseConv2DDerInputProgram}(),tL={kernelName:p.DepthwiseConv2dNativeBackpropFilter,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var t=e.inputs,n=e.backend,a=e.attrs,r=t.x,i=t.dy,o=a.strides,s=a.dilations,u=a.pad,c=a.dimRoundingMode,d=a.filterShape,l=p.backend_util.computeConv2DInfo(r.shape,d,o,s,u,c,!0),h=new tT(l),f=[{type:"int32",data:[l.strideHeight,l.strideWidth]},{type:"int32",data:[l.padInfo.top,l.padInfo.left]},{type:"int32",data:[l.filterHeight,l.filterWidth]},{type:"int32",data:[l.outHeight]},{type:"int32",data:[l.outWidth]},{type:"int32",data:[l.inHeight]},{type:"int32",data:[l.inWidth]},{type:"int32",data:[l.batchSize]},{type:"int32",data:[l.outChannels/l.inChannels]}];return n.runWebGPUProgram(h,[r,i],"float32",f)}},tM={kernelName:p.DepthwiseConv2dNativeBackpropInput,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var t=e.inputs,n=e.backend,a=e.attrs,r=t.dy,i=t.filter,o=a.strides,s=a.dilations,u=a.pad,c=a.dimRoundingMode,d=a.inputShape,l=p.backend_util.computeConv2DInfo(d,i.shape,o,s,u,c,!0),h=new tB(l),f=[{type:"int32",data:[l.strideHeight,l.strideWidth]},{type:"int32",data:[l.filterHeight-1-l.padInfo.top,l.filterWidth-1-l.padInfo.left]},{type:"int32",data:[l.filterHeight,l.filterWidth]},{type:"int32",data:[l.outHeight]},{type:"int32",data:[l.outWidth]},{type:"int32",data:[l.outChannels/l.inChannels]}];return n.runWebGPUProgram(h,[r,i],r.dtype,f)}},tW=function(){function DiagProgram(e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,e],this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="diag"}return DiagProgram.prototype.getUserCode=function(){return"\n      ".concat(getMainHeaderString("index")," {\n        if (index < uniforms.size) {\n          let coords = getOutputCoords();\n          let value = select(0.0, getX(coords[0]), coords[0] == coords[1]);\n          setOutputAtIndex(index, value);\n        }\n      }\n    ")},DiagProgram}(),tU={kernelName:p.Diag,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,a=t.x,r=__spreadArray(__spreadArray([],__read(a.shape),!1),__read(a.shape),!1),i=p.util.sizeFromShape(a.shape),o=reshape({inputs:{x:a},backend:n,attrs:{shape:[i]}}),s=new tW(i),u=n.runWebGPUProgram(s,[o],o.dtype),c=reshape({inputs:{x:u},backend:n,attrs:{shape:r}});return n.disposeData(o.dataId),n.disposeData(u.dataId),c}},tE=function(){function Dilation2DProgram(e){this.variableNames=["x","w"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="dilation2d"}return Dilation2DProgram.prototype.getUserCode=function(){return"\n       ".concat(getMainHeaderString("index")," {\n         if (index < uniforms.size) {\n           let neg_infinity = -3.4e38;\n           let coords = getOutputCoords();\n           let batch = coords.x;\n           let d1 = coords.w;\n           let outTopLeftCorner = coords.yz * uniforms.strides - uniforms.pads;\n           let hBeg = outTopLeftCorner.x;\n           let wBeg = outTopLeftCorner.y;\n\n           var curVal = neg_infinity;\n           for (var h = 0; h < uniforms.filterDims[0]; h = h + 1) {\n             let hIn = hBeg + h * uniforms.dilations[0];\n\n             if (hIn >= 0 && hIn < uniforms.xShape[1]) {\n               for (var w = 0; w < uniforms.filterDims[1]; w = w + 1) {\n                 let wIn = wBeg + w * uniforms.dilations[1];\n\n                 if (wIn >= 0 && wIn < uniforms.xShape[2]) {\n                   let val = getX(batch, hIn, wIn, d1) + getW(h, w, d1);\n                   if (val > curVal) {\n                     curVal = val;\n                   }\n                 }\n               }\n             }\n           }\n\n           setOutputAtIndex(index, curVal);\n         }\n       }\n     ")},Dilation2DProgram}(),tO={kernelName:p.Dilation2D,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,a=e.attrs,r=t.x,i=t.filter,o=a.strides,s=a.pad,u=a.dilations,c=p.backend_util.computeDilation2DInfo(r.shape,i.shape,o,s,"NHWC",u),d=[c.padInfo.top,c.padInfo.left],l=[{type:"int32",data:[c.filterHeight,c.filterWidth]},{type:"int32",data:__spreadArray([],__read(d),!1)},{type:"int32",data:[c.strideHeight,c.strideWidth]},{type:"int32",data:[c.dilationHeight,c.dilationWidth]}],h=new tE(c);return n.runWebGPUProgram(h,[r,i],r.dtype,l)}},tV=function(){function Dilation2DBackpropInputProgram(e,t){if(this.variableNames=["x","w","dy"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e.inShape,this.dispatchLayout=flatDispatchLayout(e.outShape),this.dispatch=computeDispatch(this.dispatchLayout,e.outShape,this.workgroupSize),"float32"!==t&&"int32"!==t)throw Error("Dilation2DBackpropInput only supports float32 and int32\n          types, does not support ".concat(t," type."));this.type=t,this.shaderKey="dilation2DBackpropInput"}return Dilation2DBackpropInputProgram.prototype.getUserCode=function(){return"\n       ".concat(getMainHeaderString("index")," {\n         if (index < uniforms.dySize) {\n           let coords = getDyCoordsFromIndex(index);\n           let b = coords[0];\n           let r = coords[1];\n           let c = coords[2];\n           let d = coords[3];\n\n           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;\n           var curVal = -3.4e38;  // neg_infinity\n           var xRMax = 0;\n           var xCMax = 0;\n\n           // In the case of multiple argmax branches, we only back-propagate\n           // along the last branch, i.e., the one with largest value of\n           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling\n           // backward routines.\n           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {\n             let xR = dyCorner.x + wR * uniforms.dilations[0];\n\n             if (xR >= 0 && xR < uniforms.xShape[1]) {\n               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {\n                 let xC = dyCorner.y + wC * uniforms.dilations[1];\n\n                 if (xC >= 0 && xC < uniforms.xShape[2]) {\n                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);\n                   if (val > curVal) {\n                     curVal = val;\n                     xRMax = xR;\n                     xCMax = xC;\n                   }\n                 }\n               }\n             }\n           }\n\n           let flatIndexIn = d + uniforms.xShape[3] *\n               (xCMax + uniforms.xShape[2] * (xRMax + uniforms.xShape[1] * b));\n           let value = getDy(b, r, c, d);\n           ").concat(atomicAddSnippet("&result[flatIndexIn]","value",this.type),"\n         }\n       }\n     ")},Dilation2DBackpropInputProgram}(),tG=function(){function Dilation2DBackpropFilterProgram(e,t,n){if(this.variableNames=["x","w","dy"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e.filterShape,this.dispatchLayout=flatDispatchLayout(e.outShape),this.dispatch=computeDispatch(this.dispatchLayout,e.outShape,this.workgroupSize),"float32"!==n&&"int32"!==n)throw Error("Dilation2DBackpropFilter only supports float32 and int32\n          types, does not support ".concat(n," type."));this.type=n,this.shaderKey="dilation2DBackpropFilter"}return Dilation2DBackpropFilterProgram.prototype.getUserCode=function(){return"\n       ".concat(getMainHeaderString("index")," {\n         if (index < uniforms.dySize) {\n           let coords = getDyCoordsFromIndex(index);\n           let b = coords[0];\n           let r = coords[1];\n           let c = coords[2];\n           let d = coords[3];\n\n           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;\n           var curVal = -3.4e38;  // neg_infinity\n           var wRMax = 0;\n           var wCMax = 0;\n\n           // In the case of multiple argmax branches, we only back-propagate\n           // along the last branch, i.e., the one with largest value of\n           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling\n           // backward routines.\n           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {\n             let xR = dyCorner.x + wR * uniforms.dilations[0];\n\n             if (xR >= 0 && xR < uniforms.xShape[1]) {\n               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {\n                 let xC = dyCorner.y + wC * uniforms.dilations[1];\n\n                 if (xC >= 0 && xC < uniforms.xShape[2]) {\n                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);\n                   if (val > curVal) {\n                     curVal = val;\n                     wRMax = wR;\n                     wCMax = wC;\n                   }\n                 }\n               }\n             }\n           }\n\n           let flatIndexIn = d + uniforms.wShape[2] * (wCMax + wRMax * uniforms.wShape[1]);\n           let value = getDy(b, r, c, d);\n           ").concat(atomicAddSnippet("&result[flatIndexIn]","value",this.type),"\n         }\n       }\n     ")},Dilation2DBackpropFilterProgram}(),tH={kernelName:p.Dilation2DBackpropFilter,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var t=e.inputs,n=e.backend,a=e.attrs,r=t.x,i=t.filter,o=t.dy,s=a.strides,u=a.pad,c=a.dilations,d=p.backend_util.computeDilation2DInfo(r.shape,i.shape,s,u,"NHWC",c),l=i.dtype,h=new tG(d,i.shape,l),f=[{type:"int32",data:[d.filterHeight,d.filterWidth]},{type:"int32",data:[d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]},{type:"int32",data:[p.util.sizeFromShape(d.outShape)]}],m=fill({backend:n,attrs:{shape:i.shape,value:0,dtype:l}});return n.runWebGPUProgram(h,[r,i,o],l,f,m)}},tK={kernelName:p.Dilation2DBackpropInput,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var t=e.inputs,n=e.backend,a=e.attrs,r=t.x,i=t.filter,o=t.dy,s=a.strides,u=a.pad,c=a.dilations,d=p.backend_util.computeDilation2DInfo(r.shape,i.shape,s,u,"NHWC",c),l=r.dtype,h=new tV(d,l),f=[{type:"int32",data:[d.filterHeight,d.filterWidth]},{type:"int32",data:[d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]},{type:"int32",data:[p.util.sizeFromShape(d.outShape)]}],m=fill({backend:n,attrs:{shape:d.inShape,value:0,dtype:l}});return n.runWebGPUProgram(h,[r,i,o],l,f,m)}},tX=function(){function DrawProgram(e,t,n){this.variableNames=["Image"],this.uniforms="alpha: f32,",this.workgroupSize=[64,1,1],this.pixelsOpType=a.DRAW,this.size=!0,this.outputShape=e,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.type=t,this.textureFormat=n,this.shaderKey="draw_".concat(t,"_").concat(n)}return DrawProgram.prototype.getUserCode=function(){var e,t="float32"===this.type?"value":"value / 255.0";return e="\n      if (uniforms.numChannels == 1) {\n        rgba[0] = ".concat(t,";\n        rgba[1] = ").concat(t,";\n        rgba[2] = ").concat(t,";\n      } else {\n        rgba[d] = ").concat(t,";\n      }"),"\n       @group(0) @binding(0) var outImage : texture_storage_2d<".concat(this.textureFormat,", write>;\n       ").concat(getMainHeaderString("index")," {\n         if (index < uniforms.size) {\n           var rgba = vec4<f32>(0.0, 0.0, 0.0, uniforms.alpha);\n           for (var d = 0; d < uniforms.numChannels; d = d + 1) {\n             let value = f32(inBuf[index * uniforms.numChannels + d]);\n             ").concat(e,"\n           }\n           rgba.x = rgba.x * rgba.w;\n           rgba.y = rgba.y * rgba.w;\n           rgba.z = rgba.z * rgba.w;\n           let coords = getCoordsFromIndex(index);\n           textureStore(outImage, vec2<i32>(coords.yx), rgba);\n         }\n       }\n      ")},DrawProgram}(),tq={kernelName:p.Draw,backendName:"webgpu",kernelFunc:function(e){var t,n=e.inputs,a=e.backend,r=e.attrs,i=n.image,o=r.canvas,s=r.options,u=__read(i.shape.slice(0,2),2),c=u[0],d=u[1],p=(s||{}).imageOptions,l=(null==p?void 0:p.alpha)||1,h=a.device.features.has("bgra8unorm-storage")?"bgra8unorm":"rgba8unorm",f=[c,d],m=new tX(f,i.dtype,h);o.width=d,o.height=c;var g="webgpu",y=o.getContext(g);y||(y=(t=new OffscreenCanvas(d,c)).getContext(g));var v=3===i.shape.length?i.shape[2]:1;y.configure({device:a.device,format:h,usage:GPUTextureUsage.STORAGE_BINDING,alphaMode:"premultiplied"});var x="int32",b=a.makeTensorInfo(f,x),S=a.tensorMap.get(b.dataId);S.resource=y.getCurrentTexture(),S.external=!0;var w=[{type:"uint32",data:[v]},{type:"float32",data:[l]}];if(a.runWebGPUProgram(m,[i],x,w,b),t){var C=o.getContext("2d");if(!C)throw Error("Please make sure this canvas has only been used for 2d or webgpu context!");C.drawImage(t,0,0)}return a.disposeData(b.dataId),i}},tY=binaryKernelFunc({opType:i.MUL,cpuKernelImpl:Z,supportsComplex:!0}),tj={kernelName:p.Multiply,backendName:"webgpu",kernelFunc:tY};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sum(e){var t=e.inputs,n=e.backend,a=e.attrs;return reduce(t.x,a.axis,a.keepDims,"sum",n)}var tQ={kernelName:p.Sum,backendName:"webgpu",kernelFunc:sum},tZ={kernelName:p.Einsum,backendName:"webgpu",kernelFunc:function(e){var t,n,a,r,i=e.inputs,o=e.backend,s=e.attrs.equation,u=p.backend_util.decodeEinsumEquation(s,i.length),c=u.allDims,d=u.summedDims,l=u.idDims;p.backend_util.checkEinsumDimSizes(c.length,l,i);for(var h=p.backend_util.getEinsumComputePath(d,l),f=h.path,m=h.steps,g=m.length,y=null,v=c.length,x=[],b=0;b<g;++b){try{for(var S=(t=void 0,__values(m[b])),w=S.next();!w.done;w=S.next()){var C=w.value,k=p.backend_util.getEinsumPermutation(v,l[C]),I=k.permutationIndices,P=k.expandDims,R=void 0;p.backend_util.isIdentityPermutation(I)?R=i[C]:(R=transpose({inputs:{x:i[C]},backend:o,attrs:{perm:I}}),x.push(R));for(var D=R.shape.slice(),_=0;_<P.length;++_)D.splice(P[_],0,1);p.util.arraysEqual(R.shape,D)||(R=reshape({inputs:{x:R},backend:o,attrs:{shape:D}}),x.push(R)),null===y?y=R:(y=tY({inputs:{a:R,b:y},backend:o}),x.push(y))}}catch(e){t={error:e}}finally{try{w&&!w.done&&(n=S.return)&&n.call(S)}finally{if(t)throw t.error}}b<g-1&&(f[b]>=0&&(y=sum({inputs:{x:y},backend:o,attrs:{axis:f[b]-(c.length-v),keepDims:!1}}),x.push(y)),v--)}try{for(var A=__values(x),z=A.next();!z.done;z=A.next()){var N=z.value;N!==y&&o.disposeData(N.dataId)}}catch(e){a={error:e}}finally{try{z&&!z.done&&(r=A.return)&&r.call(A)}finally{if(a)throw a.error}}return y}},t$=unaryKernelFunc({opType:o.ELU}),tJ={kernelName:p.Elu,backendName:"webgpu",kernelFunc:t$},t2={kernelName:p.EluGrad,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,a=t.dy,r=t.y,o=new F(i.ELU_DER,a.shape,r.shape);return n.runWebGPUProgram(o,[a,r],a.dtype)}},t0=binaryKernelFunc({opType:i.EQUAL,dtype:"bool",cpuKernelImpl:U}),t1={kernelName:p.Equal,backendName:"webgpu",kernelFunc:t0},t3=unaryKernelFunc({opType:o.ERF}),t4={kernelName:p.Erf,backendName:"webgpu",kernelFunc:t3},t6=unaryKernelFunc({opType:o.EXP,cpuKernelImpl:E,dtype:"float32"}),t5={kernelName:p.Exp,backendName:"webgpu",kernelFunc:t6};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function expandDims(e){var t=e.inputs,n=e.attrs,a=e.backend,r=n.dim,i=t.input,o=i.shape.length,s=i.shape.slice(),u=r;return r<0&&(p.util.assert(-(o+1)<=r,function(){return"Axis must be in the interval [".concat(-(o+1),", ").concat(o,"]")}),u=o+r+1),s.splice(u,0,1),reshape({inputs:{x:i},backend:a,attrs:{shape:s}})}var t8={kernelName:p.ExpandDims,backendName:"webgpu",kernelFunc:expandDims},t9=unaryKernelFunc({opType:o.EXPM1,cpuKernelImpl:O}),t7={kernelName:p.Expm1,backendName:"webgpu",kernelFunc:t9},ne=function(){function FFTProgram(e,t){this.variableNames=["real","imag"],this.outputShape=[],this.uniforms="exponentMultiplier : f32, denominator: f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.component=e,this.shaderKey="fft_".concat(e)}return FFTProgram.prototype.getUserCode=function(){var e="real"===this.component?"return real * expR - imag * expI;":"return real * expI + imag * expR;";return"\n    fn unaryOpComplex(real: f32, expR: f32, imag: f32, expI: f32) -> f32 {\n      ".concat(e,"\n    }\n\n    fn mulMatDFT(batch: i32, index: i32) -> f32 {\n      let indexRatio = f32(index) / f32(uniforms.realShape[1]);\n      let exponentMultiplierTimesIndexRatio =\n          uniforms.exponentMultiplier * indexRatio;\n\n      var result = 0.0;\n\n      for (var i = 0; i < uniforms.realShape[1]; i = i + 1) {\n        // x = (-2|2 * PI / N) * index * i;\n        let x = exponentMultiplierTimesIndexRatio * f32(i);\n        let expR = cos(x);\n        let expI = sin(x);\n        let real = getReal(batch, i);\n        let imag = getImag(batch, i);\n\n        result = result +\n            unaryOpComplex(real, expR, imag, expI) / uniforms.denominator;\n      }\n\n      return result;\n    }\n\n    ").concat(getMainHeaderString("index")," {\n      if (index < uniforms.size) {\n        let coords = getOutputCoords();\n        setOutputAtIndex(index, mulMatDFT(coords[0], coords[1]));\n      }\n    }\n  ")},FFTProgram}();/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fftImpl(e,t,n){var a=n.tensorMap.get(e.dataId),r=p.util.sizeFromShape(e.shape),i=e.shape[e.shape.length-1],o=[],s=reshape({inputs:{x:e},backend:n,attrs:{shape:[r/i,i]}});o.push(s);var u=s.shape,c=new ne("real",u),d=new ne("imag",u),l=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:u},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:u}],h=[{type:"float32",data:[t?2*Math.PI:-2*Math.PI]},{type:"float32",data:[t?u[1]:1]}],f=n.runWebGPUProgram(c,l,"float32",h);o.push(f);var m=n.runWebGPUProgram(d,l,"float32",h);o.push(m);var g=complex({inputs:{real:f,imag:m},backend:n});o.push(g);var y=reshape({inputs:{x:g},backend:n,attrs:{shape:e.shape}});return o.forEach(function(e){return n.disposeData(e.dataId)}),y}var nt={kernelName:p.FFT,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var t=e.inputs,n=e.backend;return fftImpl(t.input,!1,n)}},nn=function(){function FlipLeftRightProgram(e){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="flipLeftRight"}return FlipLeftRightProgram.prototype.getUserCode=function(){return"\n      ".concat(getMainHeaderString("index")," {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let coordX = uniforms.xShape[2] - coords[2] - 1;\n          let outputValue = getX(coords[0], coords[1], coordX, coords[3]);\n          setOutputAtIndex(index, outputValue);\n        }\n      }\n    ")},FlipLeftRightProgram}(),na={kernelName:p.FlipLeftRight,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,a=t.image,r=new nn(a.shape);return n.runWebGPUProgram(r,[a],a.dtype)}},nr=unaryKernelFunc({opType:o.FLOOR,cpuKernelImpl:V}),ni={kernelName:p.Floor,backendName:"webgpu",kernelFunc:nr},no=binaryKernelFunc({opType:i.FLOOR_DIV,cpuKernelImpl:G,dtype:"int32"}),ns={kernelName:p.FloorDiv,backendName:"webgpu",kernelFunc:no},nu=function(){function FromPixelsProgram(e,t,n){void 0===n&&(n=!1),this.pixelsOpType=a.FROM_PIXELS,this.outputShape=[0],this.variableNames=[],this.workgroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize,[t,1,1]),this.importVideo=n,this.shaderKey="fromPixels_".concat(this.importVideo)}return FromPixelsProgram.prototype.getUserCode=function(){var e=this.importVideo?"textureLoad(src, vec2<i32>(coords.yx));":"textureLoad(src, vec2<i32>(coords.yx), 0)",t=this.importVideo?"texture_external":"texture_2d<f32>";return"\n      @binding(1) @group(0) var src: ".concat(t,";\n      ").concat(getMainHeaderString("index")," {\n        let flatIndex = index * uniforms.numChannels;\n        if (flatIndex < uniforms.size) {\n          let coords = getCoordsFromIndex(flatIndex);\n          let values = ").concat(e,";\n          for (var i = 0; i < uniforms.numChannels; i = i + 1) {\n            result[flatIndex + i] = i32(floor(255.0 * values[i]));\n          }\n        }\n      }\n  ")},FromPixelsProgram}(),nc={kernelName:p.FromPixels,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,a=e.attrs,r=t.pixels,i=a.numChannels;if(null==r)throw Error("pixels passed to tf.browser.fromPixels() can not be null");var o="undefined"!=typeof HTMLVideoElement&&r instanceof HTMLVideoElement,s="undefined"!=typeof HTMLImageElement&&r instanceof HTMLImageElement,c="undefined"!=typeof HTMLCanvasElement&&r instanceof HTMLCanvasElement||"undefined"!=typeof OffscreenCanvas&&r instanceof OffscreenCanvas,d="undefined"!=typeof ImageBitmap&&r instanceof ImageBitmap,l=__read(o?[r.videoWidth,r.videoHeight]:[r.width,r.height],2),h=l[0],f=l[1],m=[f,h,i],g=p.env().getBool("WEBGPU_IMPORT_EXTERNAL_TEXTURE")&&o,y=o||s;if(d||c||y){var v=void 0;if(g)v=n.device.importExternalTexture({source:r});else{if(y){var x=p.env().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(null==u||x!==nd)&&(nd=x,u=document.createElement("canvas").getContext("2d",{willReadFrequently:nd})),u.canvas.width=h,u.canvas.height=f,u.drawImage(r,0,0,h,f),r=u.canvas}var b=GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,S=n.textureManager.acquireTexture(m[1],m[0],"rgba8unorm",b);n.queue.copyExternalImageToTexture({source:r},{texture:S},[m[1],m[0]]),v=S}var w=p.util.sizeFromShape(m),C=p.util.computeStrides(m),k=new nu(m,i,g),I=[{type:"uint32",data:[w]},{type:"uint32",data:[i]},{type:"uint32",data:__spreadArray([],__read(C),!1)}],P=n.makeTensorInfo([f,h],"int32");n.tensorMap.get(P.dataId).resource=v;var R=n.runWebGPUProgram(k,[P],"int32",I);return n.disposeData(P.dataId),R}var D=r.data,_=D;if(null!=i&&4!==i){_=new Uint8Array(r.width*r.height*i);for(var A=D.length,z=0,N=0;N<A;N++)N%4<i&&(_[z++]=D[N])}var F=n.makeTensorInfo(m,"int32",new Int32Array(_));return n.uploadToGPU(F.dataId),F}},nd=p.env().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU"),np=function(){function BatchNormProgram(e,t,n,a,r){this.uniforms="varianceEpsilon : f32,",this.workgroupSize=[128,1,1],this.size=!0,this.variableNames=["x","mean","variance"],p.backend_util.assertAndGetBroadcastShape(e,t),p.backend_util.assertAndGetBroadcastShape(e,n),this.outputShape=e,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),null!=a&&(p.backend_util.assertAndGetBroadcastShape(e,a),this.variableNames.push("offset")),null!=r&&(p.backend_util.assertAndGetBroadcastShape(e,r),this.variableNames.push("scale")),this.offsetShape=a,this.scaleShape=r,this.shaderKey="batchNorm"}return BatchNormProgram.prototype.getUserCode=function(){var e="0.0";null!=this.offsetShape&&(e="getOffsetByOutputIndex(index)");var t="1.0";return null!=this.scaleShape&&(t="getScaleByOutputIndex(index)"),"\n      ".concat(getMainHeaderString("index")," {\n        if (index < uniforms.size)\n        {\n          let xValue = getXByOutputIndex(index);\n          let meanValue = getMeanByOutputIndex(index);\n          let varianValue = getVarianceByOutputIndex(index);\n          let offsetValue = ").concat(e,";\n          let scaleValue = ").concat(t,";\n          let inv = scaleValue * inverseSqrt(varianValue + f32(uniforms.varianceEpsilon));\n          setOutputAtIndex(index,dot(vec3<f32>(xValue, -meanValue, offsetValue), vec3<f32>(inv, inv, 1.0)));\n        }\n      }\n  ")},BatchNormProgram}(),nl={kernelName:p.FusedBatchNorm,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,n=e.attrs,a=e.backend,r=t.x,i=t.scale,o=t.offset,s=t.mean,u=t.variance,c=n.varianceEpsilon,d=[r,s,u],p=null;null!=o&&(p=o.shape,d.push(o));var l=null;null!=i&&(l=i.shape,d.push(i));var h=new np(r.shape,s.shape,u.shape,p,l),f=[{type:"float32",data:[c]}];return a.runWebGPUProgram(h,d,r.dtype,f)}},nh={kernelName:p.FusedConv2D,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var t=e.inputs,n=e.backend,a=e.attrs,r=t.x,i=t.filter,o=t.bias,s=t.preluActivationWeights,u=a.strides,c=a.pad,d=a.dataFormat,l=a.dilations,h=a.dimRoundingMode,f=a.activation,m=a.leakyreluAlpha,g=p.backend_util.convertConv2DDataFormat(d),y=p.backend_util.computeConv2DInfo(r.shape,i.shape,u,l,c,h,!1,g);return conv2DImpl({x:r,filter:i,convInfo:y,backend:n,bias:o,preluActivationWeights:s,leakyreluAlpha:m,activation:f})}},nf={kernelName:p.FusedDepthwiseConv2D,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var t,n=e.inputs,a=e.backend,r=e.attrs,i=n.x,o=n.filter,s=n.bias,u=n.preluActivationWeights,c=r.strides,d=r.pad,l=r.dilations,h=r.dimRoundingMode,f=r.activation,m=r.leakyreluAlpha,g=l;null==g&&(g=[1,1]),p.util.assert(p.backend_util.eitherStridesOrDilationsAreOne(c,g),function(){return"Error in depthwiseConv2d: Either strides or dilations must be "+"1. Got strides ".concat(c," and dilations '").concat(g,"'")});var y=p.backend_util.computeConv2DInfo(i.shape,o.shape,c,g,d,h,!0),v=[i,o],x=null!=s,b=null!=u;x&&v.push(s),b&&v.push(u);var S=[{type:"int32",data:[y.padInfo.top,y.padInfo.left]},{type:"int32",data:[y.inHeight,y.inWidth]}];return y.outHeight>4&&y.outWidth>4&&y.strideWidth<=2&&y.inChannels===y.outChannels&&1===y.dilationHeight&&1===y.dilationWidth&&y.inChannels%4==0?(t=new tz(y,x,f,b),S.push({type:"int32",data:[t.virtualWidth]})):(t=new tN(y,x,f,b),S.push({type:"int32",data:[y.filterHeight]},{type:"int32",data:[y.filterWidth]},{type:"int32",data:[y.strideHeight,y.strideWidth]},{type:"int32",data:[y.dilationHeight,y.dilationWidth]})),"leakyrelu"===f&&(S.push({type:"float32",data:[m]}),t.uniforms+=" alpha : f32,"),a.runWebGPUProgram(t,v,"float32",S)}},nm=function(){function GatherNDProgram(e,t){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="gathernd_".concat(e),this.sliceDim=e,this.uniforms="sliceDim : i32, strides : ".concat(getCoordsDataType(e),",")}return GatherNDProgram.prototype.getUserCode=function(){var e;return e=this.sliceDim>1?"uniforms.strides[j]":"uniforms.strides","\n      ".concat(getMainHeaderString("index")," {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          var flattenIndex = 0;\n          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {\n            let indexTemp = i32(round(getIndices(coords[0], j)));\n            let strideNum = ").concat(e,";\n            flattenIndex = flattenIndex + indexTemp * strideNum;\n          }\n\n          setOutputAtIndex(index, getA(flattenIndex, coords[1]));\n        }\n      }\n      ")},GatherNDProgram}(),ng={kernelName:p.GatherNd,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,a=t.params,r=t.indices,i=r.shape,o=i[i.length-1],s=p.util.sizeFromShape(a.shape),u=__read(p.backend_util.prepareAndValidate(a,r),4),c=u[0],d=u[1],l=u[2],h=u[3],f=reshape({inputs:{x:r},backend:n,attrs:{shape:[d,o]}}),m=reshape({inputs:{x:a},backend:n,attrs:{shape:[p.util.sizeFromShape(a.shape)/l,l]}});if(n.shouldExecuteOnCPU([a,r])||"string"===a.dtype){var g=gatherNdImplCPU(n.readSync(r.dataId),n.bufferSync(a),a.dtype,d,o,l,h,a.shape,s);return n.makeTensorInfo(c,a.dtype,g.values)}var y=new nm(o,[d,l]),v=[{type:"int32",data:[o]},{type:"int32",data:h}],x=n.runWebGPUProgram(y,[m,f],m.dtype,v),b=reshape({inputs:{x:x},backend:n,attrs:{shape:c}});return n.disposeData(f.dataId),n.disposeData(m.dataId),n.disposeData(x.dataId),b}},ny=function(){function GatherProgram(e,t){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.slice(),this.aShape=e,this.outputShape=t,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="gather"}return GatherProgram.prototype.getUserCode=function(){var e=function(e){for(var t=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[],a=0;a<e.length;a++)2===a?n.push("indexZ"):n.push("".concat(t[a]));return n.join()}(this.aShape);return"\n      ".concat(getMainHeaderString("index")," {\n        if (index < uniforms.size) {\n          let resRC = getCoordsFromIndex(index);\n          let indexZ = i32(getIndices(resRC.x, resRC.z));\n          let inBounds = select(0.0, 1.0, indexZ >= 0 && indexZ < uniforms.aShape[2]);\n          setOutputAtIndex(index, inBounds * getA(").concat(e,"));\n        }\n      }\n    ")},GatherProgram}();/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gatherV2(e){var t=e.inputs,n=e.backend,a=e.attrs,r=t.x,i=t.indices,o=a.axis,s=a.batchDims,u=p.util.parseAxisParam(o,r.shape)[0],c=p.backend_util.segment_util.collectGatherOpShapeInfo(r,i,u,s),d=p.util.sizeFromShape(i.shape),l=[],h=reshape({inputs:{x:r},backend:n,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),f=reshape({inputs:{x:i},backend:n,attrs:{shape:[c.batchSize,d/c.batchSize]}});l.push(h),l.push(f);var m=[c.batchSize,c.outerSize,d/c.batchSize,c.sliceSize];if(n.shouldExecuteOnCPU([r,i])){var g=n.tensorMap.get(f.dataId).values,y=p.buffer(f.shape,f.dtype,g),v=n.tensorMap.get(h.dataId).values,x=gatherV2ImplCPU(p.buffer(h.shape,h.dtype,v),y,m);return l.forEach(function(e){return n.disposeData(e.dataId)}),n.makeTensorInfo(c.outputShape,x.dtype,x.values)}var b=new ny(h.shape,m),S=n.runWebGPUProgram(b,[h,f],h.dtype);l.push(S);var w=reshape({inputs:{x:S},backend:n,attrs:{shape:c.outputShape}});return l.forEach(function(e){return n.disposeData(e.dataId)}),w}var nv={kernelName:p.GatherV2,backendName:"webgpu",kernelFunc:gatherV2},nx=binaryKernelFunc({opType:i.GREATER,cpuKernelImpl:H,dtype:"bool"}),nb={kernelName:p.Greater,backendName:"webgpu",kernelFunc:nx},nS=binaryKernelFunc({opType:i.GREATER_EQUAL,dtype:"bool",cpuKernelImpl:K}),nw={kernelName:p.GreaterEqual,backendName:"webgpu",kernelFunc:nS},nC={kernelName:p.IFFT,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var t=e.inputs,n=e.backend;return fftImpl(t.input,!0,n)}},nk=unaryKernelFunc({opType:o.IS_FINITE,dtype:"bool"}),nI={kernelName:p.IsFinite,backendName:"webgpu",kernelFunc:nk},nP=unaryKernelFunc({opType:o.IS_INF,dtype:"bool"}),nR={kernelName:p.IsInf,backendName:"webgpu",kernelFunc:nP},nD=unaryKernelFunc({opType:o.IS_NAN,dtype:"bool"}),n_={kernelName:p.IsNan,backendName:"webgpu",kernelFunc:nD},nA={kernelName:p.LeakyRelu,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var t=e.inputs,n=e.backend,a=e.attrs,r=t.x,i=[{type:"float32",data:[a.alpha]}],s=new L(r.shape,o.LEAKYRELU,"alpha : f32,");return n.runWebGPUProgram(s,[r],"float32",i)}},nz=binaryKernelFunc({opType:i.LESS,dtype:"bool",cpuKernelImpl:X}),nN={kernelName:p.Less,backendName:"webgpu",kernelFunc:nz},nF=binaryKernelFunc({opType:i.LESS_EQUAL,dtype:"bool",cpuKernelImpl:q}),nT={kernelName:p.LessEqual,backendName:"webgpu",kernelFunc:nF},nB=function(){function LinSpaceProgram(e){this.variableNames=[],this.outputShape=[],this.uniforms="start : f32, step : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e],this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="linSpace"}return LinSpaceProgram.prototype.getUserCode=function(){return"\n      ".concat(getMainHeaderString("index")," {\n        if (index < uniforms.size) {\n          setOutputAtIndex(index, uniforms.start + f32(index) * uniforms.step);\n        }\n      }\n    ")},LinSpaceProgram}(),nL={kernelName:p.LinSpace,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var t=e.backend,n=e.attrs,a=n.start,r=n.stop,i=n.num,o=(r-a)/(i-1),s=new nB(i),u=[{type:"float32",data:[a]},{type:"float32",data:[o]}];return t.runWebGPUProgram(s,[],"float32",u)}},nM=unaryKernelFunc({opType:o.LOG,cpuKernelImpl:Y}),nW={kernelName:p.Log,backendName:"webgpu",kernelFunc:nM},nU=unaryKernelFunc({opType:o.LOG1P}),nE={kernelName:p.Log1p,backendName:"webgpu",kernelFunc:nU},nO=binaryKernelFunc({opType:i.LOGICAL_AND,dtype:"bool"}),nV={kernelName:p.LogicalAnd,backendName:"webgpu",kernelFunc:nO},nG=unaryKernelFunc({opType:o.LOGICAL_NOT}),nH={kernelName:p.LogicalNot,backendName:"webgpu",kernelFunc:nG},nK=binaryKernelFunc({opType:i.LOGICAL_OR}),nX={kernelName:p.LogicalOr,backendName:"webgpu",kernelFunc:nK},nq="\n  var powValue = 0.0;\n  let basis = uniforms.bias + uniforms.alpha * sum;\n  if (uniforms.beta == 0.5) {\n    powValue = inverseSqrt(basis);\n  } else if (uniforms.beta == 1.0) {\n    powValue = 1.0 / basis;\n  } else {\n    powValue = exp(log(basis) * (-uniforms.beta));\n  }\n",nY=function(){function LRNProgram(e){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn"}return LRNProgram.prototype.getUserCode=function(){return"\n    ".concat(getMainHeaderString("index")," {\n      if (index < uniforms.size) {\n        let coords = getOutputCoords();\n        let b = coords[0];\n        let r = coords[1];\n        let c = coords[2];\n        let d = coords[3];\n\n        let x = getX(b, r, c, d);\n        var sum = 0.0;\n        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {\n          let idx = d + i;\n          if (idx >= 0 && idx < uniforms.xShape[3]) {\n            let z = getX(b, r, c, idx);\n            sum = sum + z * z;\n          }\n        }\n        ").concat(nq,"\n\n        setOutputAtIndex(index, x * powValue);\n      }\n    }\n  ")},LRNProgram}(),nj=function(){function LRNSharedProgram(e,t){var n=this;this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[256,1,1],this.maxAllowRadius=16,p.util.assert(t<=this.maxAllowRadius,function(){return"Radius must be less than or equal to ".concat(n.maxAllowRadius,", current radius is ").concat(t)}),this.outputShape=e,this.elementsPerWorkgroup=this.workgroupSize[0]-2*this.maxAllowRadius,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,[this.elementsPerWorkgroup,this.workgroupSize[1],this.workgroupSize[2]]),this.shaderKey="lrn_shared"}return LRNSharedProgram.prototype.getUserCode=function(){return"\n    var <workgroup>lrnSub: array<f32, ".concat(this.workgroupSize[0],">;\n    const elementsPerWorkgroup = ").concat(this.elementsPerWorkgroup,";\n    const maxAllowRadius = ").concat(this.maxAllowRadius,";\n\n    ").concat(getMainHeaderString()," {\n      let localDepth = i32(localId.x);\n      let workgroupDepth = i32(workgroupId.x) * elementsPerWorkgroup;\n      let xDepth = workgroupDepth + localDepth - maxAllowRadius;\n      let b = i32(globalId.z) / uniforms.xShape[1];\n      let r = i32(globalId.z) - b * uniforms.xShape[1];\n      let c = i32(globalId.y);\n      let d = workgroupDepth + localDepth;\n\n      var x = 0.0;\n      if (xDepth >= 0 && xDepth < uniforms.xShape[3]) {\n        x = getX(b, r, c, xDepth);\n      }\n      lrnSub[localDepth] = x;\n      workgroupBarrier();\n\n      if (localDepth < elementsPerWorkgroup && d < uniforms.outShape[3]) {\n        var sum = 0.0;\n        let index = localDepth + maxAllowRadius;\n        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {\n          let z = lrnSub[index + i];\n          sum = sum + z * z;\n        }\n        ").concat(nq,"\n\n        setOutputAtCoords(b, r, c, d, lrnSub[index] * powValue);\n      }\n    } ")},LRNSharedProgram}(),nQ={kernelName:p.LRN,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var t,n=e.inputs,a=e.backend,r=e.attrs,i=n.x,o=r.depthRadius,s=r.bias,u=r.alpha,c=r.beta;t=o>16?new nY(i.shape):new nj(i.shape,o);var d=[{type:"int32",data:[o]},{type:"float32",data:[s]},{type:"float32",data:[u]},{type:"float32",data:[c]}];return a.runWebGPUProgram(t,[i],i.dtype,d)}},nZ=function(){function LRNGradProgram(e){this.outputShape=[],this.variableNames=["inputImage","outputImage","dy"],this.uniforms="depthRadius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn_grad"}return LRNGradProgram.prototype.getUserCode=function(){return"\n    ".concat(getMainHeaderString("index")," {\n      if (index < uniforms.size) {\n        let coords = getOutputCoords();\n        let b = coords[0];\n        let r = coords[1];\n        let c = coords[2];\n\n        let MIN_DEPTH_BEGIN = 0;\n        let MAX_DEPTH_END = uniforms.outShape[3];\n        var result = 0.0;\n        for (var d = MIN_DEPTH_BEGIN; d < MAX_DEPTH_END; d++) {\n          let depthBegin = max(MIN_DEPTH_BEGIN, d - uniforms.depthRadius);\n          let depthEnd = min(MAX_DEPTH_END, d + uniforms.depthRadius + 1);\n\n          var norm = 0.0;\n          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {\n            if (k < depthBegin) {\n              continue;\n            } else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            } else {\n              break;\n            }\n          }\n\n          norm = uniforms.alpha * norm + uniforms.bias;\n\n          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {\n            if (k < depthBegin) {\n              continue;\n            } else if (k >= depthBegin && k < depthEnd) {\n              var dyi = -2.0 * uniforms.alpha * uniforms.beta\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d) / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * uniforms.beta);\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            } else {\n              break;\n            }\n          }\n        }\n\n        setOutputAtIndex(index, result);\n      }\n    }\n  ")},LRNGradProgram}(),n$={kernelName:p.LRNGrad,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var t=e.inputs,n=e.backend,a=e.attrs,r=t.x,i=t.y,o=t.dy,s=a.depthRadius,u=a.bias,c=a.alpha,d=a.beta,p=new nZ(r.shape),l=[{type:"int32",data:[s]},{type:"float32",data:[u]},{type:"float32",data:[c]},{type:"float32",data:[d]}];return n.runWebGPUProgram(p,[r,i,o],r.dtype,l)}},nJ=binaryKernelFunc({opType:i.MAX,cpuKernelImpl:j}),n2={kernelName:p.Maximum,backendName:"webgpu",kernelFunc:nJ},n0={kernelName:p.MaxPool,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var t=e.inputs,n=e.backend,a=e.attrs,r=t.x,i=a.filterSize,o=a.strides,s=a.pad,u=a.dimRoundingMode,c=p.backend_util.computePool2DInfo(r.shape,i,o,1,s,u);return poolImpl(r,c,"max",n)}},n1={kernelName:p.MaxPool3D,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var t=e.inputs,n=e.backend,a=e.attrs,r=t.x,i=a.filterSize,o=a.strides,s=a.pad,u=a.dataFormat,c=a.dimRoundingMode,d=p.backend_util.computePool3DInfo(r.shape,i,o,[1,1,1],s,c,u),l=new eT(d,"max"),h=[{type:"int32",data:[d.strideDepth,d.strideHeight,d.strideWidth]},{type:"int32",data:[d.padInfo.front,d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.inDepth,d.inHeight,d.inWidth]},{type:"int32",data:[d.effectiveFilterDepth,d.effectiveFilterHeight,d.effectiveFilterWidth]}];return n.runWebGPUProgram(l,[r],r.dtype,h)}},n3=function(){function MaxPool2DBackpropProgram(e){this.variableNames=["dy","maxPos"],this.uniforms="strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,\n       outHeight : i32, outWidth : i32",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="maxPool2DBackprop"}return MaxPool2DBackpropProgram.prototype.getUserCode=function(){return"\n      ".concat(getMainHeaderString("index")," {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords[0];\n        let d = coords[3];\n\n        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;\n        let dyRCorner = dyRCCorner.x;\n        let dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] - 1;\n        for (var wR = 0; wR < uniforms.filterDims[0]; wR += uniforms.dilations[0]) {\n          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);\n\n          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {\n            continue;\n          }\n          let idyR = i32(dyR);\n\n          for (var wC = 0; wC < uniforms.filterDims[1]; wC += uniforms.dilations[1]) {\n            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);\n\n            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {\n              continue;\n            }\n            let idyC = i32(dyC);\n\n            let dyValue = getDy(batch, idyR, idyC, d);\n            let maxPosValue = lastIndex - i32(getMaxPos(batch, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            let curPosValue = wR * uniforms.filterDims[1] + wC;\n            let mask = select(0.0, 1.0, maxPosValue == curPosValue);\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n    ")},MaxPool2DBackpropProgram}(),n4=function(){function MaxPool3DBackpropProgram(e){this.variableNames=["dy","maxPos"],this.uniforms="strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,\n      outDepth : i32, outHeight : i32, outWidth : i32",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="maxPool3DBackprop"}return MaxPool3DBackpropProgram.prototype.getUserCode=function(){return"\n      ".concat(getMainHeaderString("index")," {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords.x;\n        let ch = coords.u;\n\n        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;\n        let dyDCorner = dyCorner.x;\n        let dyRCorner = dyCorner.y;\n        let dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] * uniforms.filterDims[2] - 1;\n\n        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {\n          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);\n\n          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {\n            continue;\n          }\n          let idyD = i32(dyD);\n\n          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {\n            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);\n\n            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {\n              continue;\n            }\n            let idyR = i32(dyR);\n\n            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {\n              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);\n\n              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {\n                continue;\n              }\n              let idyC = i32(dyC);\n\n              let dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              let maxPosValue = lastIndex - i32(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              let curPosValue = wD * uniforms.filterDims[1] * uniforms.filterDims[2] + wR * uniforms.filterDims[2] + wC;\n              let mask = select(0.0, 1.0, maxPosValue == curPosValue);\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n    ")},MaxPool3DBackpropProgram}(),n6={kernelName:p.MaxPool3DGrad,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var t=e.inputs,n=e.backend,a=e.attrs,r=t.dy,i=t.input,o=a.filterSize,s=a.strides,u=a.pad,c=a.dimRoundingMode,d=p.backend_util.computePool3DInfo(i.shape,o,s,[1,1,1],u,c),l=new eT(d,"max",!0),h=[{type:"int32",data:[d.strideDepth,d.strideHeight,d.strideWidth]},{type:"int32",data:[d.padInfo.front,d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.inDepth,d.inHeight,d.inWidth]},{type:"int32",data:[d.effectiveFilterDepth,d.effectiveFilterHeight,d.effectiveFilterWidth]}],f=n.runWebGPUProgram(l,[i],"int32",h),m=new n4(d);h=[{type:"int32",data:[d.strideDepth,d.strideHeight,d.strideWidth]},{type:"int32",data:[d.effectiveFilterDepth-1-d.padInfo.front,d.effectiveFilterHeight-1-d.padInfo.top,d.effectiveFilterWidth-1-d.padInfo.left]},{type:"int32",data:[d.effectiveFilterDepth,d.effectiveFilterHeight,d.effectiveFilterWidth]},{type:"int32",data:[d.outDepth]},{type:"int32",data:[d.outHeight]},{type:"int32",data:[d.outWidth]}];var g=n.runWebGPUProgram(m,[r,f],i.dtype,h);return n.disposeData(f.dataId),g}},n5={kernelName:p.MaxPoolGrad,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var t=e.inputs,n=e.backend,a=e.attrs,r=t.dy,i=t.input;assertNotComplex([i,t.output],"maxPoolGrad");var o=a.filterSize,s=a.strides,u=a.pad,c=a.dimRoundingMode,d=p.backend_util.computePool2DInfo(i.shape,o,s,1,u,c),l=new eF(d,"max",!0),h=[{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]},{type:"int32",data:[d.inHeight,d.inWidth]},{type:"int32",data:[d.effectiveFilterHeight,d.effectiveFilterWidth]}],f=n.runWebGPUProgram(l,[i],"int32",h),m=new n3(d);h=[{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.effectiveFilterHeight-1-d.padInfo.top,d.effectiveFilterWidth-1-d.padInfo.left]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]},{type:"int32",data:[d.effectiveFilterHeight,d.effectiveFilterWidth]},{type:"int32",data:[d.outHeight]},{type:"int32",data:[d.outWidth]}];var g=n.runWebGPUProgram(m,[r,f],i.dtype,h);return n.disposeData(f.dataId),g}},n8={kernelName:p.MaxPoolWithArgmax,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var t=e.inputs,n=e.backend,a=e.attrs,r=a.filterSize,i=a.strides,o=a.pad,s=a.includeBatchInIndex,u=t.x;p.util.assert(4===u.shape.length,function(){return"Error in maxPool: input must be rank 4 but got rank ".concat(u.shape.length,".")});var c=[1,1];p.util.assert(p.backend_util.eitherStridesOrDilationsAreOne(i,c),function(){return"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(i," and dilations '").concat(c,"'")});var d=p.backend_util.computePool2DInfo(u.shape,r,i,c,o),l=[{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]},{type:"int32",data:[d.inHeight,d.inWidth]},{type:"int32",data:[d.effectiveFilterHeight,d.effectiveFilterWidth]}],h=new eF(d,"max",!1),f=n.runWebGPUProgram(h,[u],u.dtype,l);return h=new eF(d,"max",!0,!0,s),[f,n.runWebGPUProgram(h,[u],"int32",l)]}},n9={kernelName:p.Min,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var t=e.inputs,n=e.backend,a=e.attrs;return reduce(t.x,a.axis,a.keepDims,"min",n)}},n7=binaryKernelFunc({opType:i.MIN,cpuKernelImpl:Q}),ae={kernelName:p.Minimum,backendName:"webgpu",kernelFunc:n7},at=function(){function MirrorPadProgram(e,t,n){var a=this;this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.map(function(t,n){return t[0]+e[n]+t[1]}),this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=e,t.map(function(e,t){a.uniforms+=" pad".concat(t," : vec2<i32>,")}),this.offset="reflect"===n?0:1,this.shaderKey="mirrorPad_".concat(n)}return MirrorPadProgram.prototype.getUserCode=function(){var e=this.xShape.length,t=this.xShape.map(function(e,t){return"uniforms.pad".concat(t,"[0]")}).join(","),n=this.xShape.map(function(t,n){return"uniforms.pad".concat(n,"[0] + uniforms.xShape").concat(e>1?"[".concat(n,"]"):"")}).join(","),a=1===e?"start":"start[i]",r=1===e?"end":"end[i]",i=1===e?"outC":"outC[i]",o=getCoordsDataType(e),s=e>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e):"coords";return"\n      ".concat(getMainHeaderString("index")," {\n        if (index < uniforms.size) {\n          let start = ").concat(o,"(").concat(t,");\n          let end = ").concat(o,"(").concat(n,");\n          var outC = getCoordsFromIndex(index);\n          for (var i = 0; i < ").concat(e,"; i = i + 1) {\n            if (").concat(i," < ").concat(a,") {\n              ").concat(i," = ").concat(a," * 2 - ").concat(i," - ").concat(this.offset,";\n            } else if(").concat(i," >= ").concat(r,") {\n              ").concat(i," = (").concat(r," - 1) * 2 - ").concat(i," + ").concat(this.offset,";\n            }\n          }\n          let coords = outC - start;\n          setOutputAtIndex(index, getX(").concat(s,"));\n        }\n      }\n    ")},MirrorPadProgram}(),an={kernelName:p.MirrorPad,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,n=e.attrs,a=e.backend,r=t.x,i=n.paddings,o=n.mode,s=i.map(function(e){return{type:"int32",data:[e[0],e[1]]}}),u=new at(r.shape,i,o);return a.runWebGPUProgram(u,[r],r.dtype,s)}},aa=binaryKernelFunc({opType:i.MOD}),ar={kernelName:p.Mod,backendName:"webgpu",kernelFunc:aa},ai=function(){function MultinomialProgram(e,t){this.variableNames=["probs"],this.outputShape=[],this.uniforms="seed : f32, numOutcomes: i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,t],this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="multinomial"}return MultinomialProgram.prototype.getUserCode=function(){return"\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    fn random (seed : f32, resultUV : vec2<f32>) -> f32 {\n      let HASHSCALE1 = 443.8975;\n      let p = resultUV * seed;\n      var p3  = fract(vec3<f32>(p.xyx) * HASHSCALE1);\n      p3 = p3 + dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ".concat(getMainHeaderString("index")," {\n      if (index < uniforms.size) {\n        let coords = getOutputCoords();\n        let batch = coords[0];\n\n        let resUV = vec2<f32>(f32(coords[1]) / f32(uniforms.outShape[1]),\n            f32(coords[0]) / f32(uniforms.outShape[0]));\n        let r = random(uniforms.seed, resUV);\n        var cdf = 0.0;\n        for (var i = 0; i < uniforms.numOutcomes - 1; i = i + 1) {\n          cdf = cdf + getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutputAtIndexI32(index, i);\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutputAtIndexI32(index, uniforms.numOutcomes - 1);\n      }\n    }\n  ")},MultinomialProgram}(),ao=function(){function SoftmaxProgram(e){this.variableNames=["logits"],this.outputShape=e,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=[this.outputShape[0],1,1],this.outputShape[1]>=4096?this.workgroupSize=[256,1,1]:this.workgroupSize=[64,1,1],this.shaderKey="softmax"}return SoftmaxProgram.prototype.getUserCode=function(){return"\n    var<workgroup> buf : array<f32, ".concat(this.workgroupSize[0],">;\n    var<workgroup> rowMaxShared : f32;\n    var<workgroup> rowSumShared : f32;\n    const blockSize = ").concat(this.workgroupSize[0],";\n    ").concat(getMainHeaderString("index")," {\n      let row = index / blockSize;\n      let tid = i32(localId.x);\n      let cols = uniforms.outShape[1];\n\n      var threadMax = -3.402823e+38f;\n      for (var col = tid; col < cols; col += blockSize) {\n        let value = getLogits(row, col);\n        threadMax = max(threadMax, value);\n      }\n      if (tid < cols) {\n        buf[tid] = threadMax;\n      }\n      workgroupBarrier();\n\n      var reduceSize = min(cols, blockSize);\n      for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {\n        reduceSize = currSize + (reduceSize & 1);\n        if (tid < currSize) {\n          buf[tid] = max(buf[tid], buf[tid + reduceSize]);\n        }\n        workgroupBarrier();\n      }\n\n      if (tid == 0) {\n        rowMaxShared = buf[0];\n      }\n      workgroupBarrier();\n\n      var threadSum = 0.0;\n      for (var col = tid; col < cols; col += blockSize) {\n        let subExp = exp(getLogits(row, col) - rowMaxShared);\n        threadSum += subExp;\n      }\n      buf[tid] = threadSum;\n      workgroupBarrier();\n\n      for (var currSize = blockSize >> 1;  currSize > 0; currSize = currSize >> 1) {\n        if (tid < currSize) {\n          buf[tid] = buf[tid] + buf[tid + currSize];\n        }\n        workgroupBarrier();\n      }\n\n      if (tid == 0) {\n        rowSumShared = buf[0];\n      }\n      workgroupBarrier();\n\n      for (var col = tid; col < cols; col += blockSize) {\n        let value = exp(getLogits(row, col) - rowMaxShared) / rowSumShared;\n        setOutputAtCoords(row, col, value);\n      }\n  }\n    ")},SoftmaxProgram}();/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function softmax(e){var t=e.inputs,n=e.backend,a=e.attrs,r=t.logits,i=a.dim,o=reshape({inputs:{x:r},backend:n,attrs:{shape:[p.util.sizeFromShape(r.shape)/r.shape[i],r.shape[i]]}}),s=new ao(o.shape),u=n.runWebGPUProgram(s,[o],r.dtype),c=reshape({inputs:{x:u},backend:n,attrs:{shape:r.shape}});return n.disposeData(o.dataId),n.disposeData(u.dataId),c}var as={kernelName:p.Softmax,backendName:"webgpu",kernelFunc:softmax},au={kernelName:p.Multinomial,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var t=e.inputs,n=e.backend,a=e.attrs,r=t.logits,i=a.numSamples,o=a.seed,s=a.normalized,u=s?r:softmax({inputs:{logits:r},backend:n,attrs:{dim:r.shape.length-1}}),c=u.shape[0],d=u.shape[1],p=new ai(c,i),l=n.runWebGPUProgram(p,[u],"int32",[{type:"float32",data:[o]},{type:"int32",data:[d]}]);return s||n.disposeData(u.dataId),l}},ac={kernelName:p.Neg,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,a=t.x;if(n.shouldExecuteOnCPU([a])){var r,i,s,u=__read((r=n.tensorMap.get(a.dataId).values,i=a.shape,s=a.dtype,Z([],i,p.util.createScalarValue(-1,s),r,s)),2),c=u[0],d=u[1];return n.makeTensorInfo(d,a.dtype,c)}var l=new L(a.shape,o.NEG);return n.runWebGPUProgram(l,[a],a.dtype)}},ad={kernelName:p.NonMaxSuppressionV3,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");var t=e.inputs,n=e.backend,a=e.attrs,r=t.boxes,i=t.scores,o=a.maxOutputSize,s=a.iouThreshold,u=a.scoreThreshold,c=n.readSync(r.dataId),d=n.readSync(i.dataId),l=p.kernel_impls.nonMaxSuppressionV3Impl(c,d,o,s,u).selectedIndices;return n.makeTensorInfo([l.length],"int32",new Int32Array(l))}},ap={kernelName:p.NonMaxSuppressionV5,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");var t=e.inputs,n=e.backend,a=e.attrs,r=t.boxes,i=t.scores,o=a.maxOutputSize,s=a.iouThreshold,u=a.scoreThreshold,c=a.softNmsSigma,d=n.readSync(r.dataId),l=n.readSync(i.dataId),h=p.kernel_impls.nonMaxSuppressionV5Impl(d,l,o,s,u,c),f=h.selectedIndices,m=h.selectedScores;return[n.makeTensorInfo([f.length],"int32",new Int32Array(f)),n.makeTensorInfo([m.length],"float32",new Float32Array(m))]}},al=function(){function OneHotProgram(e,t){this.variableNames=["x"],this.uniforms="onValue : f32, offValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,t],this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="onehot"}return OneHotProgram.prototype.getUserCode=function(){return"\n      ".concat(getMainHeaderString("index")," {\n        if(index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          setOutputAtIndex(index, mix(uniforms.offValue, uniforms.onValue,\n                                      f32(i32(round(getX(coords.x))) == coords.y)));\n        }\n      }\n    ")},OneHotProgram}(),ah={kernelName:p.OneHot,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,a=e.attrs,r=t.indices,i=a.dtype,o=a.depth,s=a.onValue,u=a.offValue,c=p.util.sizeFromShape(r.shape),d=new al(c,o),l=reshape({inputs:{x:r},backend:n,attrs:{shape:[c]}}),h=n.runWebGPUProgram(d,[l],i,[{type:"float32",data:[s]},{type:"float32",data:[u]}]);n.disposeData(l.dataId);var f=reshape({inputs:{x:h},backend:n,attrs:{shape:__spreadArray(__spreadArray([],__read(r.shape),!1),[o],!1)}});return n.disposeData(h.dataId),f}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zerosLike(e){var t=e.inputs,n=e.backend,a=t.x;if("complex64"!==a.dtype)return fill({attrs:{shape:a.shape,dtype:a.dtype,value:"string"===a.dtype?"":0},backend:n});var r=real({inputs:{input:a},backend:n}),i=zerosLike({inputs:{x:r},backend:n}),o=imag({inputs:{input:a},backend:n}),s=zerosLike({inputs:{x:o},backend:n}),u=complex({inputs:{real:i,imag:s},backend:n});return n.disposeData(r.dataId),n.disposeData(i.dataId),n.disposeData(o.dataId),n.disposeData(s.dataId),u}var af={kernelName:p.ZerosLike,backendName:"webgpu",kernelFunc:zerosLike},am={kernelName:p.OnesLike,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function onesLike(e){var t=e.inputs,n=e.backend,a=t.x;if("string"===a.dtype)throw Error("onesLike is not supported under string dtype");if("complex64"!==a.dtype)return fill({attrs:{shape:a.shape,dtype:a.dtype,value:1},backend:n});var r=real({inputs:{input:a},backend:n}),i=onesLike({inputs:{x:r},backend:n}),o=imag({inputs:{input:a},backend:n}),s=zerosLike({inputs:{x:o},backend:n}),u=complex({inputs:{real:i,imag:s},backend:n});return n.disposeData(r.dataId),n.disposeData(i.dataId),n.disposeData(o.dataId),n.disposeData(s.dataId),u}},ag={kernelName:p.Pack,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var t=e.inputs,n=e.backend,a=e.attrs.axis;if(1===t.length)return expandDims({inputs:{input:t[0]},backend:n,attrs:{dim:a}});var r=t[0].shape,i=t[0].dtype;t.forEach(function(e){p.util.assertShapesMatch(r,e.shape,"All tensors passed to stack must have matching shapes"),p.util.assert(i===e.dtype,function(){return"All tensors passed to stack must have matching dtypes"})});var o=[],s=concat({inputs:t.map(function(e){var t=expandDims({inputs:{input:e},backend:n,attrs:{dim:a}});return o.push(t),t}),backend:n,attrs:{axis:a}});return o.forEach(function(e){return n.disposeData(e.dataId)}),s}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function padCommon(e,t){void 0===t&&(t=!1);var n=e.length,a=getCoordsDataType(n),r=e.map(function(e,t){return"uniforms.pad".concat(t,"[0]")}).join(","),i=e.map(function(e,t){return"uniforms.pad".concat(t,"[0] + uniforms.xShape").concat(n>1?"[".concat(t,"]"):"")}).join(","),o=n>1?"".concat(a,"(").concat(r,")"):"".concat(r),s=n>1?"".concat(a,"(").concat(i,")"):"".concat(i),u=n>1?"any(paddedCoords < start)":"paddedCoords < start",c=n>1?"any(paddedCoords >= end)":"paddedCoords >= end",d=n>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,n):"coords";return"\n        let start = ".concat(o,";\n        let end = ").concat(s,";\n        if (").concat(u," || ").concat(c,") {\n          setOutputAtIndex(index, ").concat(t?0:"uniforms.constantValue",");\n        } else {\n          let coords = paddedCoords - start;\n          setOutputAtIndex(index, getX(").concat(d,"));\n        }\n  ")}var ay=function(){function PadProgram(e,t){var n=this;this.variableNames=["x"],this.uniforms="constantValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.map(function(t,n){return t[0]+e[n]+t[1]}),this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),t.map(function(e,t){n.uniforms+=" pad".concat(t," : vec2<i32>,")}),this.xShape=e,this.shaderKey="pad"}return PadProgram.prototype.getUserCode=function(){return"\n      ".concat(getMainHeaderString("index")," {\n        if (index < uniforms.size) {\n          let paddedCoords = getCoordsFromIndex(index);\n          ").concat(padCommon(this.xShape),"\n        }\n      }\n    ")},PadProgram}(),av={kernelName:p.PadV2,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,a=e.attrs,r=t.x,i=a.paddings,o=a.constantValue;if(i.every(function(e){return p.util.arraysEqual(e,[0,0])}))return identity({inputs:{x:r},backend:n});if(0===p.util.sizeFromShape(r.shape))return fill({backend:n,attrs:{shape:i.map(function(e,t){return e[0]+r.shape[t]+e[1]}),value:o,dtype:r.dtype}});var s=[{type:"float32",data:[o]}];i.map(function(e){return s.push({type:"int32",data:[e[0],e[1]]})});var u=new ay(r.shape,i);return n.runWebGPUProgram(u,[r],r.dtype,s)}},ax=binaryKernelFunc({opType:i.POW}),ab={kernelName:p.Pow,backendName:"webgpu",kernelFunc:ax},aS={kernelName:p.Prelu,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var t=e.inputs,n=e.backend,a=t.x,r=t.alpha,o=new F(i.PRELU,a.shape,r.shape);return n.runWebGPUProgram(o,[a,r],"float32")}},aw={kernelName:p.Prod,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var t=e.inputs,n=e.backend,a=e.attrs;return reduce(t.x,a.axis,a.keepDims,"prod",n)}},aC={kernelName:p.Range,backendName:"webgpu",kernelFunc:function(e){var t=e.backend,n=e.attrs,a=n.start,r=n.stop,i=n.step,o=n.dtype,s=rangeImplCPU(a,r,i,o);return t.makeTensorInfo([s.length],o,s)}},ak=binaryKernelFunc({opType:i.DIV}),aI={kernelName:p.RealDiv,backendName:"webgpu",kernelFunc:ak},aP=unaryKernelFunc({opType:o.RECIPROCAL}),aR={kernelName:p.Reciprocal,backendName:"webgpu",kernelFunc:aP},aD=unaryKernelFunc({opType:o.RELU}),a_={kernelName:p.Relu,backendName:"webgpu",kernelFunc:aD},aA=unaryKernelFunc({opType:o.RELU6}),az={kernelName:p.Relu6,backendName:"webgpu",kernelFunc:aA},aN=function(){function ResizeBilinearProgram(e,t,n){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, halfPixelCenters : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],t,n,e[3]],this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="resizeBilinear"}return ResizeBilinearProgram.prototype.getUserCode=function(){return"\n      ".concat(getMainHeaderString("index")," {\n        if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n          let b = coords[0];\n          let d = coords[3];\n          let rc = coords.yz;\n\n          let effectiveInSize = vec2<f32>(\n            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveOutSize = vec2<f32>(\n            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveInputOverOutputRatioRC =\n              effectiveInSize / effectiveOutSize;\n\n          // Fractional source index\n          let sourceFracIndexRC =\n            (vec2<f32>(rc) + vec2<f32>(uniforms.halfPixelCenters)) *\n            effectiveInputOverOutputRatioRC - vec2<f32>(uniforms.halfPixelCenters);\n\n          // Compute the four integer indices.\n          let sourceFloorRC = vec2<i32>(sourceFracIndexRC);\n          let sourceCeilRC = vec2<i32>(\n            min(vec2<f32>(uniforms.xShape.yz) - vec2<f32>(1.0), ceil(sourceFracIndexRC)));\n\n          let topLeft = getX(b, sourceFloorRC.x, sourceFloorRC.y, d);\n          let bottomLeft = getX(b, sourceCeilRC.x, sourceFloorRC.y, d);\n          let topRight = getX(b, sourceFloorRC.x, sourceCeilRC.y, d);\n          let bottomRight = getX(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n          let fracRC = sourceFracIndexRC - vec2<f32>(sourceFloorRC);\n\n          let top = topLeft + (topRight - topLeft) * fracRC.y;\n          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n          let newValue = top + (bottom - top) * fracRC.x;\n\n          setOutputAtIndex(index, newValue);\n        }\n      }\n    ")},ResizeBilinearProgram}(),aF={kernelName:p.ResizeBilinear,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,a=e.attrs,r=t.images,i=a.alignCorners,o=a.size,s=a.halfPixelCenters,u=__read(o,2),c=u[0],d=u[1],p=[{type:"float32",data:[i&&c>1?1:0,i&&d>1?1:0]},{type:"float32",data:[s?.5:0]}],l=new aN(r.shape,c,d);return n.runWebGPUProgram(l,[r],"float32",p)}},aT=function(){function ResizeBilinearBackpropProgram(e,t){this.variableNames=["dy"],this.uniforms="effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, heightScale : f32, widthScale : f32,\n       invHeightScale : f32, invWidthScale : f32, winHeight : i32, winWidth : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.alignCorners=t,this.shaderKey="resizeBilinearBackprop_".concat(t)}return ResizeBilinearBackpropProgram.prototype.getUserCode=function(){return"\n      ".concat(getMainHeaderString("index")," {\n        if (index < uniforms.size) {\n          let coords = getOutputCoords();\n          let b = coords[0];\n          let d = coords[3];\n          let r = coords[1];\n          let c = coords[2];\n\n          var accumulator = 0.0;\n\n          // Compute bounds for where in dy we will look\n          let startRLerp = floor(f32(r) * uniforms.invHeightScale);\n          let startDyR = i32(startRLerp - f32(uniforms.winHeight / 2));\n\n          let startCLerp = floor(f32(c) * uniforms.invWidthScale);\n          let startDyC = i32(startCLerp - f32(uniforms.winWidth / 2));\n\n          // Loop over dy\n          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {\n            let dyR = startDyR + dyROffset;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {\n              continue;\n            }\n\n            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {\n              let dyC = startDyC + dyCOffset;\n\n              // Guard against the window exceeding the bounds of dy\n              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {\n                continue;\n              }\n\n              let dxR = f32(dyR) * uniforms.heightScale;\n              let topDxRIndex = i32(floor(dxR));\n              let bottomDxRIndex = i32(min(ceil(dxR), f32(uniforms.outShape[1] - 1)));\n              let dxRLerp = dxR - f32(topDxRIndex);\n              let inverseDxRLerp = 1.0 - dxRLerp;\n\n              let dxC = f32(dyC) * uniforms.widthScale;\n              let leftDxCIndex = i32(floor(dxC));\n              let rightDxCIndex = i32(min(ceil(dxC), f32(uniforms.outShape[2] - 1)));\n              let dxCLerp = dxC - f32(leftDxCIndex);\n              let inverseDxCLerp = 1.0 - dxCLerp;\n\n              if (r == topDxRIndex && c == leftDxCIndex) {\n                // topLeft\n                accumulator +=\n                  getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n              }\n\n              if (r == topDxRIndex && c == rightDxCIndex) {\n                // topRight\n                accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n              }\n\n              if (r == bottomDxRIndex && c == leftDxCIndex) {\n                // bottomLeft\n                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n              }\n\n              if (r == bottomDxRIndex && c == rightDxCIndex) {\n                // bottomRight\n                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n              }\n            }\n          }\n          // End loop over dy\n\n          setOutputAtIndex(index, accumulator);\n        }\n      }\n    ")},ResizeBilinearBackpropProgram}(),aB={kernelName:p.ResizeBilinearGrad,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,a=e.attrs,r=t.images,i=t.dy,o=a.alignCorners,s=__read(r.shape,3),u=s[1],c=s[2],d=__read(i.shape,3),p=d[1],l=d[2],h=[o&&p>1?u-1:u,o&&l>1?c-1:c],f=[o&&p>1?p-1:p,o&&l>1?l-1:l],m=h[0]/f[0],g=h[1]/f[1],y=1/m,v=1/g,x=2*Math.ceil(y)+2,b=2*Math.ceil(v)+2,S=new aT(r.shape,o),w=[{type:"int32",data:h},{type:"int32",data:f},{type:"float32",data:[m]},{type:"float32",data:[g]},{type:"float32",data:[y]},{type:"float32",data:[v]},{type:"int32",data:[x]},{type:"int32",data:[b]}];return n.runWebGPUProgram(S,[i],i.dtype,w)}},aL=function(){function ResizeNearestNeighborProgram(e,t,n,a){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, roundBase : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],t,n,e[3]],this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.halfPixelCenters=a,this.shaderKey="resizeNearest_".concat(a)}return ResizeNearestNeighborProgram.prototype.getUserCode=function(){var e;return e=this.halfPixelCenters?"max((vec2<f32>(rc) + vec2<f32>(0.5)) * effectiveInputOverOutputRatioRC, vec2<f32>(0.0))":"vec2<f32>(rc) * effectiveInputOverOutputRatioRC","\n      ".concat(getMainHeaderString("index")," {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let b = coords[0];\n          let d = coords[3];\n          let rc = coords.yz;\n\n          let effectiveInSize = vec2<f32>(\n            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveOutSize = vec2<f32>(\n            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveInputOverOutputRatioRC =\n              effectiveInSize / effectiveOutSize;\n\n          // Fractional source index\n          let sourceFracIndexRC = ").concat(e,";\n\n          // Compute the coordinators of nearest neighbor point.\n          let inputShapeRC = vec2<f32>(f32(uniforms.xShape.y), f32(uniforms.xShape.z));\n          let sourceNearestRC = vec2<i32>(\n            min(inputShapeRC - 1.0, floor(sourceFracIndexRC + uniforms.roundBase)));\n          let newValue = getX(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n          setOutputAtIndex(index, newValue);\n        }\n      }\n    ")},ResizeNearestNeighborProgram}(),aM={kernelName:p.ResizeNearestNeighbor,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,a=e.attrs,r=t.images,i=a.alignCorners,o=a.halfPixelCenters,s=__read(a.size,2),u=s[0],c=s[1],d=[{type:"float32",data:[i&&u>1?1:0,i&&c>1?1:0]},{type:"float32",data:[i?.5:0]}],p=new aL(r.shape,u,c,o);return n.runWebGPUProgram(p,[r],r.dtype,d)}},aW=function(){function ResizeNearestNeigborBackpropProgram(e,t){this.variableNames=["dy"],this.uniforms="effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, invHeightScale : f32, invWidthScale : f32,\n       winHeight : i32, winWidth : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.alignCorners=t,this.shaderKey="resizeNearestNeigborBackprop_".concat(t)}return ResizeNearestNeigborBackpropProgram.prototype.getUserCode=function(){return"\n      ".concat(getMainHeaderString("index")," {\n        if (index < uniforms.size) {\n          let coords = getOutputCoords();\n          let b = coords[0];\n          let d = coords[3];\n          let r = coords[1];\n          let c = coords[2];\n\n          var accumulator = 0.0;\n\n          // Compute bounds for where in dy we will look\n          let startRLerp = floor(f32(r) * uniforms.invHeightScale);\n          let startDyR = i32(floor(startRLerp - f32(uniforms.winHeight / 2)));\n\n          let startCLerp = floor(f32(c) * uniforms.invWidthScale);\n          let startDyC = i32(floor(startCLerp - f32(uniforms.winWidth / 2)));\n\n          // Loop over dy\n          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {\n            let dyR = startDyR + dyROffset;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {\n              continue;\n            }\n\n            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {\n              let dyC = startDyC + dyCOffset;\n\n              // Guard against the window exceeding the bounds of dy\n              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {\n                continue;\n              }\n\n              let sourceFracRow = f32(uniforms.effectiveXSize[0]) *\n                  (f32(dyR) / f32(uniforms.effectiveYSize[0]));\n\n              let sourceFracCol = f32(uniforms.effectiveXSize[1]) *\n                  (f32(dyC) / f32(uniforms.effectiveYSize[1]));\n\n              let sourceNearestRow =\n                  i32(min(f32(uniforms.outShape[1] - 1),\n                  ").concat(this.alignCorners?"floor(sourceFracRow + 0.5)":"floor(sourceFracRow)","));\n\n              let sourceNearestCol =\n                  i32(min(f32(uniforms.outShape[2] - 1),\n                  ").concat(this.alignCorners?"floor(sourceFracCol + 0.5)":"floor(sourceFracCol)","));\n\n              if (r == sourceNearestRow && c == sourceNearestCol) {\n                accumulator += getDy(b, dyR, dyC, d);\n              }\n            }\n          }\n          // End loop over dy\n\n          setOutputAtIndex(index, accumulator);\n        }\n      }\n    ")},ResizeNearestNeigborBackpropProgram}(),aU={kernelName:p.ResizeNearestNeighborGrad,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,a=e.attrs,r=t.images,i=t.dy,o=a.alignCorners,s=__read(r.shape,3),u=s[1],c=s[2],d=__read(i.shape,3),p=d[1],l=d[2],h=[o&&p>1?u-1:u,o&&l>1?c-1:c],f=[o&&p>1?p-1:p,o&&l>1?l-1:l],m=h[0]/f[0],g=h[1]/f[1],y=1/m,v=1/g,x=2*Math.ceil(y)+2,b=2*Math.ceil(v)+2,S=new aW(r.shape,o),w=[{type:"int32",data:h},{type:"int32",data:f},{type:"float32",data:[y]},{type:"float32",data:[v]},{type:"int32",data:[x]},{type:"int32",data:[b]}];return n.runWebGPUProgram(S,[i],i.dtype,w)}},aE=function(){function ReverseProgram(e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=" axis : vec4<i32>,",this.shaderKey="reverse"}return ReverseProgram.prototype.getUserCode=function(){return"\n      ".concat("\n      // Using uniform variables as judging conditions, so the function has\n      // coherent execution within all threads.\n      fn getReverseCoords(coords : vec4<i32>) -> vec4<i32> {\n        var reverseCoords = coords;\n        if (uniforms.axis[0] == 1) {\n          reverseCoords[0] = uniforms.xShape[0] - coords[0] - 1;\n        }\n        if (uniforms.axis[1] == 1) {\n          reverseCoords[1] = uniforms.xShape[1] - coords[1] - 1;\n        }\n        if (uniforms.axis[2] == 1) {\n          reverseCoords[2] = uniforms.xShape[2] - coords[2] - 1;\n        }\n        if (uniforms.axis[3] == 1) {\n          reverseCoords[3] = uniforms.xShape[3] - coords[3] - 1;\n        }\n\n        return reverseCoords;\n      }\n    ","\n      ").concat(getMainHeaderString("index")," {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let reverseCoords = getReverseCoords(coords);\n          setOutputAtIndex(index, getX(reverseCoords[0],\n              reverseCoords[1], reverseCoords[2], reverseCoords[3]));\n        }\n      }\n    ")},ReverseProgram}(),aO={kernelName:p.Reverse,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var t=e.inputs,n=e.backend,a=e.attrs,r=t.x,i=a.dims,o=r.shape.length;if(0===o)return identity({inputs:{x:r},backend:n});var s=r.shape,u=[1,1,1,1];s.forEach(function(e,t){u[t+4-o]=e});var c=p.util.parseAxisParam(i,r.shape),d=[0,0,0,0];c.forEach(function(e){d[e+4-o]=1});var l=[{type:"int32",data:d}],h=reshape({inputs:{x:r},backend:n,attrs:{shape:u}}),f=new aE(u),m=n.runWebGPUProgram(f,[h],h.dtype,l);n.disposeData(h.dataId);var g=reshape({inputs:{x:m},backend:n,attrs:{shape:s}});return n.disposeData(m.dataId),g}},aV=function(){function RotateProgram(e,t){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms="centerX : f32, centerY : f32, sinRadians : f32,\n          cosRadians : f32,",this.shaderKey="rotate",this.outputShape=e,"number"==typeof t?(this.uniforms+=" fillValue : f32,",this.fillSnippet="var outputValue = uniforms.fillValue;",this.shaderKey+="_float"):(this.uniforms+=" fillValue : vec3<f32>,",this.fillSnippet="var outputValue = uniforms.fillValue[coords[3]];",this.shaderKey+="_vec3")}return RotateProgram.prototype.getUserCode=function(){return"\n        ".concat(getMainHeaderString("index")," {\n          if (index < uniforms.size) {\n            let coords = getCoordsFromIndex(index);\n            let coordXFloat = (f32(coords[2]) - uniforms.centerX) *\n                uniforms.cosRadians - (f32(coords[1]) - uniforms.centerY) *\n                uniforms.sinRadians;\n            let coordYFloat = (f32(coords[2]) - uniforms.centerX) *\n                uniforms.sinRadians + (f32(coords[1]) - uniforms.centerY) *\n                uniforms.cosRadians;\n            let coordX = i32(round(coordXFloat + uniforms.centerX));\n            let coordY = i32(round(coordYFloat + uniforms.centerY));\n            ").concat(this.fillSnippet,"\n            if(coordX >= 0 && coordX < uniforms.xShape[2] && coordY >= 0 &&\n                coordY < uniforms.xShape[1]) {\n              outputValue = getX(coords[0], coordY, coordX, coords[3]);\n            }\n            setOutputAtIndex(index, outputValue);\n          }\n        }\n      ")},RotateProgram}(),aG={kernelName:p.RotateWithOffset,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,n=e.attrs,a=e.backend,r=t.image,i=n.radians,o=n.fillValue,s=n.center,u=new aV(r.shape,o),c=__read(p.backend_util.getImageCenter(s,r.shape[1],r.shape[2]),2),d=[{type:"float32",data:[c[0]]},{type:"float32",data:[c[1]]},{type:"float32",data:[Math.sin(i)]},{type:"float32",data:[Math.cos(i)]}];return"number"==typeof o?d.push({type:"float32",data:[Number.parseFloat(o.toFixed(2))]}):d.push({type:"float32",data:o}),a.runWebGPUProgram(u,[r],r.dtype,d)}},aH=unaryKernelFunc({opType:o.ROUND}),aK={kernelName:p.Round,backendName:"webgpu",kernelFunc:aH},aX=unaryKernelFunc({opType:o.RSQRT,cpuKernelImpl:J}),aq={kernelName:p.Rsqrt,backendName:"webgpu",kernelFunc:aX},aY=function(){function ScatterProgram(e,t,n,a,r,i,o,s){void 0===s&&(s=!0),this.variableNames=["updates","indices"],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=i,this.type=o,this.sumDupeIndices=s,this.dispatchLayout=flatDispatchLayout(e),this.dispatch=computeDispatch(this.dispatchLayout,e,this.workgroupSize),this.sliceDimGreaterThanOne=t>1,this.shaderKey="scatter_".concat(n,"_").concat(a,"_").concat(this.sliceDimGreaterThanOne,"_").concat(o,"_").concat(s,"_").concat(r.length);var u=getCoordsDataType(r.length);this.uniforms="sliceDim : i32, strides: ".concat(u,", updatesSize: i32,"),this.updatesRank=a,this.indicesRank=n}return ScatterProgram.prototype.getUserCode=function(){var e="";1===this.indicesRank?e="coords[0]":2===this.indicesRank&&(e="coords[0], j");var t="getIndices(".concat(e,")"),n=this.sliceDimGreaterThanOne?"uniforms.strides[j]":"uniforms.strides",a="",r="";1===this.dispatchLayout.x.length?(a="flattenedIndex",r="\n      fn getUpdatesCoordsFromFlatIndex(index : i32) -> i32 {\n        return index;\n      }\n      "):2===this.dispatchLayout.x.length&&(a="vec2<i32>(flattenedIndex, coords[1])",r="\n      fn getUpdatesCoordsFromFlatIndex(index : i32) -> vec2<i32> {\n        // N.B. |updates| could be a scalar tensor, conceptually representing a\n        // 2D tensor with all values equal to that. By design, its size must be\n        // the same as |outShape[1]| in one dimension, and |indicesShape[0]|\n        // gives the other.\n        let sliceSize = uniforms.outShape[1];\n        let d0 = index / sliceSize;\n        let d1 = index - d0 * sliceSize;\n        return vec2<i32>(d0, d1);\n      }\n      ");var i=Array.from({length:this.updatesRank},function(e,t){return"coords[".concat(t,"]")}),o="getUpdates(".concat(i.join(", "),")");return"\n    ".concat(r,"\n      ").concat(getMainHeaderString("index")," {\n        if (index < uniforms.updatesSize) {\n          let coords = getUpdatesCoordsFromFlatIndex(index);\n          var flattenedIndex = 0;\n          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {\n            let indexInside = i32(round(").concat(t,"));\n            flattenedIndex = flattenedIndex + indexInside * ").concat(n,";\n          }\n          let updateValue =\n              ").concat(dataTypeToGPUType(this.type),"(").concat(o,");\n          let flatIndex = getOutputIndexFromCoords(").concat(a,");\n\n          ").concat(this.sumDupeIndices?atomicAddSnippet("&result[flatIndex]","updateValue",this.type):"atomicStore(&result[flatIndex], bitcast<i32>(updateValue));","\n        }\n      }")},ScatterProgram}(),aj={kernelName:p.ScatterNd,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var t=e.inputs,n=e.backend,a=e.attrs,r=t.indices,i=t.updates,o=a.shape,s=p.backend_util.calculateShapes(i,r,o),u=s.sliceRank,c=s.numUpdates,d=s.sliceSize,l=s.strides,h=s.outputSize,f=[h/d,d];if(0===h)return n.makeTensorInfo(o,r.dtype);var m=reshape({inputs:{x:r},backend:n,attrs:{shape:[c,u]}}),g=reshape({inputs:{x:i},backend:n,attrs:{shape:[c,d]}}),y=g.dtype,v=fill({backend:n,attrs:{shape:f,value:0,dtype:y}}),x=[{type:"int32",data:[u]},{type:"int32",data:l},{type:"int32",data:[p.util.sizeFromShape(g.shape)]}],b=new aY(g.shape,u,m.shape.length,g.shape.length,l,f,y),S=n.runWebGPUProgram(b,[g,m],y,x,v),w=reshape({inputs:{x:S},backend:n,attrs:{shape:o}});return n.disposeData(m.dataId),n.disposeData(g.dataId),n.disposeData(S.dataId),w}},aQ=function(){function SearchSortedProgram(e,t){this.outputShape=[],this.variableNames=["sortedSequence","values"],this.uniforms="numInputs : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.side=t,this.shaderKey="search_sorted_".concat(t)}return SearchSortedProgram.prototype.getUserCode=function(){var e="left"===this.side?"<":"<=";return"\n      fn findBound(batch: i32, value: f32) -> i32 {\n        var left = i32(0);\n        var right = uniforms.numInputs;\n        while (left < right) {\n          var mid = (left + right) / 2;\n          if (getSortedSequence(batch, mid) ".concat(e," value) {\n            left = mid + 1;\n          } else {\n            right = mid;\n          }\n        }\n        return right;\n      }\n\n      ").concat(getMainHeaderString("index")," {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let value = getValuesByOutputIndex(index);\n          setOutputAtIndexI32(index, findBound(coords[0], value));\n        }\n      }\n    ")},SearchSortedProgram}(),aZ={kernelName:p.SearchSorted,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var t=e.inputs,n=e.backend,a=e.attrs,r=t.sortedSequence,i=t.values,o=a.side,s=new aQ([i.shape[0],i.shape[1]],o),u=[{type:"int32",data:[r.shape[1]]}];return n.runWebGPUProgram(s,[r,i],"int32",u)}},a$=function(){function SelectProgram(e,t,n){this.variableNames=["c","a","b"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.cRank=e,this.rank=n,this.shaderKey="select"}return SelectProgram.prototype.getUserCode=function(){if(this.rank>4)throw Error("Where for rank ".concat(this.rank," is not yet supported"));if(1===this.rank)t="resRC",e="resRC";else{for(var e,t,n=["resRC.x","resRC.y","resRC.z","resRC.w"],a=[],r=[],i=0;i<this.outputShape.length;i++)r.push("".concat(n[i])),i<this.cRank&&a.push("".concat(n[i]));e=a.join(),t=r.join()}return"\n      ".concat(getMainHeaderString("index")," {\n        if (index < uniforms.size) {\n          let resRC = getCoordsFromIndex(index);\n          let cVal = getC(").concat(e,");\n          if (cVal >= 1.0) {\n            setOutputAtIndex(index, getA(").concat(t,"));\n          } else {\n            setOutputAtIndex(index, getB(").concat(t,"));\n          }\n        }\n      }\n    ")},SelectProgram}(),aJ={kernelName:p.Select,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var t=e.inputs,n=e.backend,a=t.condition,r=t.t,i=t.e,o=new a$(a.shape.length,r.shape,r.shape.length);return n.runWebGPUProgram(o,[a,r,i],p.upcastType(r.dtype,i.dtype))}},a2=unaryKernelFunc({opType:o.SELU}),a0={kernelName:p.Selu,backendName:"webgpu",kernelFunc:a2},a1=unaryKernelFunc({opType:o.SIGMOID}),a3={kernelName:p.Sigmoid,backendName:"webgpu",kernelFunc:a1},a4=unaryKernelFunc({opType:o.SIGN}),a6={kernelName:p.Sign,backendName:"webgpu",kernelFunc:a4},a5=unaryKernelFunc({opType:o.SIN}),a8={kernelName:p.Sin,backendName:"webgpu",kernelFunc:a5},a9=unaryKernelFunc({opType:o.SINH}),a7={kernelName:p.Sinh,backendName:"webgpu",kernelFunc:a9},re=unaryKernelFunc({opType:o.SOFTPLUS}),rt={kernelName:p.Softplus,backendName:"webgpu",kernelFunc:re},rn=function(){function SpaceToBatchNDProgram(e,t,n,a,r,i){var o=this;this.variableNames=["x"],this.outputShape=[],this.uniforms="",this.workgroupSize=[64,1,1],this.size=!0;for(var s=Array(a.length),u=0;u<s.length;u++)s[u]=a[r[u]];this.outputShape=s,this.newDim=r,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=e,this.paddedXShape=t,this.uniforms+="reshapedPaddedXShape : ".concat(getCoordsDataType(a.length),", paddedXShapeStrides : ").concat(getCoordsDataType(i),", "),n.map(function(e,t){o.uniforms+=" pad".concat(t," : vec2<i32>,")}),this.shaderKey="spaceToBatchND_".concat(r)}return SpaceToBatchNDProgram.prototype.getUserCode=function(){var e=getCoordsDataType(this.outputShape.length),t=getSwitchedCoords(this.newDim);return"\n      ".concat(getCoordsFromIndexSnippet(this.paddedXShape,"PaddedX"),"\n      ").concat(getMainHeaderString("index")," {\n        if(index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let switchedIndex = getIndexFromCoords").concat(this.outputShape.length,"D(").concat(e,"(").concat(t,"), uniforms.reshapedPaddedXShape);\n          let paddedCoords = getPaddedXCoordsFromIndex(switchedIndex);\n          ").concat(padCommon(this.xShape,!0),"\n        }\n      }\n    ")},SpaceToBatchNDProgram}(),ra={kernelName:p.SpaceToBatchND,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,a=e.attrs,r=t.x,i=a.blockShape,o=a.paddings;p.util.assert(r.shape.length<=4,function(){return"spaceToBatchND for rank > 4 with a WebGPU backend not implemented yet"});var s=i.reduce(function(e,t){return e*t}),u=[[0,0]];u.push.apply(u,__spreadArray([],__read(o),!1));for(var c=1+i.length;c<r.shape.length;++c)u.push([0,0]);var d=u.map(function(e,t){return e[0]+r.shape[t]+e[1]}),l=p.backend_util.getReshaped(d,i,s,!1),h=p.backend_util.getPermuted(l.length,i.length,!1),f=p.backend_util.getReshapedPermuted(d,i,s,!1),m=p.util.computeStrides(d),g=new rn(r.shape,d,u,l,h,m.length),y=[{type:"int32",data:l},{type:"int32",data:m}];u.map(function(e){return y.push({type:"int32",data:[e[0],e[1]]})});var v=n.runWebGPUProgram(g,[r],r.dtype,y),x=reshape({inputs:{x:v},backend:n,attrs:{shape:f}});return n.disposeData(v.dataId),x}},rr=function(){function SparseSegmentSumProgram(e,t,n){this.variableNames=["input","indices","segmentIds"],this.outputShape=[],this.uniforms="segmentSize : i32, sparseSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e,this.type=n,this.dispatchLayout=flatDispatchLayout([t]),this.dispatch=computeDispatch(this.dispatchLayout,[t],this.workgroupSize),this.shaderKey="sparseSegmentSum"}return SparseSegmentSumProgram.prototype.getUserCode=function(){return"\n    ".concat(getMainHeaderString("index")," {\n      if (index < uniforms.sparseSize) {\n        let indexInSegmentIds = index / uniforms.segmentSize;\n        let indexInSegment = index % uniforms.segmentSize;\n        let indexInInput = indices[indexInSegmentIds];\n        let segmentId = segmentIds[indexInSegmentIds];\n\n        let value = input[indexInInput * uniforms.segmentSize + indexInSegment];\n        let outIndex = segmentId * uniforms.segmentSize + indexInSegment;\n        ").concat(atomicAddSnippet("&result[outIndex]","value",this.type),"\n      }\n    }\n  ")},SparseSegmentSumProgram}(),ri=function(){function SparseSegmentIdCountProgram(e,t){this.variableNames=["segmentIds"],this.outputShape=[],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=[e],this.dispatchLayout=flatDispatchLayout(t),this.dispatch=computeDispatch(this.dispatchLayout,t,this.workgroupSize),this.shaderKey="sparseSegmentIdCountProgram"}return SparseSegmentIdCountProgram.prototype.getUserCode=function(){return"\n    ".concat(getMainHeaderString("index")," {\n      if (index < uniforms.segmentIdsShape) {\n        let segmentId = segmentIds[index];\n        ").concat(atomicAddSnippet("&result[segmentId]","1","int32"),"\n      }\n    }\n  ")},SparseSegmentIdCountProgram}(),ro=function(){function SparseSegmentMeanProgram(e,t){this.variableNames=["segmentSum","sameSegmentIdCount"],this.outputShape=[],this.uniforms="segmentSize : i32",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.type=t,this.dispatchLayout=flatDispatchLayout(e),this.dispatch=computeDispatch(this.dispatchLayout,e,this.workgroupSize),this.shaderKey="sparseSegmentMean"}return SparseSegmentMeanProgram.prototype.getUserCode=function(){return"\n    ".concat(getMainHeaderString("index")," {\n      if (index < uniforms.size) {\n        let segmentId = index / uniforms.segmentSize;\n        let count = sameSegmentIdCount[segmentId];\n        if (count != 0) {\n          ").concat("float32"===this.type?"setOutputAtIndex(index, segmentSum[index] / f32(count));":"setOutputAtIndexI32(index, segmentSum[index] / count);","\n        }\n      }\n    }\n  ")},SparseSegmentMeanProgram}();/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sparseSegmentReduce(e,t,n,a,r){void 0===a&&(a=!1);var i,o=p.util.sizeFromShape(e.shape)/e.shape[0],s=e.dtype,u=p.util.sizeFromShape(t.shape),c=r.readSync(n.dataId),d=u>0?c[u-1]+1:0,l=e.shape.slice();l[0]=d;var h=u*o,f=fill({backend:r,attrs:{shape:l,value:0,dtype:s}});i=new rr(l,h,s);var m=[{type:"int32",data:[o]},{type:"int32",data:[h]}],g=r.runWebGPUProgram(i,[e,t,n],s,m,f);if(a)return g;var y=fill({backend:r,attrs:{shape:[d],value:0,dtype:"int32"}});i=new ri(d,n.shape);var v=r.runWebGPUProgram(i,[n],"int32",null,y),x=fill({backend:r,attrs:{shape:l,value:0,dtype:s}});i=new ro(l,s),m=[{type:"int32",data:[o]}];var b=r.runWebGPUProgram(i,[g,v],s,m,x);return r.disposeData(g.dataId),r.disposeData(v.dataId),b}var rs={kernelName:p.SparseSegmentMean,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var t=e.inputs,n=e.backend;return sparseSegmentReduce(t.data,t.indices,t.segmentIds,!1,n)}},ru={kernelName:p.SparseSegmentSum,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var t=e.inputs,n=e.backend;return sparseSegmentReduce(t.data,t.indices,t.segmentIds,!0,n)}},rc=function(){function TileProgram(e,t){this.variableNames=["A"],this.workgroupSize=[64,1,1],this.size=!0;for(var n=Array(e.length),a=0;a<n.length;a++)n[a]=e[a]*t[a];this.outputShape=n,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.rank=this.outputShape.length,this.shaderKey="tile"}return TileProgram.prototype.getUserCode=function(){var e=function(e,t){if(void 0===t&&(t=""),e>=5)throw Error("Tile for rank ".concat(e," is not yet supported"));if(1===e)return"(resRC % ".concat(t,"aShape)");for(var n=["resRC.x","resRC.y","resRC.z","resRC.w"],a=[],r=0;r<e;r++)a.push("(".concat(n[r]," % ").concat(t,"aShape[").concat(r,"])"));return a.join()}(this.rank,"uniforms.");return"\n      ".concat(getMainHeaderString("index")," {\n        if (index < uniforms.size) {\n          let resRC = getCoordsFromIndex(index);\n          setOutputAtIndex(index, getA(").concat(e,"));\n        }\n      }\n    ")},TileProgram}();/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tile(e){var t=e.inputs,n=e.backend,a=e.attrs,r=t.x,i=a.reps;if(n.shouldExecuteOnCPU([r])||"string"===r.dtype||r.shape.length>=5){var o=n.readSync(r.dataId),s="string"===r.dtype?o.map(function(e){return p.util.decodeString(e)}):o,u=tileImplCPU(p.buffer(r.shape,r.dtype,s),i);return n.makeTensorInfo(u.shape,u.dtype,u.values)}var c=new rc(r.shape,i);return n.runWebGPUProgram(c,[r],r.dtype)}var rd={kernelName:p.Tile,backendName:"webgpu",kernelFunc:tile},rp={kernelName:p.SparseToDense,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var t=e.inputs,n=e.backend,a=e.attrs,r=t.sparseIndices,i=t.sparseValues,o=t.defaultValue,s=a.outputShape,u=p.backend_util.calculateShapes(i,r,s),c=u.sliceRank,d=u.numUpdates,l=u.sliceSize,h=u.strides,f=u.outputSize;if("string"===i.dtype){var m=scatterImplCPU(n.bufferSync(r),n.bufferSync(i),s,f,l,d,c,h,p.util.decodeString(n.readSync(o.dataId)[0]),!1);return n.makeTensorInfo(s,m.dtype,m.values)}var g=[f/l,l],y=reshape({inputs:{x:r},backend:n,attrs:{shape:[d,c]}}),v=i.shape.length?reshape({inputs:{x:i},backend:n,attrs:{shape:[d,l]}}):identity({inputs:{x:i},backend:n}),x=v.dtype,b=n.makeTensorInfo([],x,p.util.makeZerosTypedArray(1,x)),S=reshape({inputs:{x:o},backend:n,attrs:{shape:Array(g.length).fill(1)}}),w=tile({inputs:{x:S},backend:n,attrs:{reps:g}}),C=[{type:"int32",data:[c]},{type:"int32",data:h},{type:"int32",data:[p.util.sizeFromShape([d,l])]}];switch(d){case 0:break;case 1:var k=new aY([d,l],c,y.shape.length,v.shape.length,h,g,x,!1);n.runWebGPUProgram(k,[v,y],x,C,w);break;default:var k=new aY([d,l],c,y.shape.length,b.shape.length,h,g,x,!1);n.runWebGPUProgram(k,[b,y],x,C,w);var k=new aY([d,l],c,y.shape.length,v.shape.length,h,g,x);n.runWebGPUProgram(k,[v,y],x,C,w)}var I=reshape({inputs:{x:w},backend:n,attrs:{shape:s}});return n.disposeData(y.dataId),n.disposeData(v.dataId),n.disposeData(S.dataId),n.disposeData(b.dataId),n.disposeData(w.dataId),I}},rl={kernelName:p.SplitV,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,a=e.attrs,r=t.x,i=a.numOrSizeSplits,o=a.axis,s=p.util.parseAxisParam(o,r.shape)[0],u=p.backend_util.prepareSplitSize(r,i,s),c=Array(r.shape.length).fill(0),d=r.shape.slice();return u.map(function(e){var t=__spreadArray([],__read(d),!1);t[s]=e;var a=slice({inputs:{x:r},backend:n,attrs:{begin:c,size:t}});return c[s]+=e,a})}},rh=unaryKernelFunc({opType:o.SQRT}),rf={kernelName:p.Sqrt,backendName:"webgpu",kernelFunc:rh},rm={kernelName:p.Square,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,a=t.x,r=new L(a.shape,o.SQUARE);return n.runWebGPUProgram(r,[a],a.dtype)}},rg=binaryKernelFunc({opType:i.SQUARED_DIFFERENCE}),ry={kernelName:p.SquaredDifference,backendName:"webgpu",kernelFunc:rg},rv={kernelName:p.Step,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var t=e.inputs,n=e.attrs,a=e.backend,r=t.x,i=new L(r.shape,o.STEP,"stepAlpha : f32,"),s=[{type:"float32",data:[n.alpha]}];return a.runWebGPUProgram(i,[r],r.dtype,s)}},rx=function(){function StridedSliceProgram(e){this.variableNames=["x"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]);var t=getCoordsDataType(this.outputShape.length);this.uniforms="begin : ".concat(t,",  strides : ").concat(t,", "),this.shaderKey="stridedSlice"}return StridedSliceProgram.prototype.getUserCode=function(){var e=this,t=this.outputShape.length,n="";if(1===t)n="coords * uniforms.strides + uniforms.begin";else{var a=0;n=this.outputShape.map(function(t,n){return a++,1===e.outputShape.length?"coords * uniforms.strides[".concat(n,"] + uniforms.begin[").concat(n,"]"):"coords[".concat(a-1,"] * uniforms.strides[").concat(n,"] + uniforms.begin[").concat(n,"]")}).join(",")}return"\n       ".concat(getMainHeaderString("index")," {\n         if (index < uniforms.size) {\n           let coords = getCoordsFromIndex(index);\n           setOutputAtIndex(index, getX(").concat(n,"));\n         }\n       }\n     ")},StridedSliceProgram}(),rb={kernelName:p.StridedSlice,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var t,n=e.inputs,a=e.backend,r=e.attrs,i=n.x,o=r.begin,s=r.end,u=r.strides,c=r.beginMask,d=r.endMask,l=r.ellipsisMask,h=r.newAxisMask,f=r.shrinkAxisMask,m=p.slice_util.sliceInfo(i.shape,o,s,u,c,d,l,h,f),g=m.finalShapeSparse,y=m.finalShape,v=m.isIdentity,x=m.sliceDim0,b=m.isSimpleSlice,S=m.begin,w=m.end,C=m.strides;if(v)t=reshape({inputs:{x:i},backend:a,attrs:{shape:y}});else if(x||b){p.util.assert(i.shape.length>=1,function(){return"Input must have rank at least 1, got: ".concat(i.shape.length)});var k=p.slice_util.computeOutShape(S,w,C),I=slice({inputs:{x:i},backend:a,attrs:{begin:S,size:k}});t=reshape({inputs:{x:I},backend:a,attrs:{shape:y}}),a.disposeData(I.dataId)}else if(a.shouldExecuteOnCPU([i])){var P=a.readSync(i.dataId),R=stridedSliceImplCPU(g,p.buffer(i.shape,i.dtype,P),C,S);t=a.makeTensorInfo(y,i.dtype,R.values)}else{var D=new rx(g),_=[{type:"int32",data:S},{type:"int32",data:C}],R=a.runWebGPUProgram(D,[i],i.dtype,_);t=reshape({inputs:{x:R},backend:a,attrs:{shape:y}}),a.disposeData(R.dataId)}return t}},rS={kernelName:p.StringNGrams,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,a=e.attrs,r=a.separator,i=a.nGramWidths,o=a.leftPad,s=a.rightPad,u=a.padWidth,c=a.preserveShortSequences,d=t.data,p=t.dataSplits,l=n.readSync(d.dataId),h=n.readSync(p.dataId),f=__read(new ee(r,i,o,s,u,c).compute(l,h),2),m=f[0],g=f[1];return[n.makeTensorInfo([m.length],"string",m),n.makeTensorInfo(p.shape,"int32",g)]}},rw=binaryKernelFunc({opType:i.SUB,cpuKernelImpl:et,supportsComplex:!0}),rC={kernelName:p.Sub,backendName:"webgpu",kernelFunc:rw},rk=unaryKernelFunc({opType:o.TAN}),rI={kernelName:p.Tan,backendName:"webgpu",kernelFunc:rk},rP=unaryKernelFunc({opType:o.TANH}),rR={kernelName:p.Tanh,backendName:"webgpu",kernelFunc:rP},rD={kernelName:p.TensorScatterUpdate,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var t=e.inputs,n=e.backend;e.attrs;var a=t.tensor,r=t.indices,i=t.updates,o=p.backend_util.calculateShapes(i,r,a.shape),s=o.sliceRank,u=o.numUpdates,c=o.sliceSize,d=o.strides,l=o.outputSize,h=[l/c,c];if(0===l)return n.makeTensorInfo(a.shape,r.dtype);var f=[],m=reshape({inputs:{x:r},backend:n,attrs:{shape:[u,s]}});f.push(m);var g=reshape({inputs:{x:i},backend:n,attrs:{shape:[u,c]}});f.push(g);var y=reshape({inputs:{x:a},backend:n,attrs:{shape:h}});f.push(y);var v=tile({inputs:{x:y},backend:n,attrs:{reps:Array(h.length).fill(1)}}),x=new aY([u,c],s,m.shape.length,g.shape.length,d,h,a.dtype,!1),b=[{type:"int32",data:[s]},{type:"int32",data:d},{type:"int32",data:[p.util.sizeFromShape([u,c])]}],S=n.runWebGPUProgram(x,[g,m],y.dtype,b,v);f.push(S);var w=reshape({inputs:{x:S},backend:n,attrs:{shape:a.shape}});return f.forEach(function(e){return n.disposeData(e.dataId)}),w}},r_=function(){function SwapProgram(e){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms="inputSize : i32, firstPass : i32, negativeInf : f32,\n        dir : i32, inc : i32,",this.shaderKey="swap"}return SwapProgram.prototype.getUserCode=function(){return"\n        ".concat(getMainHeaderString("index")," {\n          if (index < uniforms.size) {\n            let outC = getCoordsFromIndex(index);\n            let batch = outC[0];\n            let elemIdx = outC[1];\n            // We compare elements pair-wise within a group of size 2 * inc.\n            // The comparing rule for each group alternates between ascending\n            // and descending. Within each group, we compare each pair at\n            // positions i and i+inc. To decide whether an element at position i\n            // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n            // inc, it is in the first half of the group, we denote it as x0,\n            // otherwise we denote it as x1.\n            // For example, as shown in the Bitonic top K paper referenced\n            // above, Figure5(a) shows that element[1] is in the second half of\n            // the group when group size is 2, but it is in the first half of\n            // the group when group size is 4.\n            let isFirstInPair = elemIdx % (2 * uniforms.inc) < uniforms.inc;\n            var i = 0;\n            if (isFirstInPair) {\n              i = elemIdx;\n            } else {\n              i = elemIdx - uniforms.inc;\n            }\n\n            var i0 = 0;\n            if (uniforms.firstPass == 1) {\n              i0 = i;\n            } else {\n              i0 = i32(getIndices(batch, i));\n            }\n\n            var i1 = 0;\n            if (uniforms.firstPass == 1) {\n              i1 = i + uniforms.inc;\n            } else {\n              i1 = i32(getIndices(batch, i + uniforms.inc));\n            }\n\n            var x0 = f32(0.0);\n            var x1 = f32(0.0);\n            if (i0 < uniforms.inputSize) {\n              x0 = getX(batch, i0);\n            } else {\n              x0 = uniforms.negativeInf;\n            }\n            if (i1 < uniforms.inputSize) {\n              x1 = getX(batch, i1);\n            } else {\n              x1 = uniforms.negativeInf;\n            }\n\n            let reverse = elemIdx % (2 * uniforms.dir) >= uniforms.dir;\n            let isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n            if (reverse == isGreater) {\n              // Elements in opposite order of direction\n              let iTemp = i0;\n              i0 = i1;\n              i1 = iTemp;\n            }\n            if (isFirstInPair) {\n              setOutputAtIndex(index, f32(i0));\n            } else {\n              setOutputAtIndex(index, f32(i1));\n            }\n          }\n        }\n      ")},SwapProgram}(),rA=function(){function MergeProgram(e){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms="inputSize : i32, firstPass : i32, k : i32,",this.shaderKey="merge"}return MergeProgram.prototype.getUserCode=function(){return"\n        ".concat(getMainHeaderString("index")," {\n          if (index < uniforms.size) {\n            let outC = getCoordsFromIndex(index);\n            let batch = outC[0];\n            let elemIdx = outC[1];\n            // The output size is half of the previous size.\n            // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _\n            // (k=4), we only need to output the indices at positions |, the\n            // indices at positions _ can be thrown away, see Figure5(b) After\n            // Phase 2 (Merge phase) in the Bitonic Top K paper referenced\n            // above.\n            // For example, the paper shows we only need to output the orange\n            // bars. The output sequence should look like this | | | | | | | |.\n            // Because the sequence is halved, to map the output index back to\n            // the previous sequence to find the corresponding value, we need\n            // to double the index. When we double the index, we basically\n            // interpolate a position, so 2i looks like\n            // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k\n            // position of each 2k positions by - elemIdx % k. E.g. for output\n            // at index 4,5,6,7, we want to get the corresponding element at\n            // original index 8,9,10,11, for output at index 8,9,10,11,\n            // we want to get the corresponding element at original index\n            // 16,17,18,19, so on and so forth.\n\n            var i = 0;\n            if (elemIdx < uniforms.k) {\n              i = elemIdx;\n            } else {\n              i = elemIdx * 2 - elemIdx % uniforms.k;\n            }\n            var i0 = 0;\n            if (uniforms.firstPass == 1) {\n              i0 = i;\n            } else {\n              i0 = i32(getIndices(batch, i));\n            }\n            var i1 = 0;\n            if (uniforms.firstPass == 1) {\n              i1 = i + uniforms.k;\n            } else {\n              i1 = i32(getIndices(batch, i + uniforms.k));\n            }\n\n            let x0 = getX(batch, i0);\n            var x1 = f32(0.0);\n            if (i1 < uniforms.inputSize) {\n              x1 = getX(batch, i1);\n            } else {\n              x1 = x0;\n            }\n\n            if (x0 >= x1) {\n              setOutputAtIndex(index, f32(i0));\n            } else {\n              setOutputAtIndex(index, f32(i1));\n            }\n          }\n        }\n      ")},MergeProgram}();function disposeIntermediateTensorInfoOrNull(e,t){null!==t&&e.disposeData(t.dataId)}function roundUpToPow2(e){for(var t=1;t<e;)t*=2;return t}var rz={kernelName:p.TopK,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,a=e.attrs,r=t.x,i=a.k,o=a.sorted,s=r.shape,u=s[s.length-1];if(n.shouldExecuteOnCPU([r])){var c=__read(topKImplCPU(n.readSync(r.dataId),s,r.dtype,i,o),2),d=c[0],l=c[1];return[n.makeTensorInfo(d.shape,d.dtype,d.values),n.makeTensorInfo(l.shape,l.dtype,l.values)]}if(0===i)return s[s.length-1]=0,[n.makeTensorInfo(s,r.dtype,[]),n.makeTensorInfo(s,"int32",[])];if(1===u)return[r,fill({attrs:{shape:s,dtype:"int32",value:0},backend:n})];for(var h=p.util.sizeFromShape(s)/u,f=reshape({inputs:{x:r},attrs:{shape:[h,u]},backend:n}),m=roundUpToPow2(i),g=roundUpToPow2(u),y=null,getInputs=function(){return null===y?[f,f]:[f,y]},runSwap=function(e,t,a){var r=getInputs(),i=new r_(a),o=[{type:"int32",data:[u]},{type:"int32",data:[null===y?1:0]},{type:"float32",data:[Number.NEGATIVE_INFINITY]},{type:"int32",data:[e]},{type:"int32",data:[t]}],s=y;y=n.runWebGPUProgram(i,r,"int32",o),disposeIntermediateTensorInfoOrNull(n,s)},v=1;v<m;v*=2)for(var x=2*v,b=v;b>=1;b/=2)runSwap(x,b,[h,g]);for(var S=g;S>m;S/=2){var w=getInputs(),C=new rA([h,S/2]),k=[{type:"int32",data:[u]},{type:"int32",data:[null===y?1:0]},{type:"int32",data:[m]}],I=y;y=n.runWebGPUProgram(C,w,"int32",k),disposeIntermediateTensorInfoOrNull(n,I);for(var v=m/2,x=2*v,b=v;b>=1;b/=2)runSwap(x,b,y.shape)}var P=y;y=slice({inputs:{x:y},backend:n,attrs:{begin:0,size:[h,i]}}),disposeIntermediateTensorInfoOrNull(n,P);var R=gatherV2({inputs:{x:f,indices:y},backend:n,attrs:{axis:1,batchDims:1}});disposeIntermediateTensorInfoOrNull(n,f);var D=s.slice(0,-1);D.push(i),P=y,y=reshape({inputs:{x:y},attrs:{shape:D},backend:n}),disposeIntermediateTensorInfoOrNull(n,P);var _=R;return R=reshape({inputs:{x:R},attrs:{shape:D},backend:n}),disposeIntermediateTensorInfoOrNull(n,_),[R,y]}},rN=function(){function TransformProgram(e){this.variableNames=["Image","Transforms"],this.uniforms="interpolationModeId : i32, fillModeId : i32, fillValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="transform"}return TransformProgram.prototype.getUserCode=function(){return"\n          fn mapCoord(outCoord : f32, len : f32) -> f32{\n            var inCoord = outCoord;\n            if(uniforms.fillModeId == 2) {\n              if (inCoord < 0.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz2 = 2.0 * len;\n                  if (inCoord < sz2) {\n                    inCoord = sz2 * f32(i32(f32(-inCoord / sz2))) +\n                    inCoord;\n                  }\n                  if (inCoord < -len) {\n                    inCoord = inCoord + sz2;\n                  } else {\n                    inCoord = -inCoord - 1.0;\n                  }\n                }\n              } else if (inCoord > len - 1.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz2 = 2.0 * len;\n                  inCoord = inCoord - sz2 * f32(i32(f32(inCoord / sz2)));\n                  if (inCoord >= len) {\n                    inCoord = sz2 - inCoord - 1.0;\n                  }\n                }\n              }\n              return clamp(inCoord, 0.0, len - 1.0);\n            } else if (uniforms.fillModeId == 3) {\n              if (inCoord < 0.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz = len - 1.0;\n                  inCoord = inCoord + len * (f32(i32(f32(-inCoord / sz))) + 1.0);\n                }\n              } else if (inCoord > len - 1.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz = len - 1.0;\n                  inCoord = inCoord - len * f32(i32(f32(inCoord / sz)));\n                }\n              }\n              return clamp(inCoord, 0.0, len - 1.0);\n            } else if (uniforms.fillModeId == 4) {\n              return clamp(outCoord, 0.0, len - 1.0);\n            }\n            return outCoord;\n          }\n          fn readWithFillValue(batch : i32, coordY : i32, coordX : i32,\n            channel : i32) -> f32 {\n            var outputValue : f32;\n            if (0 <= coordY && coordY < uniforms.imageShape[1] && 0 <= coordX && coordX < uniforms.imageShape[2]) {\n                outputValue = getImage(batch, coordY, coordX, channel);\n            } else {\n              outputValue = uniforms.fillValue;\n            }\n            return outputValue;\n          }\n\n          ".concat(getMainHeaderString("index")," {\n            if (index < uniforms.size) {\n              let coords = getCoordsFromIndex(index);\n              var outputValue : f32;\n              let batch = coords[0];\n              let x = coords[2];\n              let y = coords[1];\n              let channel = coords[3];\n              let xf = f32(x);\n              let yf = f32(y);\n              let a1 = getTransforms(batch, 0);\n              let a2 = getTransforms(batch, 1);\n              let a3 = getTransforms(batch, 2);\n              let b1 = getTransforms(batch, 3);\n              let b2 = getTransforms(batch, 4);\n              let b3 = getTransforms(batch, 5);\n              let c1 = getTransforms(batch, 6);\n              let c2 = getTransforms(batch, 7);\n              let projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = uniforms.fillValue;\n              } else {\n                let inX = (a1 * xf + a2 * yf + a3) / projection;\n                let inY = (b1 * xf + b2 * yf + b3) / projection;\n                let mapX = mapCoord(inX, f32(uniforms.imageShape[2]));\n                let mapY = mapCoord(inY, f32(uniforms.imageShape[1]));\n\n                if (uniforms.interpolationModeId == 1) {\n                  let coordY = i32(round(mapY));\n                  let coordX = i32(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  let yFloor = floor(mapY);\n                  let xFloor = floor(mapX);\n                  let yCeil = yFloor + 1.0;\n                  let xCeil = xFloor + 1.0;\n                  let valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, i32(yFloor), i32(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, i32(yFloor), i32(xCeil), channel);\n                  let valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, i32(yCeil), i32(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, i32(yCeil), i32(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutputAtIndex(index, outputValue);\n            }\n          }\n        ")},TransformProgram}(),rF={kernelName:p.Transform,backendName:"webgpu",kernelFunc:function(e){var t,n=e.inputs,a=e.backend,r=e.attrs,i=n.image,o=n.transforms,s=r.interpolation,u=r.fillMode,c=r.fillValue,d=r.outputShape,p=__read(i.shape,4),l=p[0],h=p[1],f=p[2],m=p[3],g=__read(null!=d?d:[h,f],2),y=[l,g[0],g[1],m],v=new rN(y);switch(u){case"constant":default:t=1;break;case"reflect":t=2;break;case"wrap":t=3;break;case"nearest":t=4}var x=[{type:"int32",data:["nearest"===s?1:2]},{type:"int32",data:[t]},{type:"float32",data:[c]}];return a.runWebGPUProgram(v,[i,o],"float32",x)}},rT={kernelName:p.Unpack,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var t=e.inputs,n=e.backend,a=e.attrs,r=t.value,i=a.axis;i<0&&(i+=r.shape.length);for(var o=r.shape.length,s=r.shape[i],u=Array(o-1),c=0,d=0;d<o;d++)d!==i&&(u[c++]=r.shape[d]);var p=[],l=Array(o).fill(0),h=r.shape.slice();h[i]=1;for(var f=Array(s),d=0;d<f.length;d++){l[i]=d;var m=slice({inputs:{x:r},backend:n,attrs:{begin:l,size:h}}),g=reshape({inputs:{x:m},backend:n,attrs:{shape:u}});f[d]=g,p.push(m)}return p.forEach(function(e){return n.disposeData(e.dataId)}),f}},rB=function(){function UnsortedSegmentSumProgram(e,t,n){if(this.outputShape=[],this.variableNames=["x","segmentIds"],this.uniforms="numSegments : i32, xSize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=t,this.dispatchLayout=flatDispatchLayout(e),this.dispatch=computeDispatch(this.dispatchLayout,e,this.workgroupSize),"float32"!==n&&"int32"!==n)throw Error("UnsortedSegmentSum only supports float32 and int32\n              types, does not support ".concat(n," type."));this.type=n,this.shaderKey="unsortedSegmentSum"}return UnsortedSegmentSumProgram.prototype.getUserCode=function(){return"\n    ".concat(getMainHeaderString("index")," {\n      if (index < uniforms.xSize) {\n        let coords = getXCoordsFromIndex(index);\n        let b = coords[0];\n        let inCol = coords[1];\n\n        let segmentId = i32(getSegmentIds(inCol));\n        if (segmentId >= 0) {\n          let flatIndex = b * uniforms.numSegments + segmentId % uniforms.numSegments;\n          let value = getX(b, inCol);\n\n          ").concat(atomicAddSnippet("&result[flatIndex]","value",this.type),"\n        }\n      }\n    }\n  ")},UnsortedSegmentSumProgram}(),rL={kernelName:p.UnsortedSegmentSum,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){var t=e.inputs,n=e.backend,a=e.attrs,r=t.x,i=t.segmentIds,o=a.numSegments,s=r.shape.length,u=[],c=0,d=p.backend_util.getAxesPermutation([c],s),l=r;null!=d&&(u.push(l=transpose({inputs:{x:r},backend:n,attrs:{perm:d}})),c=p.backend_util.getInnerMostAxes(1,s)[0]);var h=p.backend_util.segment_util.computeOutShape(l.shape,c,o),f=p.util.sizeFromShape([l.shape[c]]),m=reshape({inputs:{x:l},backend:n,attrs:{shape:[-1,f]}});u.push(m);var g=r.dtype,y=[m.shape[0],o],v=fill({backend:n,attrs:{shape:y,value:0,dtype:g}}),x=new rB(m.shape,y,g),b=[{type:"int32",data:[o]},{type:"int32",data:[p.util.sizeFromShape(m.shape)]}],S=n.runWebGPUProgram(x,[m,i],g,b,v),w=reshape({inputs:{x:S},backend:n,attrs:{shape:h}});u.push(S);var C=w;return null!=d&&(u.push(w),C=transpose({inputs:{x:C},backend:n,attrs:{perm:p.backend_util.getUndoAxesPermutation(d)}})),u.forEach(function(e){return n.disposeData(e.dataId)}),C}};try{for(var rM=__values([z,ea,ei,es,ec,ep,ey,ev,eb,eS,eC,eI,eR,e_,ez,eM,eW,eO,eV,eG,eq,eQ,e$,e1,e4,e8,B,e7,tn,to,tp,th,tm,tg,ty,tx,tS,tC,tI,tP,tR,t_,tL,tM,tF,tU,tO,tH,tK,tq,tZ,tJ,t2,t1,t4,t5,t8,t7,nt,_,na,nc,ni,ns,nl,nh,nf,ng,nv,nb,nw,T,nC,tt,nI,nR,n_,nA,nN,nT,nL,nE,nW,nV,nH,nX,nQ,n$,eB,n2,n0,n5,n1,n6,n8,eL,n9,ae,an,ar,au,tj,ac,ad,ap,e2,ah,am,ag,av,ab,aS,aw,aC,e0,aI,aR,a_,az,A,aF,aB,aM,aU,aO,aG,aK,aq,aj,aZ,aJ,a0,a3,a6,a8,a7,eX,rv,rb,rS,as,rt,ra,rs,ru,rp,rl,rf,rm,ry,rC,tQ,rI,rR,rD,rd,rz,rF,ef,rT,rL,af]),rW=rM.next();!rW.done;rW=rM.next()){var rU=rW.value;p.registerKernel(rU)}}catch(e){c={error:e}}finally{try{rW&&!rW.done&&(d=rM.return)&&d.call(rM)}finally{if(c)throw c.error}}t.WebGPUBackend=b,t.webgpu_util={__proto__:null,GPUBytesPerElement:GPUBytesPerElement,get MatMulProgramType(){return r},assertNotComplex:assertNotComplex,computeDispatch:computeDispatch,computeWorkPerThreadForConv2d:computeWorkPerThreadForConv2d,computeWorkgroupInfoForMatMul:computeWorkgroupInfoForMatMul,computeWorkgroupSizeForConv2d:computeWorkgroupSizeForConv2d,flatDispatchLayout:flatDispatchLayout,isWebGPUSupported:isWebGPUSupported,tilesFitEvenlyIntoShape:function(e,t){if(e.length!==t.length)throw Error("Cannot compute whether rank ".concat(e.length)+" tiles fit evenly into rank ".concat(t.length," shape")+" - ranks must match.");return t.every(function(t,n){return t%e[n]==0})}}}};